1,"Patch per Trattamenti CORE - v1.2","ITA/FRA","1","YAX3C","X3","1",
2,"TRT","SPEYAX3M",""
#<AdxTL>@(#)0.0.0.0 $Revision$
$ACTION

  Case ACTION
    When "OUVRE"      : Gosub OUVRE
    When "DEBUT"      : Gosub DEBUT
  Endcase

Return

###################################################################################################

$OUVRE

  Local Blbfile QRGPLAYSTORE_BLB, QRAPPLESTORE_BLB, QRCONFIG_BLB
  Local Clbfile QRBASE64_CLB(3)
  Local Integer COUNT
  Local Char SUCCESS(5), MESSAGE(250)
  Local Char PCOD(100)(1..10),PVAL(100)(1..10)

  #Qui estraggo il Dossier in cui sono presente [il servizio REST avrà sempre questa dicitura : AX3M_API_PROD, AX3M_API_SVIL, ecc]
  Local Char YDOSSIER(6): YDOSSIER = toupper(nomap(0))

Return

##################################################################################################

$DEBUT

  #QR ANDROID
  Call EXEC("AX3M_API_"+YDOSSIER, "GET", "api", "/Qr/GetGooglePlayStoreLink/", PCOD, PVAL, "{}", QRBASE64_CLB) From YRESTWS
  #Call EXEC("AX3M_API_Prod", "GET", "api", "/Qr/GetGooglePlayStoreLink/", PCOD, PVAL, "{}", QRBASE64_CLB) From YRESTWS     #old

  COUNT = b64Decode( QRBASE64_CLB, QRGPLAYSTORE_BLB )
  [M:YAX3M]YQRANDROID = QRGPLAYSTORE_BLB

  Affzo [M:YAX3M]YQRANDROID

  #QR APPLE
  Raz QRBASE64_CLB, PCOD, PVAL
  Call EXEC("AX3M_API_"+YDOSSIER, "GET", "api", "/Qr/GetAppleStoreLink/", PCOD, PVAL, "{}", QRBASE64_CLB) From YRESTWS
  #Call EXEC("AX3M_API_Prod", "GET", "api", "/Qr/GetAppleStoreLink/", PCOD, PVAL, "{}", QRBASE64_CLB) From YRESTWS     #old

  COUNT = b64Decode( QRBASE64_CLB, QRAPPLESTORE_BLB )
  [M:YAX3M]YQRAPPLE = QRAPPLESTORE_BLB

  Affzo [M:YAX3M]YQRAPPLE

  #QR CONFIG
  Raz QRBASE64_CLB, PCOD, PVAL
  Call EXEC("AX3M_API_"+YDOSSIER, "GET", "api", "/Qr/GetConfig/", PCOD, PVAL, "{}", QRBASE64_CLB) From YRESTWS
  #Call EXEC("AX3M_API_Prod", "GET", "api", "/Qr/GetConfig/", PCOD, PVAL, "{}", QRBASE64_CLB) From YRESTWS   #old

  COUNT = b64Decode( QRBASE64_CLB, QRCONFIG_BLB )
  [M:YAX3M]YQRCONFIG = QRCONFIG_BLB

  Affzo [M:YAX3M]YQRCONFIG

Return
**********
7,"TRT","SPEYAX3M",""
2,"TRT","YAX3MAUTHLIB",""
#<AdxTL>@(#)0.0.0.0 $Revision$ 
##############################################################################################
##############################################################################################
############################################# UTENTI #########################################
##############################################################################################
##############################################################################################
Subprog YGET_DEMOUSR(YRESPONSE)
  Variable Clbfile YRESPONSE

  Local File YAX3MUSER [F:YAX3MU]

  Columns  [F:YAX3MU] (USERNAME)
  Filter [F:YAX3MU] Where ISDEMO = 2 & ENAFLG = 2
  Read [F:YAX3MU] Last # con più utenti implementare una BL per acquisirne uno random

  Local Integer DATA_COUNT, RESP_COUNT
  Local Char DATA_FIELDS(250)(3)
  Local Clbfile RESPONSE_FIELDS(1)(0..)

  Gosub GET_WS_CONSTANTS From YUTILS

  If fstat <> 0
    # Token non trovato
    RESPONSE_FIELDS(RESP_COUNT) = func YJSONSERIALIZE.GET_INT("statusCode", NOT_FOUND, 1) : RESP_COUNT += 1
    RESPONSE_FIELDS(RESP_COUNT) = func YJSONSERIALIZE.GET_STR("message", "Utenti demo non trovati!", 1) : RESP_COUNT += 1
  Else
    Raz DATA_FIELDS : DATA_COUNT = 0
    DATA_FIELDS(DATA_COUNT) = func YJSONSERIALIZE.GET_STR("username", [F:YAX3MU]USERNAME, 2) : DATA_COUNT += 1
    DATA_FIELDS(DATA_COUNT) = func YJSONSERIALIZE.GET_STR("email", [F:YAX3MU]EMAIL, 1) : DATA_COUNT += 1
    # li seleziono attivi quindi imposto 1 (true) di default
    DATA_FIELDS(DATA_COUNT) = func YJSONSERIALIZE.GET_BOOL("enabled", 1, 1) : DATA_COUNT += 1

    # --- Risposta finale OK ---
    Raz RESPONSE_FIELDS : RESP_COUNT = 0
    RESPONSE_FIELDS(RESP_COUNT) = func YJSONSERIALIZE.GET_INT("statusCode", SUCCESS, 1) : RESP_COUNT += 1
    RESPONSE_FIELDS(RESP_COUNT) = func YJSONSERIALIZE.GET_CLBOBJ("data", DATA_FIELDS, 0, 1) : RESP_COUNT += 1
    RESPONSE_FIELDS(RESP_COUNT) = func YJSONSERIALIZE.GET_STR("message", "Utente demo trovato!", 1) : RESP_COUNT += 1
  Endif

  YRESPONSE = func YJSONSERIALIZE.GET_CLBOBJ(AVOID.ACHAR, RESPONSE_FIELDS, 1, 1)

End

##############################################################################################
Subprog YUPSERT_USR(YUSERNAME, YX3USERNAME, YNOMUSR, YEMAIL, YENAFLG, YISDEMO, YHASH, YSALT, YRESPONSE)

  Variable Char YUSERNAME
  Variable Char YX3USERNAME
  Variable Char YNOMUSR
  Variable Char YEMAIL
  Variable Integer YENAFLG
  Variable Integer YISDEMO
  Variable Char YHASH
  Variable Char YSALT

  Variable Clbfile YRESPONSE

  Local File YAX3MUSER [F:YAX3MU]
  Local Integer YI
  Local Char YPASSWORD(50)
  Local Char YKEYVALUES(250)(2,3)
  Local Char YCREDENTIALS(250)(2)
  Local Char PCOD(100)(1), PVAL(100)(1)
  Local Char YRESPONSE_ARR(250)(func YJSONDESERIALIZE.F_MAXELEMENT(), func YJSONDESERIALIZE.F_DEEPLEVEL() + 1)
  Local Clbfile YRESPONSE_JSON(1), YBODY(1)
  Local Integer EXIST_USER : EXIST_USER = 0

  Call OUVRE_TRACE ("YAX3MUSR - Creazione/Aggiornamento Utente ArgoX3 Mobile" - num$(date$)) From LECFIC

  Trbegin [F:YAX3MU]
  Readlock [F:YAX3MU]YAX3MU0 = YUSERNAME
  EXIST_USER = func YUTILS.IIF(fstat = 0, 1, 0)

  # Insert record into table
  [F:YAX3MU]USERNAME     = YUSERNAME
  [F:YAX3MU]X3USERNAME   = YX3USERNAME
  [F:YAX3MU]NOMUSR       = YNOMUSR
  [F:YAX3MU]EMAIL        = YEMAIL
  [F:YAX3MU]ENAFLG       = YENAFLG
  [F:YAX3MU]ISDEMO       = YISDEMO
  [F:YAX3MU]PASSWORDHASH = YHASH
  [F:YAX3MU]PASSWORDSALT = YSALT

  Local Integer YOPERATION : YOPERATION = 1
  #non esiste l'utente
  If EXIST_USER <> 1
    Write [F:YAX3MU]
  Else
    Rewrite [F:YAX3MU]
  Endif

  Gosub GET_WS_CONSTANTS From YUTILS
  If fstat
    YRESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", INTERNAL_SERVER_ERROR, 0)
    YRESPONSE += func YJSONSERIALIZE.GET_STR("message", "Errore interno!", 1)
  Else
    If fstat = 0
      Commit
      If fstat = 0
        YRESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", SUCCESS, 0)
        YRESPONSE += func YJSONSERIALIZE.GET_STR("message", "Utente" - func YUTILS.STR_IIF(EXIST_USER = 2, "inserito", "aggiornato") - "con successo!" , 1)
      Else
        Rollback
        YRESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", INTERNAL_SERVER_ERROR, 0)
        YRESPONSE += func YJSONSERIALIZE.GET_STR("message", "Errore interno!", 1)
      Endif
    Else
      Rollback
      YRESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", INTERNAL_SERVER_ERROR, 0)
      YRESPONSE += func YJSONSERIALIZE.GET_STR("message", "Errore interno!", 1)
    Endif
  Endif

  Raz [F:YAX3MU]
  YRESPONSE = func YJSONSERIALIZE.GET_JSON(YRESPONSE)

End

#########################################################################################
Subprog YCHECK_USER(YUSERNAME, YRESPONSE)

  Value Char YUSERNAME
  Variable Clbfile YRESPONSE

  Gosub GET_CONSTANTS From YUTILS
  Gosub GET_WS_CONSTANTS From YUTILS

  Local File YAX3MUSER [YAX3MU]

  Columns [F:YAX3MU](PASSWORDHASH,PASSWORDSALT)
  Read [F:YAX3MU]YAX3MU0=YUSERNAME

  Clbfile RESPONSE(0)
  If fstat = 0
    RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", SUCCESS, 0)
    RESPONSE += func YJSONSERIALIZE.GET_STR("message", "Utente trovato!", 0)
    Local Char USER_DATA(250)(3)
    USER_DATA(0) = func YJSONSERIALIZE.GET_STR("username", YUSERNAME, 1)
    USER_DATA(1) = func YJSONSERIALIZE.GET_STR("passwordHash", [F:YAX3MU]PASSWORDHASH, 1)
    USER_DATA(2) = func YJSONSERIALIZE.GET_STR("passwordSalt", [F:YAX3MU]PASSWORDSALT, 1)
    RESPONSE += func YJSONSERIALIZE.GET_STROBJ("data", USER_DATA, 0, 1)
  Else
    RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", NOT_FOUND, 0)
    RESPONSE += func YJSONSERIALIZE.GET_STR("message", "Utente inesistente!", 1)
  Endif

  YRESPONSE = func YJSONSERIALIZE.GET_JSON(RESPONSE)

End

################################################################################
Subprog YFIND_BYEMAIL(YEMAIL, YRESPONSE)
  Value Char YEMAIL
  Variable Clbfile YRESPONSE

  Local Char USERNAME(30), X3USERNAME(5), NOMUSR(30), EMAIL(80)
  Local Integer ENABLED, UCOUNT

  Local Char FIELDS(250)(5)

  Local File YAX3MUSER [YAX3MU]

  Gosub GET_WS_CONSTANTS From YUTILS

  Filter[YAX3MU] Where tolower([YAX3MU]EMAIL) = tolower(YEMAIL)

  Read [YAX3MU] First

  FIELDS(0) = func YJSONSERIALIZE.GET_STR("username", [YAX3MU]USERNAME, 1)
  FIELDS(1) = func YJSONSERIALIZE.GET_STR("x3username", [YAX3MU]X3USERNAME, 1)
  FIELDS(2) = func YJSONSERIALIZE.GET_STR("nomusr", [YAX3MU]NOMUSR, 1)
  FIELDS(3) = func YJSONSERIALIZE.GET_STR("email", [YAX3MU]EMAIL, 1)
  FIELDS(4) = func YJSONSERIALIZE.GET_BOOL("enabled", func YUTILS.IIF([YAX3MU]ENAFLG = 2, 1, 0), 1)

  # Creazione payload output
  Append YRESPONSE, func YJSONSERIALIZE.GET_OPENCURLYBRACKET()
  If fstat = 0
    Append YRESPONSE, func YJSONSERIALIZE.GET_INT("statusCode", SUCCESS, 0)
    Append YRESPONSE, func YJSONSERIALIZE.GET_STROBJ("data", FIELDS, 0, 1)
  Else
    Append YRESPONSE, func YJSONSERIALIZE.GET_INT("statusCode", NOT_FOUND, 0)
    Append YRESPONSE, func YJSONSERIALIZE.GET_STR("message", "Utente non trovato!", 1)
  Endif
  Append YRESPONSE, func YJSONSERIALIZE.GET_CLOSECURLYBRACKET()

End

################################################################################
# Subprog: YFIND_BYRESETTOKEN
# Scopo:
#   Ricerca un utente in anagrafica utenti tramite token hash
# Valore di ritorno:
#   YRESPONSE contenente JSON
################################################################################
Subprog YFIND_BYRESETTOKEN(YTOKENHASH, YRESPONSE)
  Value Char YTOKENHASH
  Variable Clbfile YRESPONSE

  Local Datetime EXPIRY
  Local Char USERNAME(100), EMAIL(100)
  Local Integer ENABLED
  Local Clbfile DATA_FIELDS(1)(0..)
  Local Integer DATA_COUNT
  Local Clbfile RESPONSE_FIELDS(1)(0..)
  Local Integer RESP_COUNT

  Local File YAX3MUSER [YAX3MUSR]
  Local File YAX3MPWRESTK [YAX3MPR]
  Gosub GET_WS_CONSTANTS From YUTILS

  # Inizializzo
  Raz RESPONSE_FIELDS : RESP_COUNT = 0

  # Lettura record
  Link [YAX3MPR] With  [YAX3MUSR]YAX3MU0~=[YAX3MPR]USERNAME As [YUSRLNK]
&                Where [YAX3MPR]TOKENHASH=YTOKENHASH

  Read [YUSRLNK] First


  If fstat <> 0
    # Token non trovato
    RESPONSE_FIELDS(RESP_COUNT) = func YJSONSERIALIZE.GET_INT("statusCode", NOT_FOUND, 1) : RESP_COUNT += 1
    RESPONSE_FIELDS(RESP_COUNT) = func YJSONSERIALIZE.GET_STR("message", "Token non trovato", 1) : RESP_COUNT += 1
  Else

    # Recupero campi
    EXPIRY = [YAX3MPR]EXPIRY
    USERNAME = [YAX3MPR]USERNAME
    EMAIL = [YAX3MUSR]EMAIL
    ENABLED = [YAX3MUSR]ENAFLG

    # Controllo scadenza
    If EXPIRY <= datetime$
      RESPONSE_FIELDS(RESP_COUNT) = func YJSONSERIALIZE.GET_INT("statusCode", UNAUTHORIZED, 1) : RESP_COUNT += 1
      RESPONSE_FIELDS(RESP_COUNT) = func YJSONSERIALIZE.GET_STR("message", "Token di reset scaduto", 1) : RESP_COUNT += 1
    Else
      # --- Costruzione oggetto Data (utente) ---
      Raz DATA_FIELDS : DATA_COUNT = 0
      DATA_FIELDS(DATA_COUNT) = func YJSONSERIALIZE.GET_STR("username", USERNAME, 2) : DATA_COUNT += 1
      DATA_FIELDS(DATA_COUNT) = func YJSONSERIALIZE.GET_STR("email", EMAIL, 1) : DATA_COUNT += 1
      DATA_FIELDS(DATA_COUNT) = func YJSONSERIALIZE.GET_BOOL("enabled", func YUTILS.IIF(ENABLED = 2, 1, 0), 1) : DATA_COUNT += 1

      # --- Risposta finale OK ---
      Raz RESPONSE_FIELDS : RESP_COUNT = 0
      RESPONSE_FIELDS(RESP_COUNT) = func YJSONSERIALIZE.GET_INT("statusCode", SUCCESS, 1) : RESP_COUNT += 1
      RESPONSE_FIELDS(RESP_COUNT) = func YJSONSERIALIZE.GET_CLBOBJ("data", DATA_FIELDS, 0, 1) : RESP_COUNT += 1
      RESPONSE_FIELDS(RESP_COUNT) = func YJSONSERIALIZE.GET_STR("message", "Token valido", 1) : RESP_COUNT += 1
    Endif

  Endif

  YRESPONSE = func YJSONSERIALIZE.GET_CLBOBJ(AVOID.ACHAR, RESPONSE_FIELDS, 1, 1)

End

################################################################################
# Aggiorna hash e expiry
Subprog YSAVE_RESETTOKEN(YUSERNAME, YTOKENHASH, YEXPIRY, YRESPONSE)
  Value Char YUSERNAME
  Value Char YTOKENHASH
  Value Char YEXPIRY
  Variable Clbfile YRESPONSE

  Local Integer YSTATUS
  Local Char YMESSAGE(250)

  Gosub GET_WS_CONSTANTS From YUTILS

  Local File YAX3MUSER [YAX3MUSR]
  Local File YAX3MPWRESTK [YAX3MPR]

  Read [YAX3MUSR]YAX3MU0 = YUSERNAME
  If fstat = 0

    Trbegin [YAX3MPR]
    Delete [YAX3MPR] Where USERNAME = YUSERNAME

    [YAX3MPR]USERNAME = YUSERNAME
    [YAX3MPR]TOKENHASH = YTOKENHASH
    [YAX3MPR]EXPIRY =  gdatetime$(YEXPIRY) # YEXPIRY deve essere cosi formattato: YYYY-MM-DDTHH:MM:SSZ

    Write [YAX3MPR]

    If !fstat
      Commit
      YSTATUS = SUCCESS
      YMESSAGE = 'Salvataggio token avvenuto con successo!'
    Else
      Rollback
      YSTATUS = INTERNAL_SERVER_ERROR
      YMESSAGE = 'Errore interno: impossibile salvare il token.'
    Endif

  Else
    YSTATUS = NOT_FOUND
    YMESSAGE = 'Utente inesistente: impossibile salvare il token.'
  Endif


  Append YRESPONSE, func YJSONSERIALIZE.GET_OPENCURLYBRACKET()
  Append YRESPONSE, func YJSONSERIALIZE.GET_INT("statusCode", YSTATUS, 0)
  Append YRESPONSE, func YJSONSERIALIZE.GET_STR("message", YMESSAGE, 1)
  Append YRESPONSE, func YJSONSERIALIZE.GET_CLOSECURLYBRACKET()

End

################################################################################

Subprog YUPDATE_PASSWORD(YUSERNAME, YNEWHASH, YNEWSALT, YRESPONSE)
  Value Char YUSERNAME
  Value Char YNEWHASH
  Value Char YNEWSALT

  Variable Clbfile YRESPONSE

  Local Integer YSTATUS
  Local Char YMESSAGE(250)

  Local File YAX3MUSER [YAX3MU]

  Gosub GET_WS_CONSTANTS From YUTILS

  Read [F:YAX3MU]YAX3MU0 = YUSERNAME

  If fstat = 0

    Trbegin [YAX3MU]

    [F:YAX3MU]PASSWORDHASH = YNEWHASH
    [F:YAX3MU]PASSWORDSALT = YNEWSALT

    Rewrite [YAX3MU]

    If !fstat
      Commit
      YSTATUS = SUCCESS
      YMESSAGE = 'Aggiornamento password avvenuto con successo!'
    Else
      Rollback
      YSTATUS = INTERNAL_SERVER_ERROR
      YMESSAGE = 'Errore interno: aggiornamento password fallito!'
    Endif

  Else
    YSTATUS = NOT_FOUND
    YMESSAGE = 'Utente inesistente: impossibile aggiornare la password!'
  Endif

  Append YRESPONSE, func YJSONSERIALIZE.GET_OPENCURLYBRACKET()
  Append YRESPONSE, func YJSONSERIALIZE.GET_INT("statusCode", YSTATUS, 0)
  Append YRESPONSE, func YJSONSERIALIZE.GET_STR("message", YMESSAGE, 1)
  Append YRESPONSE, func YJSONSERIALIZE.GET_CLOSECURLYBRACKET()

End

################################################################################

Subprog YCLEAR_RESETTOKEN(YUSERNAME, YRESPONSE)
  Value Char YUSERNAME
  Variable Clbfile YRESPONSE

  Local Integer YSTATUS
  Local Char YMESSAGE(250)

  Local File YAX3MPWRESTK [YAX3MPR]

  Gosub GET_WS_CONSTANTS From YUTILS

  Read [YAX3MPR]YAX3MPR1 = YUSERNAME

  If fstat = 0

    Trbegin [YAX3MPR]

    [YAX3MPR]TOKENHASH = AVOID.ACHAR
    [YAX3MPR]EXPIRY = AVOID.ADATE

    Rewrite [YAX3MPR]

    If !fstat
      Commit
      YSTATUS = SUCCESS
      YMESSAGE = 'Reset avvenuto con successo!'
    Else
      Rollback
      YSTATUS = INTERNAL_SERVER_ERROR
      YMESSAGE = 'Errore interno: impossibile resettare il token.'
    Endif
  Else
    YSTATUS = NOT_FOUND
    YMESSAGE = 'Utente inesistente: impossibile salvare il token.'
  Endif

  Append YRESPONSE, func YJSONSERIALIZE.GET_OPENCURLYBRACKET()
  Append YRESPONSE, func YJSONSERIALIZE.GET_INT("statusCode", YSTATUS, 0)
  Append YRESPONSE, func YJSONSERIALIZE.GET_STR("message", YMESSAGE, 1)
  Append YRESPONSE, func YJSONSERIALIZE.GET_CLOSECURLYBRACKET()

End

##########################################################################################
##########################################################################################
########################################### JWT ##########################################
##########################################################################################
##########################################################################################

Subprog YCHECK_REFRESH_TOKEN(YUSERNAME, YREFRESHTOKEN, YRESPONSE)
  Value Char YUSERNAME
  Value Char YREFRESHTOKEN
  Variable Clbfile YRESPONSE

  Gosub GET_CONSTANTS From YUTILS
  Gosub GET_WS_CONSTANTS From YUTILS

  Local Char REFRESHTOKEN_QUERY(250)
  #"select APIKEY_0, RTEXPIRACY_0, RT_VALID_0 from YAX3ATOKEN where APIKEY_0 = '" + YAPIKEY + "' and REFRESHTOKEN_0 = '" + YREFRESHTOKEN + "'"
  REFRESHTOKEN_QUERY = "select USERNAME_0, RTEXPIRACY_0, RT_VALID_0 from YAX3MUSERTOK where USERNAME_0 = '" + YUSERNAME + "' and REFRESHTOKEN_0 = '" + YREFRESHTOKEN + "'"

  Local Tinyint IS_INVALIDTOKEN
  Local File YAX3MUSERTOK [YAX3MUT]

  For (Char YCURR_USERNAME, Datetime YCURR_RTEXPIRACY, Tinyint YCURR_RTVALID) From num$(GTYPDBA*2+1) Sql REFRESHTOKEN_QUERY As [YAX3A]
    IS_INVALIDTOKEN = func YUTILS.IIF(YCURR_USERNAME = AVOID.ACHAR, 2, 1)
    IS_RTEXPIRED = func YUTILS.IIF((YCURR_RTEXPIRACY < datetime$) | (YCURR_RTVALID = FALSE), 2, 1)
  Next

  Clbfile RESPONSE(0)
  If IS_INVALIDTOKEN = TRUE | IS_RTEXPIRED = TRUE
    RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", UNAUTHORIZED, 0)
    RESPONSE += func YJSONSERIALIZE.GET_STR("message", "Refresh token non valido o scaduto!", 1)
  Else
    #AGGIORNA IL TOKEN DI AGGIORNAMENTO COME NON PIU' VALIDO
    Local Char INV_RT_QUERY(250)
    INV_RT_QUERY = "update YAX3MUSERTOK set RT_VALID_0 = " + num$(FALSE) + " where USERNAME_0 = '" + YUSERNAME + "' and REFRESHTOKEN_0 = '" + YREFRESHTOKEN + "'"

    Trbegin [YAX3MUT]

    Execsql From num$(GTYPDBA*2+1) Sql INV_RT_QUERY
    If !fstat Then
      Commit
    Else
      Rollback
    Endif

    RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", SUCCESS, 1)
  Endif
  YRESPONSE = func YJSONSERIALIZE.GET_JSON(RESPONSE)

End

#########################################################################################

Subprog YCHECK_ACCESS_TOKEN(YACCESSTOKEN, YRESPONSE)
  Value Clbfile YACCESSTOKEN
  Variable Clbfile YRESPONSE

  Gosub GET_CONSTANTS From YUTILS
  Gosub GET_WS_CONSTANTS From YUTILS

  Local Clbfile ACCESSTOKEN_QUERY_CLB(2)
  Case GTYPDBA
    When 1 : # Oracle
      ACCESSTOKEN_QUERY_CLB = "select USERNAME_0, ATEXPIRACY_0 from YAX3MUSERTOK where DBMS_LOB.INSTR(ACCESSTOKEN_0, '" + YACCESSTOKEN + "') > 0 and AT_VALID_0 = " + num$(TRUE)
    When 2 : # Sql
      ACCESSTOKEN_QUERY_CLB = "select USERNAME_0, ATEXPIRACY_0 from YAX3MUSERTOK where ACCESSTOKEN_0 = '" + YACCESSTOKEN + "' and AT_VALID_0 = " + num$(TRUE)
  Endcase

  Local Char ACCESSTOKEN_QUERY(250)(3)
  Call YCLB2STRARR(ACCESSTOKEN_QUERY_CLB, ACCESSTOKEN_QUERY) From YUTILS

  Local Tinyint IS_INVALIDTOKEN, IS_EXPIREDTOKEN

  For (Char YCURR_USERNAME, Datetime YCURR_ATEXPIRACY) From num$(GTYPDBA*2+1) Sql ACCESSTOKEN_QUERY As [YAX3A]
    # con questo controllo che non ci sia più o non sia più valido l'access token
    IS_INVALIDTOKEN = func YUTILS.IIF(YCURR_USERNAME = AVOID.ACHAR, 2, 1)
    IS_EXPIREDTOKEN = func YUTILS.IIF((YCURR_ATEXPIRACY < datetime$), 2, 1)
  Next

  Clbfile RESPONSE(0)
  If IS_INVALIDTOKEN = TRUE
    RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", UNAUTHORIZED, 0)
    RESPONSE += func YJSONSERIALIZE.GET_STR("message", "Token di accesso non valido o revocato!", 1)
  Elsif IS_EXPIREDTOKEN = TRUE
    RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", UNAUTHORIZED, 0)
    RESPONSE += func YJSONSERIALIZE.GET_STR("message", "Token di accesso scaduto!", 1)
  Else
    RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", SUCCESS, 1)
  Endif

  YRESPONSE = func YJSONSERIALIZE.GET_JSON(RESPONSE)

End

#########################################################################################

Subprog YINS_TOKEN(YUSERNAME, YACCESSTOKEN, YACCESSTOKEN_EXPIRACY, YAT_VALID, YREFRESHTOKEN, YREFRESHTOKEN_EXPIRACY, YRT_VALID, YRESPONSE)
  Value Char YUSERNAME
  Value Clbfile YACCESSTOKEN
  Value Char YACCESSTOKEN_EXPIRACY
  Value Integer YAT_VALID
  Value Clbfile YREFRESHTOKEN
  Value Char YREFRESHTOKEN_EXPIRACY
  Value Integer YRT_VALID
  Variable Clbfile YRESPONSE

  Local File YAX3MUSERTOK [YAX3MUT]

  Trbegin [YAX3MUT]

  [F:YAX3MUT]USERNAME = YUSERNAME
  [F:YAX3MUT]ACCESSTOKEN = YACCESSTOKEN
  [F:YAX3MUT]ATEXPIRACY = gdatetime$(YACCESSTOKEN_EXPIRACY)
  [F:YAX3MUT]AT_VALID = YAT_VALID
  [F:YAX3MUT]REFRESHTOKEN = YREFRESHTOKEN
  [F:YAX3MUT]RTEXPIRACY = gdatetime$(YREFRESHTOKEN_EXPIRACY)
  [F:YAX3MUT]RT_VALID = YRT_VALID
  [F:YAX3MUT]CREUSR = "AX3A"
  [F:YAX3MUT]UPDUSR = "AX3A"

  Write [YAX3MUT]

  If !fstat
    Commit
  Else
    Rollback
  Endif

  Gosub JSON_RESPONSE_BUILDER From YUTILS

End

#########################################################################################

Subprog YINV_TOKEN(YACCESSTOKEN, YRESPONSE)
  Value Clbfile YACCESSTOKEN
  Variable Clbfile YRESPONSE

  Gosub GET_CONSTANTS From YUTILS
  Gosub GET_WS_CONSTANTS From YUTILS

  Local Clbfile ACCESSTOKEN_QUERY_CLB(0), TOKEN_QUERY_CLB(0)
  Local Char ACCESSTOKEN_QUERY(250)(3), TOKEN_QUERY(250)(3)

  Case GTYPDBA
    When 1 : # Oracle
      TOKEN_QUERY_CLB = "update YAX3MUSERTOK set AT_VALID_0 = 1, RT_VALID_0 = 1, UPDDATTIM_0 = SYS_EXTRACT_UTC(SYSTIMESTAMP) where DBMS_LOB.INSTR(ACCESSTOKEN_0, '" + YACCESSTOKEN + "') > 0"
      Setlob ACCESSTOKEN_QUERY_CLB With "select count(*) from YAX3MUSERTOK where DBMS_LOB.INSTR(ACCESSTOKEN_0, '" + YACCESSTOKEN + "') > 0 and AT_VALID_0 = " + num$(TRUE)
    When 2 : # Sql
      TOKEN_QUERY_CLB = "update YAX3MUSERTOK set AT_VALID_0 = 1, RT_VALID_0 = 1, UPDDATTIM_0 = GETUTCDATE() where ACCESSTOKEN_0 = '" + YACCESSTOKEN + "'"
      Setlob ACCESSTOKEN_QUERY_CLB With "select count(*) from YAX3MUSERTOK where ACCESSTOKEN_0 = '" + YACCESSTOKEN + "' and AT_VALID_0 = " + num$(TRUE)
  Endcase

  Call YCLB2STRARR(ACCESSTOKEN_QUERY_CLB, ACCESSTOKEN_QUERY) From YUTILS

  Local Tinyint IS_INVALIDTOKEN
  Local File YAX3MUSERTOK [YAX3MUT]

  For (Integer YCOUNT_USERTOK) From num$(GTYPDBA*2+1) Sql ACCESSTOKEN_QUERY As [YAX3A]
    If YCOUNT_USERTOK > 0

      Call YCLB2STRARR(TOKEN_QUERY_CLB, TOKEN_QUERY) From YUTILS

      Trbegin [YAX3MUT]
      Execsql From num$(GTYPDBA*2+1) Sql TOKEN_QUERY

      If !fstat Then
        Commit
      Else
        Rollback
      Endif
    Else
      fstat = 0 #lo setto uguale a 0 perchè se il token non esiste è già stato invalidato e restituisco success
    Endif
  Next

  Gosub JSON_RESPONSE_BUILDER From YUTILS

End
**********
7,"TRT","YAX3MAUTHLIB",""
2,"TRT","YAX3MENULIB",""
#<AdxTL>@(#)0.0.0.0 $Revision$
################################################################################
# Subprog: YGET_MENU_FOR_USER
# Input:
#   - YUSERNAME (app username)  (Value Char)
# Output:
#   - YRESPONSE (clobfile) JSON compatibile con il formato di GetMenuItems()
#
# Logica:
#   1) trova mappatura locale YAX3MUSER -> X3USERNAME (campo X3USERNAME / CODUSR)
#   2) legge AUTILIS per CODUSR -> PRFFCT
#   3) legge AFCTFCT per PRFCOD: se ALLFCT = 1 => tutte le funzioni abilitate
#      altrimenti legge AFCTPRF per PRFCOD e costruisce lista FUNCTIONS[] con FNC
#   4) confronta lista FUNCTIONS con la mappatura menu->FNC definita in questo subprog
#   5) costruisce il JSON nel formato:
#     {
#       "YSMR": { "Controller": "...", "Title":"...", "SubItemsTitle": [ ... ] },
#       "YSMO": { ... }
#     }
################################################################################

Subprog YGETMENU(YUSERNAME, YRESPONSE)
  Value Char YUSERNAME
  Variable Clbfile YRESPONSE

  Gosub GET_CONSTANTS From YUTILS
  Gosub GET_WS_CONSTANTS From YUTILS

  # local vars
  Local Char X3USERNAME(5)
  Local Char AX3M_ATABDIV(4) : AX3M_ATABDIV = func AFNC.PARAM("YTDMENAX3M", "")
  Local Char FUNCTION_ARRAY(250)(2)
  Local Char FUNCTION_ID(50)
  Local Char YPRFCOD(5)
  Local Integer FIRST_ITEM : FIRST_ITEM = 1

  Local Clbfile FUNCTION_JSON_ARRAY(1)
  Local Clbfile MENU_ITEMS(1)

  Local File AUTILIS [AUS], YAX3MUSER [YAX3MU], ATABDIV [ADI], ATEXTRA [AXX], AFCTFCT [AFT], AFCTPRF [AFP]

  YRESPONSE = func YJSONSERIALIZE.GET_OPENCURLYBRACKET()

  If YUSERNAME = AVOID.ACHAR
    Gosub GET_FULLRESPONSE #RIMUOVERE QUANDO ANTONIO HA IMPLEMENTATO LA PARTE DI FRONTEND
  Else
    Columns [YAX3MU] (X3USERNAME)
    #Inizio elaborazione
    Read [YAX3MU]YAX3MU0 = YUSERNAME

    If fstat = 0

      Columns [AUS] (PRFFCT)
      Read [AUS]CODUSR = [F:YAX3MU]X3USERNAME

      If fstat = 0

        YPRFCOD = [AUS]PRFFCT
        If vireblc(YPRFCOD, 2) <> AVOID.ACHAR

          Columns [AFT] (ALLFCT)
          Read [AFT]AFT0=YPRFCOD

          If fstat = 0
            If [AFT]ALLFCT = 2
              Gosub GET_FULLRESPONSE
            Else
              Gosub GET_FILTEREDRESPONSE
            Endif
          Endif

        Endif
  #
      Else
#       #Utente non trovato su x3 (SBLOCCO TUTTE LE FUNZIONI FINCHE' NON C'è UN PROFILO)
#       Append YRESPONSE, func YJSONSERIALIZE.GET_INT("statusCode", 404, 0)
#       Append YRESPONSE, func YJSONSERIALIZE.GET_STR("message", "Utente non presente in anagrafica X3!", 1)
        Gosub GET_FULLRESPONSE
      Endif
    Else
        # Utente non trovato su ax3m
        Append YRESPONSE, func YJSONSERIALIZE.GET_INT("statusCode", 404, 0)
        Append YRESPONSE, func YJSONSERIALIZE.GET_STR("message", "Utente non presente in anagrafica ArgoX3 Mobile!", 1)
    Endif
  Endif

  Append YRESPONSE, func YJSONSERIALIZE.GET_CLOSECURLYBRACKET()

  # --- scrittura su file come facevi prima ---
#Local Char YFILENAME_RESP(100) : YFILENAME_RESP = "menu_payload_" + format$("YYYYMMDDhhmmss", datetime$)
#Local Char YFILEPATH_RESP(250) : YFILEPATH_RESP = filpath("tmp", YFILENAME_RESP, "json")
#Openo YFILEPATH_RESP Using [YRESP]
#Iomode adxifs ";" Using [YRESP]
#Iomode adxium GUTF8 Using [YRESP]
#Iomode adxirs chr$(13)+chr$(10) Using [YRESP]
#Wrseq YRESPONSE Using [YRESP]
#Openo Using [YRESP]

Call FERME_TRACE From LECFIC

End

################################################################################

$GET_FILTEREDRESPONSE

  Columns [ADI] (CODE, A1, ENAFLG)
  Link [AFP] With  [AFT]AFT0 ~= [AFP]PRFCOD,
&                  [ADI]CODE ~= AX3M_ATABDIV;[AFP]FNC
&            As    [FCTLNK]
&            Where ([AFP]PRFCOD = YPRFCOD & [ADI]ENAFLG = 2)
&            Order By [ADI]N1

  For [FCTLNK]
    Gosub BUILD_MENUITEM
  Next

  Append YRESPONSE, func YJSONSERIALIZE.GET_INT("statusCode", 200, 0)
  Append YRESPONSE, MENU_ITEMS

Return

################################################################################

$GET_FULLRESPONSE

  # Tabella diversa per reperire i controller da interrogare su ArgoX3 API
  # Se la lettura fallisce non ho gestito i controller per l'api associata alle funzioni su mobile
  #Readlock [AXX]AXX0='ATABDIV';'LNGDES';GLANGUE;AX3M_ATABDIV_CONTROLLERS;[AFC]CODINT

  #prendo le funzioni associate al N°TabellaController, Attive(ENAFLG = 2)
  # e ordinate secondo N1 (ordinamento da avere nel MenuController)

  Columns [ADI] (CODE, A1, ENAFLG)
  Filter [ADI] Where ([ADI]NUMTAB = val(AX3M_ATABDIV) & [ADI]ENAFLG = 2) Order By N1
  For [ADI]
    Gosub BUILD_MENUITEM
  Next

  Filter [ADI]

  # Costruiamo la risposta finale
  Append YRESPONSE, func YJSONSERIALIZE.GET_INT("statusCode", 200, 0)
  Append YRESPONSE, MENU_ITEMS

Return

################################################################################

$BUILD_MENUITEM

  If FIRST_ITEM = 0
    Append MENU_ITEMS, func YJSONSERIALIZE.GET_SEPARATOR()
  Else
    FIRST_ITEM = 0
  Endif

  # Creiamo l'array per questa funzione [descrizione, identificativo]
  FUNCTION_ID = [ADI]CODE  # Questo dovrebbe essere YSMR, YSMO, ecc.
  Read [F:AXX]AXX0 = "ATABDIV";"LNGDES";"ITA";AX3M_ATABDIV;FUNCTION_ID
  If fstat = 0
    FUNCTION_ARRAY(0) = [F:AXX]TEXTE    #descrizione
    FUNCTION_ARRAY(1) = [ADI]A1         #controller
    FUNCTION_JSON_ARRAY = func YJSONSERIALIZE.GET_STRLST(FUNCTION_ID, FUNCTION_ARRAY, 1)
    Append MENU_ITEMS, FUNCTION_JSON_ARRAY
  Endif

Return
**********
7,"TRT","YAX3MENULIB",""
2,"TRT","YAX3MLOG",""
#<AdxTL>@(#)0.0.0.0 $Revision$
##################################################################################################################
#                                                 LIBRERIA PER GESTIONE LOG AX3M
##################################################################################################################
#**
#* Init del Log:
#* 1-Creazione (eventuale) ambiente per il Log;
#* 2-Composizione Intestazione;
#* 3-Stampa Log ;
#* 4-Stampe : payload: yax3mresp.json, matrice: init-fields.txt
#*!

$YAX3MOB_INIT

  #1-LOG ENVIRONMENT
  Gosub YAX3MOB_SET_ENV

  #2-COMPOSIZIONE INTESTAZIONE
  Gosub YAX3MOB_SET_HEADER

  #3-STAMPA
  Call YWRITE(YLOGTEXT)
  Raz YLOGTEXT

  #4-LOG- STAMPE in INIT -lato Mobile
  If([V]GWEBSERV)
    #Stampa: yax3mresp.json
    Call YPRINT_DIR_CLB(YPAYLOADDIRNAME, YAX3MRESP, "YAX3MRESP_" + YACTION, "json") From YUTILS

    #Stampa: init-fields.txt
    If(CURRENTROW = -1)
      #se azione su Testata/Bottone di Finestra
      Call YAX3MOB_PRINT_DIR_YFIELDS(YPAYLOADDIRNAME, "init", YFIELDS, YACTION, YCURRENTUSER) From YAX3MUTILS
    Else
      #se azione su Riquadro
      Call YAX3MOB_PRINT_DIR_YFIELDS(YPAYLOADDIRNAME, "init", YFIELDS, YACTION-"-row"+num$(CURRENTROW),YCURRENTUSER) From YAX3MUTILS
    Endif
  Endif
Return

#########################################################################################################
#**
#* Sub per Creazione (eventuale) Ambiente per il Log
#*!

$YAX3MOB_SET_ENV

  Local Clbfile YLOGTEXT(2)                                                     #Clob per LOG
  Local Char YAX3MDIRNAME(20): YAX3MDIRNAME = "AX3M"                            #Nome Cartella AMBIENTE
  Local Char YLOGDIRNAME(20): YLOGDIRNAME = YAX3MDIRNAME + "\LOG"
  Local Char YPAYLOADDIRNAME(20): YPAYLOADDIRNAME = YAX3MDIRNAME + "\PAYLOAD"
  Local Char YLOGFIL(25): YLOGFIL = format$("D:YYYYMMDD",date$)                 #Nome File Log
  Local Integer STAT

  Local Integer YI,YJ
  Local Char YFILA(250)
  Local Char YBASEPATH(250):YBASEPATH = filpath("","","")

  Local Char YIDENT(30): YIDENT = num$(adxuid(1))    #identificativo

  #Creazione cartella ambiente per Log: AX3M e sotto cartelle (LOG, PAYLOAD), se non esistono
  If filinfo(filpath("","","")+"\"+YAX3MDIRNAME, 7) <= 0 # non esiste
    Call SYSTEME(adxmac(0), 'ae_mkdir - "' + filpath("","","")+"\"+YAX3MDIRNAME + '"', "", STAT) From ORDSYS
  Endif

  If filinfo(filpath("","","")+"\"+YLOGDIRNAME, 7) <= 0 # non esiste
    Call SYSTEME(adxmac(0), 'ae_mkdir - "' + filpath("","","")+"\"+YLOGDIRNAME + '"', "", STAT) From ORDSYS
  Endif

  If filinfo(filpath("","","")+"\"+YPAYLOADDIRNAME, 7) <= 0 # non esiste
    Call SYSTEME(adxmac(0), 'ae_mkdir - "' + filpath("","","")+"\"+YPAYLOADDIRNAME + '"', "", STAT) From ORDSYS
  Endif

  #Setto le variabili per parametri azione
  Local Char YPARAM(50),YPARVAL(60)
  If clalev([F:YATR])=0 : Local File ACTPAR [F:YATR] : Endif
  Local Char YEXCLUDE_PARAMS(20)(3)   #array con codici dei parametri da escludere
  YEXCLUDE_PARAMS(0)="YAX3MRESP"
  YEXCLUDE_PARAMS(1)="YRESPONSE"
  YEXCLUDE_PARAMS(2)="RESPONSE"

  #YFILA=filpath(YLOGDIRNAME, YLOGFIL, YLOG_EXT)  #gestione file
Return

##############################################################################################################
#**
#* Sub per Intestazione Log per Az.Campo e Az.Bottone Finestra. Struttura : Timestamp-Identificativo-Testo ;
#* Operazioni : 1-Cod.Azione(WS), 2-Set dei parametri, 3- Cod.Utente
#*!

$YAX3MOB_SET_HEADER

  Append YLOGTEXT, chr$(10)  # una riga vuota tra un'azione e l'altra

  #Aggiunta riga in Log: <Timestamp> - <Identificativo> - "ACTION:"<CodiceAzione>
  Append YLOGTEXT, func YUTILS.YGET_TIMESTAMP()-"-"-YIDENT-"-"-"ACTION:"- func YAX3MUTILS.YGET_SUBPRGNAME(YACTION)+chr$(10)

  #Aggiunta riga in Log: <Timestamp> - <Identificativo> - "PARAMS:"
  Append YLOGTEXT, func YUTILS.YGET_TIMESTAMP()-"-"-YIDENT-"-"-"PARAMS:"

  #Filtro i parametri dell'azione
  Local Integer YNUMPAR,YPOS,YDIME
  Columns [F:YATR] (CODPAR)
  Filter [F:YATR] Where ([F:YATR]ACTION = YACTION & !find([F:YATR]CODPAR,YEXCLUDE_PARAMS))
  YNUMPAR = rowcount([F:YATR])

  For [F:YATR]
    YPARAM = evalue("[F:YATR]CODPAR")    #codice parametro
    YDIME = func YAX3MUTILS.YGET_DIMEPARAM(func YAX3MUTILS.YGET_SUBPRGNAME(YACTION),YPARAM)
    YPOS = func YUTILS.IIF(CURRENTROW = -1, 0, CURRENTROW)

    If(YDIME=1)
      YPARVAL = func YUTILS.STR_IIF(vireblc(num$(evalue(YPARAM)),2)= AVOID.ACHAR, "empty",num$(evalue(YPARAM))) #val param
    Else
      If(YPARAM = YCURRFIELD)
        If(!GWEBSERV)
          YPARVAL = func YUTILS.STR_IIF(vireblc(num$(evalue(YPARAM)),2)= AVOID.ACHAR, "empty",num$(evalue(YPARAM+"("+num$(0)+")")))
        Else
          YPARVAL = func YUTILS.STR_IIF(vireblc(num$(evalue(YPARAM)),2)= AVOID.ACHAR, "empty",num$(evalue(YPARAM+"("+num$(YPOS)+")")))
        Endif
      Else
        YPARVAL = func YUTILS.STR_IIF(vireblc(num$(evalue(YPARAM)),2)= AVOID.ACHAR, "empty",num$(evalue(YPARAM+"("+num$(YPOS)+")")))
      Endif
    Endif

    Append YLOGTEXT,func YUTILS.STR_IIF(YI>0, chr$(32), AVOID.ACHAR)-YPARAM+":"-YPARVAL-func YUTILS.STR_IIF(YI<YNUMPAR,"-",AVOID.ACHAR)
    YI +=1
  Next
  Filter [F:YATR]

  #A capo
  Append YLOGTEXT, chr$(10)

  #Aggiunta riga in Log: <Timestamp> - <Identificativo> - "USER:"<CodiceUtente>
  Append YLOGTEXT, func YUTILS.YGET_TIMESTAMP()-"-"-YIDENT-"-"-"USER:"-YCURRENTUSER

Return

##################################################################################################
#**
#* Sub per Gestione Log a fine Azione-Campo: (Mobile): stampa YFields_end.txt, stampa YResponse_end.json
#*!

$YAX3MOB_END

  If(GWEBSERV)

    #LOGGING(STAMPE): print end matrix: YFIELDS_end + print YRESPONSE
    If(CURRENTROW = -1)
      #Se azione su Testata/Bottone di Finestra
      Call YAX3MOB_PRINT_DIR_YFIELDS(YPAYLOADDIRNAME, "end", YFIELDS, YACTION, YCURRENTUSER) From YAX3MUTILS
      Call YPRINT_DIR_CLB(YPAYLOADDIRNAME, YRESPONSE, "YRESPONSE_" + YACTION +"_("+YCURRENTUSER+")", "json") From YUTILS
    Else
      #Se azione su Riquadro
      Call YAX3MOB_PRINT_DIR_YFIELDS(YPAYLOADDIRNAME, "end", YFIELDS, YACTION-"-row"+num$(CURRENTROW),YCURRENTUSER) From YAX3MUTILS
      Call YPRINT_DIR_CLB(YPAYLOADDIRNAME, YRESPONSE, "YRESPONSE_" + YACTION-"-row"+num$(CURRENTROW)+"_("+YCURRENTUSER+")", "json") From YUTILS
    Endif
  Endif

  Raz YLOGTEXT
Return

############################################################################################
#**
#* Metodo per Loggare un testo
#*
#* @param YMKSTAT Intero(booleano) per stato
#* @param YMESSAGE Messaggio da loggare
#*!

Subprog YAX3MOB_ECRTRACE(YMKSTAT,YMESSAGE)

  Value Integer YMKSTAT
  Value Char YMESSAGE

  Local Char YTYPELOG(10)
  Local Char YIDENT(30): YIDENT = num$(adxuid(1))
  Local Clbfile YMESS

  Case YMKSTAT
    When 0 : YTYPELOG = "INFO"
    When 1 : YTYPELOG = "WARN"
    When 2 : YTYPELOG = "ERROR"
    When 4 : YTYPELOG = "FATAL"
    When Default
  Endcase

  YMESS = func YUTILS.YGET_TIMESTAMP() - "-" - YIDENT - "-" - YTYPELOG + ":" - YMESSAGE
  Call YWRITE(YMESS)
End

#########################################################################################
#**
#* Scrittura effettiva del Messaggio nel file di Log [Metodo PRIVATE]
#*
#* @param YMESSAGE Messaggio da tracciare
#*!

Subprog YWRITE(YMESSAGE)

  Value Clbfile YMESSAGE
  Local Char YFILA(250) : YFILA = filpath("AX3M\LOG", format$("D:YYYYMMDD",date$),"log")

  Openo YFILA Using [YF1]
  Iomode adxifs ";" Using [YF1]
  Iomode adxium GUTF8 Using [YF1]
  Iomode adxirs chr$(13)+chr$(10) Using [YF1]
  Wrseq YMESSAGE Using [YF1]
  Openo Using [YF1]
End
**********
7,"TRT","YAX3MLOG",""
2,"TRT","YAX3MPROTOCOLLIB",""
#<AdxTL>@(#)0.0.0.0 $Revision$
Subprog YPROTOCOL(FUNCTION, YRESPONSE)
  Value Char FUNCTION
  Variable Clbfile YRESPONSE

  Local File YVPROTOCOL [F:YVPR]
  Local Char YCRITERE(250)

  # campi top-level result
  #Local Clbfile YFUNCTION_FIELDS(1)(6)   # activityCode,code,description,objectAccess,action,window

  # campi action
  Local Clbfile YACTION_FIELDS(1)(13)  # activityCode,code,stdTrt,speTrt,subProg,nextAction,consultationCode,mainWindow,initialInsertion,windowCriteria,programPerAction,preAfterAction

  # campi window
  Local Clbfile YWINDOW_FIELDS(1)(0..)   # activityCode,code,description,type,typeWindow,headScreen,active,screens,buttons

  # array screens
  Local Clbfile YSCREENS(1)(rowcount([F:YVPR]))
  Local Clbfile YSCREEN(1)(11)    # activityCode,code,number,description,position,speTrt,spvTrt,stdTrt

  # array refTables (max 5)
  Local Char REFNAMES(12)(5)
  Local Clbfile YREF_TABLES(1)(0..)

  # array blocks (max 15)
  Local Char YBLOCK_FIELDS(250)(5)     # blockNumber,blockTitle,blockType,blockTypeValue,blockParamField,blockVisible
  Local Clbfile YBLOCKS(1)(15)

  #window number, title and description
  Local Char YSE_FIELDS(250)(3)        # ogni riga ha 3 colonne: nome, descrizione, numero
  Local Char YSE_ITEM(250)              # oggetto JSON per ciascun elemento
  Local Clbfile YSE_ITEMS(1)(15)      # fino a 15 elementi
  Local Integer SE : SE = 0           # contatore elementi

  Local Integer I, J, B

  Call OUVRE_TRACE("YPROTOCOL") From LECFIC

  # filtro per FUNCTION
  YCRITERE = "CODINT = '" + FUNCTION + "'"
  Filter [F:YVPR] Where CODINT = FUNCTION
&                 Order By Key CLE = CODINT;CODMSK

  For [F:YVPR]CLE(1)
    # inizio JSON
    YRESPONSE = func YJSONSERIALIZE.GET_OPENCURLYBRACKET()
    # Function
    Append YRESPONSE, func YJSONSERIALIZE.GET_STR("activityCode", [F:YVPR]ACODACT, 0)
    Append YRESPONSE, func YJSONSERIALIZE.GET_STR("code", [F:YVPR]CODINT, 0)
    Append YRESPONSE, func YJSONSERIALIZE.GET_STR("description", [F:YVPR]FTEXTE, 0)
    Append YRESPONSE, func YJSONSERIALIZE.GET_BOOL("objectAccess", [F:YVPR]TYP, 0)

    # Action
    YACTION_FIELDS(0)  = func YJSONSERIALIZE.GET_STR("activityCode", [F:YVPR]ACODACT, 1)
    YACTION_FIELDS(1)  = func YJSONSERIALIZE.GET_STR("code", [F:YVPR]ACTION, 1)
    YACTION_FIELDS(2)  = func YJSONSERIALIZE.GET_STR("stdTrt", [F:YVPR]CODTRT, 1)
    YACTION_FIELDS(3)  = func YJSONSERIALIZE.GET_STR("speTrt", [F:YVPR]SPETRT, 1)
    YACTION_FIELDS(4)  = func YJSONSERIALIZE.GET_STR("subProg", [F:YVPR]SUBPRG, 1)
    YACTION_FIELDS(5)  = func YJSONSERIALIZE.GET_STR("nextAction", [F:YVPR]ACTSUI, 1)
    YACTION_FIELDS(6)  = func YJSONSERIALIZE.GET_STR("consultationCode", [F:YVPR]PARAM1, 1)
    YACTION_FIELDS(7)  = func YJSONSERIALIZE.GET_STR("mainWindow", [F:YVPR]PARAM2, 1)
    YACTION_FIELDS(8)  = func YJSONSERIALIZE.GET_STR("initialInsertion", num$([F:YVPR]PARAM3), 1)
    YACTION_FIELDS(9)  = func YJSONSERIALIZE.GET_STR("windowCriteria", [F:YVPR]PARAM4, 1)
    YACTION_FIELDS(10) = func YJSONSERIALIZE.GET_STR("programPerAction", [F:YVPR]PARAM5, 1)
    YACTION_FIELDS(11) = func YJSONSERIALIZE.GET_STR("preAfterAction", num$([F:YVPR]PARAM6), 1)

    Local Shortint WINDOWFIELDS_INDEX : WINDOWFIELDS_INDEX = 0
    # Window
    YWINDOW_FIELDS(WINDOWFIELDS_INDEX) = func YJSONSERIALIZE.GET_STR("activityCode", [F:YVPR]WCODACT, 1)
    WINDOWFIELDS_INDEX+=1
    YWINDOW_FIELDS(WINDOWFIELDS_INDEX) = func YJSONSERIALIZE.GET_STR("code", [F:YVPR]WIN, 1)
    WINDOWFIELDS_INDEX+=1
    YWINDOW_FIELDS(WINDOWFIELDS_INDEX) = func YJSONSERIALIZE.GET_STR("description", [F:YVPR]WTEXTE, 1)
    WINDOWFIELDS_INDEX+=1
    YWINDOW_FIELDS(WINDOWFIELDS_INDEX) = func YJSONSERIALIZE.GET_STR("type", num$([F:YVPR]TYP), 1)
    WINDOWFIELDS_INDEX+=1
    YWINDOW_FIELDS(WINDOWFIELDS_INDEX) = func YJSONSERIALIZE.GET_STR("typeWindow", num$([F:YVPR]WINTYP), 1)
    WINDOWFIELDS_INDEX+=1
    YWINDOW_FIELDS(WINDOWFIELDS_INDEX) = func YJSONSERIALIZE.GET_STR("headScreen", [F:YVPR]MSKENT, 1)
    WINDOWFIELDS_INDEX+=1
    YWINDOW_FIELDS(WINDOWFIELDS_INDEX) = func YJSONSERIALIZE.GET_BOOL("active", func YUTILS.IIF([F:YVPR]ENAFLG = 2, 1, 0) , 1)

    # Screens array
    J = 0
    For [F:YVPR]CLE(2)
      # screen
      YSCREEN(0)= func YJSONSERIALIZE.GET_STR("activityCode", [F:YVPR]SCODACT, 1)
      YSCREEN(1)= func YJSONSERIALIZE.GET_STR("code", [F:YVPR]CODMSK, 1)
      YSCREEN(2)= func YJSONSERIALIZE.GET_INT("number", [F:YVPR]ROWMSK(J), 1)
      YSCREEN(3)= func YJSONSERIALIZE.GET_STR("description", [F:YVPR]STTEXTE, 1)
      YSCREEN(4)= func YJSONSERIALIZE.GET_DECIMAL("position", [F:YVPR]POSBLOC, 1)
      YSCREEN(5)= func YJSONSERIALIZE.GET_STR("speTrt", [F:YVPR]TRTSPE, 1)
      YSCREEN(6)= func YJSONSERIALIZE.GET_STR("spvTrt", [F:YVPR]TRTSPV, 1)
      YSCREEN(7)= func YJSONSERIALIZE.GET_STR("stdTrt", [F:YVPR]TRTSTD, 1)

      YREF_TABLES(J)= func YJSONSERIALIZE.GET_STRLST("refTables", [F:YVPR]FICREF, 1)
      Append YSCREEN(8), YREF_TABLES(J)

      # blocks
      B = 0
      For I = 0 To 14
        If [F:YVPR]RANG(I) > 0 & [F:YVPR]YVISBLOC(I) = 2
          #DIVIDO PER 5, PERCHè IN DOT NET LA FUNZIONE SORTSCREENS FA UN COMPARE CON IL NUMERO DI BLOCCO DEL CAMPO CHE PARTE DA 1 E NON E' IN M ULTIPLI DI 5
          YBLOCK_FIELDS(0)= func YJSONSERIALIZE.GET_INT("blockNumber", [F:YVPR]RANG(I) / 5, 1)
          YBLOCK_FIELDS(1)= func YJSONSERIALIZE.GET_STR("blockTitle", [F:YVPR]SBTEXTE(I), 1)
          YBLOCK_FIELDS(2)= func YJSONSERIALIZE.GET_INT("blockType", [F:YVPR]TYPBLOC(I), 1)
          YBLOCK_FIELDS(3)= func YJSONSERIALIZE.GET_STR("blockParamField", [F:YVPR]BASPAG(I), 1)
          YBLOCK_FIELDS(4)= func YJSONSERIALIZE.GET_INT("blockVisible", [F:YVPR]YVISBLOC(I), 1)
          YBLOCKS(B)= func YJSONSERIALIZE.GET_CLBOBJ_FROM_STRARRAY(AVOID.ACHAR, YBLOCK_FIELDS, 1, 1)
          B += 1
        Endif
      Next
      Append YSCREEN(9), func YJSONSERIALIZE.GET_CLBARRAY_FROM_CLBARRAY("blocks", YBLOCKS, 1)
      Append YSCREEN(10), func YJSONSERIALIZE.GET_EMPTYARRAY("fields", 0)
      # oggetto screen
      YSCREENS(J)= func YJSONSERIALIZE.GET_CLBOBJ(AVOID.ACHAR, YSCREEN, 1, 1)
      J += 1
    Next

    WINDOWFIELDS_INDEX+=1
    YWINDOW_FIELDS(WINDOWFIELDS_INDEX) = func YJSONSERIALIZE.GET_CLBARRAY_FROM_CLBARRAY("screens", YSCREENS, 1)
#    WINDOWFIELDS_INDEX+=1
#    YWINDOW_FIELDS(WINDOWFIELDS_INDEX)= func YJSONSERIALIZE.GET_EMPTYARRAY("buttons", 0)
    YACTION_FIELDS(12) = func YJSONSERIALIZE.GET_CLBOBJ("window", YWINDOW_FIELDS, 0, 1)
    Append YRESPONSE, func YJSONSERIALIZE.GET_CLBOBJ("action", YACTION_FIELDS, 0, 1)
    Append YRESPONSE, func YJSONSERIALIZE.GET_CLOSECURLYBRACKET()
  Next
#Call YPRINT_CLB(YRESPONSE, "YRESPONSE", "json") From YUTILS

  Call FERME_TRACE From LECFIC

End

#######################################################################################################

Subprog YWINBTS(WINCODE, YRESPONSE)
  Value Char WINCODE
  Variable Clbfile YRESPONSE

  Call OUVRE_TRACE("YWINBTS") From LECFIC

  Local File YVWINBTN [F:YVWB]

  Local Char YPARAM_FIELDS(250)(4)
  Local Clbfile YACTION_FIELDS(1)(12), YBUTTON_FIELDS(1)(6)

  Local Clbfile YACTION(1), YPARAM(1), YBUTTON(2)

  Local Integer I, J, COUNT_BUTTONS : I = 0 : J = 0 : BUTTON_COUNT = 0

  Columns [F:YVWB] (CODACT, ACTION, CODTRT, SPETRT, SUBPRG, ACTSUI, PARAM1, PARAM2, PARAM3, PARAM4,
&                   CODPAR, VALPAR, TYPPAR, YSENDAX3M, CODACTBOUT, NUM, CODBOUT, TYPBOUT, TEXTE)

  Filter [F:YVWB] Where WIN = WINCODE
&                 Order By Key CLE=CODBOUT;CODPAR

  Local Clbfile YPARAMETERS(1)(0..), YBUTTONS(1)(0..)
  Local Integer YROWCOUNT : YROWCOUNT = rowcount([F:YVWB])
  If YROWCOUNT > 0

    YRESPONSE = func YJSONSERIALIZE.GET_OPENCURLYBRACKET()

    For [F:YVWB]CLE(1)
      YACTION_FIELDS(0) = func YJSONSERIALIZE.GET_STR("activityCode", [F:YVWB]CODACT, 1)
      YACTION_FIELDS(1) = func YJSONSERIALIZE.GET_STR("code", [F:YVWB]ACTION, 1)
      YACTION_FIELDS(2) = func YJSONSERIALIZE.GET_INT("number", [F:YVWB]NUM, 1)
      YACTION_FIELDS(3) = func YJSONSERIALIZE.GET_STR("stdTrt", [F:YVWB]CODTRT, 1)
      YACTION_FIELDS(4) = func YJSONSERIALIZE.GET_STR("speTrt", [F:YVWB]SPETRT, 1)
      YACTION_FIELDS(5) = func YJSONSERIALIZE.GET_STR("subProg", [F:YVWB]SUBPRG, 1)
      YACTION_FIELDS(6) = func YJSONSERIALIZE.GET_STR("nextAction", [F:YVWB]ACTSUI, 1)
      YACTION_FIELDS(7) = func YJSONSERIALIZE.GET_STR("consultationCode", [F:YVWB]PARAM1, 1)
      YACTION_FIELDS(8) = func YJSONSERIALIZE.GET_STR("mainWindow", [F:YVWB]PARAM2, 1)
      YACTION_FIELDS(9) = func YJSONSERIALIZE.GET_STR("initialInsertion", num$([F:YVWB]PARAM3), 1)
      YACTION_FIELDS(10) = func YJSONSERIALIZE.GET_STR("windowCriteria", [F:YVWB]PARAM4, 1)

      For [F:YVWB]CLE(2)
        YPARAM_FIELDS(0) = func YJSONSERIALIZE.GET_STR("parameterCode", [F:YVWB]CODPAR, 1)
        YPARAM_FIELDS(1) = func YJSONSERIALIZE.GET_STR("parameterValue", [F:YVWB]VALPAR, 1)
        YPARAM_FIELDS(2) = func YJSONSERIALIZE.GET_INT("parameterType", [F:YVWB]TYPPAR, 1)
        YPARAM_FIELDS(3) = func YJSONSERIALIZE.GET_INT("sendAX3M", [F:YVWB]YSENDAX3M, 1)

        YPARAM = func YJSONSERIALIZE.GET_CLBOBJ_FROM_STRARRAY(AVOID.ACHAR, YPARAM_FIELDS, 1, 1)
        YPARAMETERS(J) = YPARAM
        J += 1
      Next
      J = 0

      YACTION_FIELDS(11) = func YJSONSERIALIZE.GET_CLBARRAY_FROM_CLBARRAY("parameters", YPARAMETERS, 1)

      YACTION = func YJSONSERIALIZE.GET_CLBOBJ("action", YACTION_FIELDS, 0, 1)

      YBUTTON_FIELDS(0) = func YJSONSERIALIZE.GET_STR("activityCode", [F:YVWB]CODACTBOUT, 1)
      YBUTTON_FIELDS(1) = func YJSONSERIALIZE.GET_STR("number", num$([F:YVWB]NUM), 1)
      YBUTTON_FIELDS(2) = func YJSONSERIALIZE.GET_STR("code", [F:YVWB]CODBOUT, 1)
      YBUTTON_FIELDS(3) = func YJSONSERIALIZE.GET_STR("type", num$([F:YVWB]TYPBOUT), 1)
      YBUTTON_FIELDS(4) = func YJSONSERIALIZE.GET_STR("description", [F:YVWB]TEXTE, 1)
      YBUTTON_FIELDS(5) = YACTION

      YBUTTON = func YJSONSERIALIZE.GET_CLBOBJ(AVOID.ACHAR, YBUTTON_FIELDS, 1, 1)
      YBUTTONS(I) = YBUTTON

      Raz YACTION, YBUTTON, YPARAMETERS
      I += 1

    Next

    YRESPONSE += func YJSONSERIALIZE.GET_CLBARRAY_FROM_CLBARRAY("buttons", YBUTTONS, 1)
    YRESPONSE += func YJSONSERIALIZE.GET_CLOSECURLYBRACKET()

  Endif

#Call YPRINT_CLB(YRESPONSE, "YRESPONSE", "json") From YUTILS
  Call FERME_TRACE From LECFIC
End

##########################################################################################
Subprog YSCRFLD(SCREENCODE, YRESPONSE)
  Variable Char SCREENCODE
  Variable Clbfile YRESPONSE

  Local Char YCRITERE(250)

  Call OUVRE_TRACE("YSCRFLD") From LECFIC

  Local File YVSCRFLD [F:YVSF]
  Local File APLSTD [F:YAST]

  Local Integer I, J, K, L
  Const Integer TEXT_TYPE : TEXT_TYPE = 10

  Local Char YLOCALMENU_ITEM(250), YLOCALMENU_FIELDS(250)(3), YPARAM_FIELDS(250)(4)
  Local Clbfile YTYPE_ITEM(1)(0..5), YFIELD_ITEM(1), YACTION_ITEMS(1)(6),
&               YPARAMETERS(1)(0..), YACTION(1)(0..), YFIELDS_DATA(1)(0..)

  YCRITERE = "CODMSK='" + SCREENCODE  + "'"

  Columns [F:YVSF] (CODACT, CODZON, CODTYP, YTEXTE, TYPTYP, TYPDES, LNGTYP, NOLIB, TEXTE, DIME, LONG, LIEN, NUMBLOC, NOZONE, VALDEF, OPTFOR,
&                   OBLIG, BREAKAFTER, TYPGRAPH, SAIAFF, VAL1, VAL2, YSCANMODE, ACTION, LANNUM, CODTRT, SPETRT, SUBPRG, CODPAR, VALPAR, TYPPAR, YSENDAX3M)
  Filter [F:YVSF] Where evalue(YCRITERE)
&                 Order By Key CLE=CODZON;ACTION;NOPAR

  Local Integer YROWCOUNT : YROWCOUNT = rowcount([F:YVSF])
  If YROWCOUNT > 0
    Local Clbfile YFIELDS(1)(0..)
    Local Char YLOCALMENUS(250)(0..)

    YRESPONSE = func YJSONSERIALIZE.GET_OPENCURLYBRACKET()
    I = 0

    For [F:YVSF]CLE(1)
      YFIELDS_DATA(0) = func YJSONSERIALIZE.GET_STR("activityCode", [F:YVSF]CODACT, 1)
      YFIELDS_DATA(1) = func YJSONSERIALIZE.GET_STR("code", [F:YVSF]CODZON, 1)

      #Gestione tipo dato come oggetto
      YTYPE_ITEM(0) = func YJSONSERIALIZE.GET_STR("value", [F:YVSF]CODTYP, 1)
      YTYPE_ITEM(1) = func YJSONSERIALIZE.GET_STR("description", [F:YVSF]YTEXTE, 1)
      YTYPE_ITEM(2) = func YJSONSERIALIZE.GET_INT("typeValue", [F:YVSF]TYPTYP, 1)
      YTYPE_ITEM(3) = func YJSONSERIALIZE.GET_STR("typeDescription", [F:YVSF]TYPDES, 1)
      YTYPE_ITEM(4) = func YJSONSERIALIZE.GET_INT("length", [F:YVSF]LNGTYP, 1)

      #Se TipoDato : Clob, Lungh = numero di caratteri associato a sua Dim
      If([F:YVSF]TYPTYP = TEXT_TYPE)
        YTYPE_ITEM(4) = func YJSONSERIALIZE.GET_INT("length", 512 * 2^[F:YVSF]LNGTYP - 2, 1)
      Else
        YTYPE_ITEM(4) = func YJSONSERIALIZE.GET_INT("length", [F:YVSF]LNGTYP, 1)
      Endif

      If [F:YVSF]NOLIB > 0
        Columns [F:YAST] (LANCHP, LANNUM, LANMES)
        Filter [F:YAST] Where LANCHP = [F:YVSF]NOLIB & LANNUM > 0 & LAN = GLANGUE
        J = 0
        For [F:YAST]
          YLOCALMENU_FIELDS(0) = func YJSONSERIALIZE.GET_INT("chapter", [F:YAST]LANCHP, 1)
          YLOCALMENU_FIELDS(1) = func YJSONSERIALIZE.GET_INT("number_", [F:YAST]LANNUM, 1)
          YLOCALMENU_FIELDS(2) = func YJSONSERIALIZE.GET_STR("message", [F:YAST]LANMES, 1)
          YLOCALMENU_ITEM = func YJSONSERIALIZE.GET_STROBJ(AVOID.ACHAR, YLOCALMENU_FIELDS, 1, 1)
          YLOCALMENUS(J) = YLOCALMENU_ITEM
          J += 1
        Next
        YTYPE_ITEM(5) = func YJSONSERIALIZE.GET_CLBARRAY_FROM_STRARRAY("localMenu", YLOCALMENUS, 1)
        Filter [F:YAST]
      Endif

      YFIELDS_DATA(2) = func YJSONSERIALIZE.GET_CLBOBJ("type", YTYPE_ITEM, 0, 1)
      YFIELDS_DATA(3) = func YJSONSERIALIZE.GET_STR("description", [F:YVSF]TEXTE, 1)
      YFIELDS_DATA(4) = func YJSONSERIALIZE.GET_INT("dim", [F:YVSF]DIME, 1)
      YFIELDS_DATA(5) = func YJSONSERIALIZE.GET_INT("length", [F:YVSF]LONG, 1)
      YFIELDS_DATA(6) = func YJSONSERIALIZE.GET_INT("linkedField", [F:YVSF]LIEN, 1)
      YFIELDS_DATA(7) = func YJSONSERIALIZE.GET_INT("blockNumber", [F:YVSF]NUMBLOC, 1)
      YFIELDS_DATA(8) = func YJSONSERIALIZE.GET_INT("blockFieldNumber", [F:YVSF]NOZONE, 1)
      YFIELDS_DATA(9) = func YJSONSERIALIZE.GET_STR("defaultValue", [F:YVSF]VALDEF, 1)
      YFIELDS_DATA(10) = func YJSONSERIALIZE.GET_STR("formatOptions", [F:YVSF]OPTFOR, 1)
      YFIELDS_DATA(11) = func YJSONSERIALIZE.GET_BOOL("mandatory", func YUTILS.IIF([F:YVSF]OBLIG = 2, 1, 0) , 1)
      YFIELDS_DATA(12) = func YJSONSERIALIZE.GET_BOOL("breakAfter", func YUTILS.IIF([F:YVSF]BREAKAFTER = 2, 1, 0) , 1)
      YFIELDS_DATA(13) = func YJSONSERIALIZE.GET_INT("UIControl", [F:YVSF]TYPGRAPH, 1)

      If([F:YVSF]TYPGRAPH = 10)
        #Inizio Gestione Righe & Colonne per Testo Multiriga:
        YFIELDS_DATA(14) = func YJSONSERIALIZE.GET_INT("rowNumber", [F:YVSF]VAL1, 1)
        YFIELDS_DATA(15) = func YJSONSERIALIZE.GET_INT("columnNumber", [F:YVSF]VAL2, 1)
        #Fine Gestione Righe & Colonne  per Testo Multiriga:

        YFIELDS_DATA(16) = func YJSONSERIALIZE.GET_INT("entryType", [F:YVSF]SAIAFF, 1)
        YFIELDS_DATA(17) = func YJSONSERIALIZE.GET_INT("localMenu", [F:YVSF]NOLIB, 1)
        YFIELDS_DATA(18) = func YJSONSERIALIZE.GET_INT("scanMode", [F:YVSF]YSCANMODE, 1)
      Else
        YFIELDS_DATA(14) = func YJSONSERIALIZE.GET_INT("entryType", [F:YVSF]SAIAFF, 1)
        YFIELDS_DATA(15) = func YJSONSERIALIZE.GET_INT("localMenu", [F:YVSF]NOLIB, 1)
        YFIELDS_DATA(16) = func YJSONSERIALIZE.GET_INT("scanMode", [F:YVSF]YSCANMODE, 1)
      Endif

      #Action
      L = 0
      For [F:YVSF]CLE(2)
        If vireblc([F:YVSF]ACTION, 2) <> AVOID.ACHAR
          Raz YACTION_ITEMS  # Pulizia dei dati precedenti
          YACTION_ITEMS(0) = func YJSONSERIALIZE.GET_STR("code", [F:YVSF]ACTION, 1)
          YACTION_ITEMS(1) = func YJSONSERIALIZE.GET_INT("number", [F:YVSF]LANNUM, 1)
          YACTION_ITEMS(2) = func YJSONSERIALIZE.GET_STR("stdTrt", [F:YVSF]CODTRT, 1)
          YACTION_ITEMS(3) = func YJSONSERIALIZE.GET_STR("speTrt", [F:YVSF]SPETRT, 1)
          YACTION_ITEMS(4) = func YJSONSERIALIZE.GET_STR("subProg", [F:YVSF]SUBPRG, 1)

          Raz YPARAMETERS  # Azzeramento array parametri
          K = 0
          For [F:YVSF]CLE(3)
            YPARAM_FIELDS(0) = func YJSONSERIALIZE.GET_STR("parameterCode", [F:YVSF]CODPAR, 1)
            YPARAM_FIELDS(1) = func YJSONSERIALIZE.GET_STR("parameterValue", [F:YVSF]VALPAR, 1)
            YPARAM_FIELDS(2) = func YJSONSERIALIZE.GET_INT("parameterType", [F:YVSF]TYPPAR, 1)
            YPARAM_FIELDS(3) = func YJSONSERIALIZE.GET_INT("sendAX3M", [F:YVSF]YSENDAX3M, 1)

            YPARAMETERS(K) = func YJSONSERIALIZE.GET_CLBOBJ_FROM_STRARRAY(AVOID.ACHAR, YPARAM_FIELDS, 1, 1)
            K += 1
          Next
          YACTION_ITEMS(5) = func YJSONSERIALIZE.GET_CLBARRAY_FROM_CLBARRAY("actionParameters", YPARAMETERS, 1)

          YACTION(L) = func YJSONSERIALIZE.GET_CLBOBJ(AVOID.ACHAR, YACTION_ITEMS, 1, 1)
          L += 1
        Endif
      Next

      YFIELDS_DATA(17) = func YJSONSERIALIZE.GET_CLBARRAY_FROM_CLBARRAY("fieldActions", YACTION, 1)

      #fine action
      YFIELD_ITEM = func YJSONSERIALIZE.GET_CLBOBJ(AVOID.ACHAR, YFIELDS_DATA, 1, 1)
      YFIELDS(I) = YFIELD_ITEM

      Raz  YTYPE_ITEM, YFIELDS_DATA, YACTION
      I += 1
    Next

    YRESPONSE += func YJSONSERIALIZE.GET_CLBARRAY_FROM_CLBARRAY("fields", YFIELDS, 1)
    YRESPONSE += func YJSONSERIALIZE.GET_CLOSECURLYBRACKET()
  Endif
  Filter [F:YVSF]

  Call FERME_TRACE From LECFIC

End

#######################################################################################################

Subprog YACTFLDPAR(SCREENCODE, FIELDCODE, YRESPONSE)
  Value Char SCREENCODE
  Value Char FIELDCODE
  Variable Clbfile YRESPONSE

  Local File YVFLDACTPAR [F:YVFAP]

  Local Char YCRITERE(250), YPARAM_FIELDS(250)(4)
  Local Clbfile YACTION_ITEMS(1)(6), YPARAM(1)
  Local Integer I, J : I = 0 : J = 0

  Call OUVRE_TRACE("YACTFLDPAR") From LECFIC

  YCRITERE -= "CODAFF = '" + SCREENCODE + "' &" - "CODZON = '" + FIELDCODE + "'"

  Columns [F:YVFAP] (ACTION, LANNUM, CODTRT, SPETRT, SUBPRG, CODPAR, VALPAR, TYPPAR, YSENDAX3M)
  Filter [F:YVFAP] Where evalue(YCRITERE)
&                  Order By Key CLE = ACTION;NOPAR

  Local Integer YROWCOUNT : YROWCOUNT = rowcount([F:YVFAP])
  If YROWCOUNT > 0
    Local Clbfile YPARAMETERS(1)(rowcount([F:YVFAP]))  # Array per i parametri
    Local Clbfile YACTION(1)(rowcount([F:YVFAP]))  # Array per le azioni

    YRESPONSE = func YJSONSERIALIZE.GET_OPENCURLYBRACKET()
    YRESPONSE += func YJSONSERIALIZE.GET_OPENSQUAREBRACKET_KEY("actions")  # Inizio array actions

    For [F:YVFAP]CLE(1)
      Raz YACTION_ITEMS  # Pulizia dei dati precedenti

      YACTION_ITEMS(0) = func YJSONSERIALIZE.GET_STR("code", [F:YVFAP]ACTION, 1)
      YACTION_ITEMS(1) = func YJSONSERIALIZE.GET_INT("number", [F:YVFAP]LANNUM, 1)
      YACTION_ITEMS(2) = func YJSONSERIALIZE.GET_STR("stdTrt", [F:YVFAP]CODTRT, 1)
      YACTION_ITEMS(3) = func YJSONSERIALIZE.GET_STR("speTrt", [F:YVFAP]SPETRT, 1)
      YACTION_ITEMS(4) = func YJSONSERIALIZE.GET_STR("subProg", [F:YVFAP]SUBPRG, 1)

      Raz YPARAMETERS  # Azzeramento array parametri
      I = 0

      For [F:YVFAP]CLE(2)
        YPARAM_FIELDS(0) = func YJSONSERIALIZE.GET_STR("parameterCode", [F:YVFAP]CODPAR, 1)
        YPARAM_FIELDS(1) = func YJSONSERIALIZE.GET_STR("parameterValue", [F:YVFAP]VALPAR, 1)
        YPARAM_FIELDS(2) = func YJSONSERIALIZE.GET_INT("parameterType", [F:YVFAP]TYPPAR, 1)
        YPARAM_FIELDS(3) = func YJSONSERIALIZE.GET_INT("sendAX3M", [F:YVFAP]YSENDAX3M, 1)

        YPARAM = func YJSONSERIALIZE.GET_CLBOBJ_FROM_STRARRAY(AVOID.ACHAR, YPARAM_FIELDS, 1, 1)
        YPARAMETERS(I) = YPARAM
        I += 1
      Next

      YACTION_ITEMS(5) = func YJSONSERIALIZE.GET_CLBARRAY_FROM_CLBARRAY("actionParameters", YPARAMETERS, 1)

      YACTION(J) = func YJSONSERIALIZE.GET_CLBOBJ(AVOID.ACHAR, YACTION_ITEMS, 1, 1)
      J += 1  # Incremento J solo qui
    Next

    Append YRESPONSE, func YJSONSERIALIZE.GET_CLBARRAY_FROM_CLBARRAY(AVOID.ACHAR, YACTION, 1)

    YRESPONSE += func YJSONSERIALIZE.GET_CLOSESQUAREBRACKET()  # Fine array actions
    YRESPONSE += func YJSONSERIALIZE.GET_CLOSECURLYBRACKET()  # Fine JSON

  Endif

  Call FERME_TRACE From LECFIC

End

##########################################################################################

Subprog YSCRFLDTYP(FIELDTYPE, YRESPONSE)
  Value Char FIELDTYPE
  Variable Clbfile YRESPONSE

  Local File YVSCRFLDTYP [F:YVSFT]

  Local Char YCRITERE(250)
  Local Char YLOCALMENU_FIELDS(250)(3)
  Local Char YLOCALMENU_ITEM(250)

  Local Integer I

  Call OUVRE_TRACE("YSCRFLDTYP") From LECFIC

  YCRITERE = "1=1"
  If vireblc(FIELDTYPE, 2) <> AVOID.ACHAR
    YCRITERE -= "& CODTYP = '" + FIELDTYPE + "'"
  Endif

  Filter [F:YVSFT] Where evalue(YCRITERE)
&                  Order By Key CLE = CODTYP;NOLIB;LANNUM

  Local Integer YROWCOUNT : YROWCOUNT = rowcount([F:YVFAP])
  If YROWCOUNT > 0

    Local Clbfile YLOCALMENUS(1)(rowcount([F:YVSFT]))
    YRESPONSE = func YJSONSERIALIZE.GET_OPENCURLYBRACKET()

    For [F:YVSFT]CLE(1)

      YRESPONSE += func YJSONSERIALIZE.GET_STR("value", [F:YVSFT]CODTYP, 0)
      YRESPONSE += func YJSONSERIALIZE.GET_STR("description", [F:YVSFT]TEXTE, 0)
      YRESPONSE += func YJSONSERIALIZE.GET_INT("typeValue", [F:YVSFT]TYPTYP, 0)
      YRESPONSE += func YJSONSERIALIZE.GET_STR("typeDescription", [F:YVSFT]TYPDES, 0)
      YRESPONSE += func YJSONSERIALIZE.GET_INT("length", [F:YVSFT]LNGTYP, 0)

      I = 0
      For [F:YVSFT]CLE(3)
        If [F:YVSFT]NOLIB > 0
          YLOCALMENU_FIELDS(0) = func YJSONSERIALIZE.GET_INT("chapter", [F:YVSFT]NOLIB, 1)
          YLOCALMENU_FIELDS(1) = func YJSONSERIALIZE.GET_INT("number_", [F:YVSFT]LANNUM, 1)
          YLOCALMENU_FIELDS(2) = func YJSONSERIALIZE.GET_STR("message", [F:YVSFT]LANMES, 1)

          YLOCALMENU_ITEM = func YJSONSERIALIZE.GET_STROBJ(AVOID.ACHAR, YLOCALMENU_FIELDS, 1, 1)
          YLOCALMENUS(I) = YLOCALMENU_ITEM
          I += 1
        Endif
      Next

      YRESPONSE += func YJSONSERIALIZE.GET_CLBARRAY_FROM_CLBARRAY("localMenu", YLOCALMENUS, 1)

    Next

    YRESPONSE += func YJSONSERIALIZE.GET_CLOSECURLYBRACKET()

  Endif

  Call FERME_TRACE From LECFIC

End
**********
7,"TRT","YAX3MPROTOCOLLIB",""
2,"TRT","YAX3MSEL",""
#<AdxTL>@(#)0.0.0.0 $Revision$
###################################################################################################################################
#               LIBRERIA PER SELEZIONI(Custom classiche/multivalore - Ad oggetto)/CONSULTAZIONI (AX3M)
###################################################################################################################################

#**
#* Subprog per Selezione Custom con valorizzazione Multi-Campo per MOBILE
#*
#* @param FUNCTION Funzione utilizzata
#* @param TYPE_FIELD Tipo del Campo
#* @param PARAMS Parametri per Critere
#* @param CRITERE Array per Critere
#* @param QUERY stringa per ricerca in "OR" nel Record set ottenuto da Critere
#* @param SELECTEDFIELDS Array con elenco dei campi da valorizzare in Selezione (MOD. Selezione con valorizzazione multi-campo)
#* @param RESPONSE Clob di riposta per Grid
#*!

Subprog SEL_MULTICUSTOM(FUNCTION, TYPE_FIELD, PARAMS, CRITERE, QUERY, SELECTEDFIELDS, RESPONSE)

  Value Char FUNCTION
  Value Char TYPE_FIELD
  Value Char PARAMS()
  Value Char CRITERE()
  Value Char QUERY
  Value Char SELECTEDFIELDS()()
  Variable Clbfile RESPONSE

Call ECR_TRACE("SEL_MULTICUSTOM",0) From GESECRAN
  Gosub SEL_BASECUSTOM
End

###############################################################################################
#**
#* Subprog per Selezione Custom Campo per MOBILE
#*
#* @param FUNCTION Funzione utilizzata
#* @param TYPE_FIELD Tipo del Campo
#* @param PARAMS Parametri per Critere
#* @param CRITERE Array per Critere
#* @param QUERY stringa per ricerca in "OR" nel Record set ottenuto da Critere
#* @param RESPONSE Clob di riposta per Grid
#*!

Subprog SEL_CUSTOM(FUNCTION, TYPE_FIELD, PARAMS, CRITERE, QUERY, RESPONSE)

  Value Char FUNCTION
  Value Char TYPE_FIELD
  Value Char PARAMS()
  Value Char CRITERE()
  Value Char QUERY
  Variable Clbfile RESPONSE

  Local Char SELECTEDFIELDS(0)(1) #inizializzato array per selez multi-campo
  Gosub SEL_BASECUSTOM
End

###################################################################################################
#**
#* Sub per Selezione Custom :
#* Richiamata in modalità: selez mono-campo(classica)(SEL_CUSTOM); selez multi-campo (SEL_MULTICUSTOM)
#*!

$SEL_BASECUSTOM

#Call OUVRE_TRACE("SEL_BASECUSTOM-"-FUNCTION-"-"-TYPE_FIELD) From LECFIC

  #Logging
  Local Char YLOGDIRNAME(20): YLOGDIRNAME = "ArgoX3Mobile_Log"

  #modalità mobile
  Local Shortint IS_MOBILE : IS_MOBILE = 2

  #apertura file
  Local Shortint OPEN : OPEN = 2
  Local Shortint COUNT_VALUES # viene settata in confgrd con la rowcount della link

  Gosub HANDLE_FILES
  Gosub CONFIG_GRID

  Local Char HEADER(250)( NUM_COLS, 2 )

  Local Char VALUES(250)( COUNT_VALUES, NUM_COLS )

  #Vengono settati gli array HEADER e VALUES necessari per la serializzazione del JSON
  Gosub SET_HEADERVALUES

  #chiusura file
  OPEN = 1
  Gosub HANDLE_FILES

  Gosub QUERY_FILTER

  Local Char EMPTY_FIELDS(0)(0..1,0..1)
  Local Char ALERT_WS(0)(0..1,0..1)
  Local Char YOPENFUNCTION(250)(4)

  #caso in cui è stata inserita una query da mobile, se il count sul filtro è maggiore di 0 printiamo i filtrati su json
  If(COUNT_CUSTOM > 0)
    RESPONSE = func YJSONSERIALIZE.GENERATE_JSON(0, AVOID.ACHAR, AVOID.ACHAR, ALERT_WS, YOPENFUNCTION ,EMPTY_FIELDS, HEADER, FILTERED_VALUES, SELECTEDFIELDS)

  #caso in cui NON c'è query, printiamo l'oggetto complessivo su json
  Elsif(COUNT_VALUES > 0 & vireblc(QUERY, 2) = AVOID.ACHAR)

    RESPONSE = func YJSONSERIALIZE.GENERATE_JSON(0, AVOID.ACHAR, AVOID.ACHAR, ALERT_WS, YOPENFUNCTION,EMPTY_FIELDS, HEADER, VALUES, SELECTEDFIELDS)

  #caso in cui non ci sono dati di output
  Else
    Local Char FIELDS(0)(1,1)
    Local Char HEADER(0)(1,1)
    Local Char DATA(0)(1,1)

    RESPONSE = func YJSONSERIALIZE.GENERATE_JSON(1, "error", "La ricerca non ha prodotto risultati!", ALERT_WS, YOPENFUNCTION,FIELDS, HEADER, DATA, SELECTEDFIELDS)

  Endif

  #END_SELCUSTOM_LOG
  Gosub YAX3MOB_SET_ENV From YAX3MLOG
  Call YPRINT_DIR_CLB(YPAYLOADDIRNAME, RESPONSE, "RESPONSE_" + "selcustom_"+FUNCTION+"_"+TYPE_FIELD, "json") From YUTILS

Return

##############################################################################################################################################
#**
#* Subprog per Selezione ad Oggetto MOBILE
#*
#* @param OBJECT Codice Oggetto in esame
#* @param QUERY stringa per ricerca in "OR" nel Record set ottenuto da Critere
#* @param RESPONSE Clob di riposta per Grid
#*!

Subprog SEL_OBJ(OBJECT, QUERY, RESPONSE)
  Value Char OBJECT
  Value Char QUERY
  Variable Clbfile RESPONSE

 Call OUVRE_TRACE("SEL_OBJ-"-OBJECT) From LECFIC
 #Local Char YTSEL_START(50), YTSEL_END(50), YT1(50),YT2(50),YT3(50),YT3A(50),YT3B(50),YT4(50)

  If GWEBSERV

    #Apertura File
    Local File ATABZON [ATZ]
    Local File ATEXTE [ATE]
    Local File ATEXTE [YATE]
    Local File AOBJET [AOB]
    Local File AOBJLST [AOL]
    Local File ATABLE [ATB]

    Local Char TEXTE(5) : TEXTE = "TEXTE"
    Local Char YLOGDIRNAME(20): YLOGDIRNAME = "ArgoX3Mobile_Log"

    Read [F:AOB]ABREV=OBJECT

    Local Char HEADERCRITERE(250)
    HEADERCRITERE = "[F:ATZ]CODFIC = [F:AOB]NOMFIC"
    HEADERCRITERE -= "& find([F:ATZ]CODZONE, [F:AOL]SELZON)"
    Link [ATZ] With [F:ATE]NUMERO~=GLANGUE;[F:ATZ]NOLONG
&                  ,[F:ATB]CODFIC~=[F:ATZ]CODFIC
&                  ,[F:AOL]AOL0~= OBJECT As [LNK1]
&              Where evalue(HEADERCRITERE)

    Columns [LNK1] ([F:ATZ]CODZONE, [F:AOL]SELZON, [F:AOL]SELEXP, [F:AOL]SELINT, [F:AOL]SELTYP, [F:AOL]SELFIC, [F:ATE]TEXTE)
    Filter [LNK1] Where evalue(HEADERCRITERE)

    Gosub GET_LINK
    Local Shortint INDEX_HEADER : INDEX_HEADER = 0
    Local Shortint INDEX_CUSTOM : INDEX_CUSTOM = 0
    Local Shortint INDEX_VALUES

    Read [LNK1]NUMLIG First

    Local Integer NUM_COLS : NUM_COLS = func COUNT_ITEMS([F:AOL]SELEXP, [F:AOL]SELZON)
    Local Char HEADER(250)( NUM_COLS, 2 )
    Local Char VARS(30)(NUM_COLS), COLS(30)(NUM_COLS)
    Local Char CRITERE_CUSTOM(250)(0..NUM_COLS)
    Local Clbfile CRITERE(1)

    #nuova parte per filtro con query in like
    If(vireblc(QUERY, 2) <> '')
      CRITERE = "("
      For [LNK1]
        If([F:AOL]SELEXP(INDEX_HEADER) <> AVOID.ACHAR)
          CRITERE_CUSTOM(INDEX_CUSTOM) = evalue([F:AOL]SELEXP)
          INDEX_CUSTOM += 1
        Elsif([F:AOL]SELZON(INDEX_HEADER) <> AVOID.ACHAR)
          COLS(INDEX_HEADER) = "[F]" + [F:ATZ]CODZONE
          VARS(INDEX_HEADER) = [F:ATZ]CODZONE
          CRITERE += "lower(" + VARS(INDEX_HEADER) + ") like lower('%" + QUERY + "%')"
          If INDEX_HEADER < rowcount([LNK1]) - 1
            CRITERE -= "or "
          Endif
        Endif
        INDEX_HEADER+=1
      Next
      CRITERE += ")"
      INDEX_HEADER = 0
    Endif

    Local Shortint COUNT_VALUES : COUNT_VALUES = rowcount([F])
    Local Shortint COUNT_LNK : COUNT_LNK = rowcount([LNK1])
    Local Char VALUES(250)( COUNT_VALUES, NUM_COLS )
    Local Char JVALUE(250)
    Local Char CUSTOM_HEADER(250)
    Local Char SELZON_MESS(250)
    Local Char SELZON_VAL(250)
    Local Char SELZON_CURRENT(25)

    Read [LNK1] First

    For INDEX_HEADER = 0 To dim([F:AOL]SELZON) - 1
      SELZON_CURRENT = [F:AOL]SELZON(INDEX_HEADER)
      If(SELZON_CURRENT <> AVOID.ACHAR)
        If SELZON_CURRENT = TEXTE
          Read [YATE]NUMERO=GLANGUE;[F:AOL]SELINT(INDEX_HEADER)
          HEADER(INDEX_HEADER, 1) = [F:YATE]TEXTE
          CUSTOM_HEADER = [F:AOL]SELZON(INDEX_HEADER - 1) + vireblc(HEADER(INDEX_HEADER, 1), 4)
          HEADER(INDEX_HEADER, 0) = CUSTOM_HEADER
        Else
          HEADER(INDEX_HEADER, 0) = SELZON_CURRENT
          Call TEXTFIC([F:AOL]SELFIC(INDEX_HEADER),HEADER(INDEX_HEADER, 0),2,HEADER(INDEX_HEADER, 1)) From OBJDIV
        Endif
        INDEX_VALUES = 0

        For [F]

          If SELZON_CURRENT = TEXTE #RIMUOVERE e capire come gestirlo
            JVALUE = func AFNC.TEXTRA([F:AOL]SELFIC(INDEX_HEADER - 1), "DESAXX", num$(evalue("[F]" + [F:AOL]SELZON(INDEX_HEADER - 1))),"")
            VALUES(INDEX_VALUES, INDEX_HEADER) = func YJSONSERIALIZE.GET_STR(CUSTOM_HEADER, JVALUE, 1)
            INDEX_VALUES+=1
          Else
            If evalue("type([F]" + SELZON_CURRENT +")") >=0
              SELZON_VAL = num$(evalue("[F]" + SELZON_CURRENT))
            Else
              SELZON_VAL = AVOID.ACHAR
            Endif
            SELZON_MESS = func YUTILS.GET_MESS(SELZON_VAL, [F:AOL]SELFIC(INDEX_HEADER), SELZON_CURRENT )
            JVALUE = func YUTILS.IIF( SELZON_MESS <> AVOID.ACHAR, SELZON_MESS, SELZON_VAL )
            VALUES(INDEX_VALUES, INDEX_HEADER) = func YJSONSERIALIZE.GET_STR(SELZON_CURRENT, JVALUE, 1)
            INDEX_VALUES+=1
          Endif
        Next
      Elsif([F:AOL]SELEXP(INDEX_HEADER) <> AVOID.ACHAR)
        HEADER(INDEX_HEADER, 0) = "CUSTOM" + num$(INDEX_HEADER)
        Read [YATE]NUMERO=GLANGUE;[F:AOL]SELINT(INDEX_HEADER)
        HEADER(INDEX_HEADER, 1) = [F:YATE]TEXTE
        INDEX_VALUES = 0
        For [F] # se usiamo la filter_ F diventa LNK2
          JVALUE = evalue([F:AOL]SELEXP(INDEX_HEADER))
          VALUES(INDEX_VALUES, INDEX_HEADER) = func YJSONSERIALIZE.GET_STR("CUSTOM" + num$(INDEX_HEADER), JVALUE, 1)
          INDEX_VALUES+=1
        Next
      Endif
    Next

    #gestione alias a elaborazione terminata
    Columns [LNK1]
    Raz [F]

    Gosub QUERY_FILTER

    Local Char FIELDS(0)(0..1,0..1)
    Local Char ALERT_WS(0)(0..1,0..1)
    Local Char YOPENFUNCTION(250)(4) #SOLA inizializzazione array per Apertura funzioni in Modale
    Local Char YSELECTEDFIELDS(0)(1) #SOLA inizializzazione array per Selez Multi-campo

    Call ECR_TRACE ("COUNT_VALUES ="-num$(COUNT_VALUES) - "COUNT_CUSTOM ="-num$(COUNT_CUSTOM),0) From GESECRAN

    #caso in cui è stata inserita una query da mobile, se il count sul filtro è maggiore di 0 printiamo i filtrati su json
    If(COUNT_CUSTOM > 0)
      RESPONSE = func YJSONSERIALIZE.GENERATE_JSON(0, AVOID.ACHAR, AVOID.ACHAR, ALERT_WS, YOPENFUNCTION,FIELDS, HEADER, FILTERED_VALUES, YSELECTEDFIELDS)

    #caso in cui NON c'è query, printiamo l'oggetto complessivo su json
    Elsif(COUNT_VALUES > 0 & vireblc(QUERY, 2) = AVOID.ACHAR)

      RESPONSE = func YJSONSERIALIZE.GENERATE_JSON(0, AVOID.ACHAR, AVOID.ACHAR, ALERT_WS, YOPENFUNCTION,FIELDS, HEADER, VALUES,YSELECTEDFIELDS)

    Else
      Local Char FIELDS(0)(1,1)
      Local Char HEADER(0)(1,1)
      Local Char DATA(0)(1,1)

      RESPONSE = func YJSONSERIALIZE.GENERATE_JSON(1, "Errore", "La ricerca non ha prodotto risultati!", ALERT_WS, YOPENFUNCTION,FIELDS, HEADER, DATA, YSELECTEDFIELDS)
    Endif

    #END_SELOBJ_LOG
    Gosub YAX3MOB_SET_ENV From YAX3MLOG
    Call YPRINT_DIR_CLB(YPAYLOADDIRNAME, RESPONSE, "RESPONSE_" + "selobj_"+OBJECT, "json") From YUTILS

  Endif
  Call FERME_TRACE From LECFIC

End

#########################################Selezione custom#################################################
#**
#*Sub per gestione Tabelle per Link - Selez Custom - X3/Mobile
#*!

$HANDLE_FILES

  Gosub HANDLE_FILES From YAX3MWSLIBCUSTOM

Return

###########################################################################################################

#**
#*Sub per apertura tabelle e creazione LINK (contestualmente all'oggetto in esame) usate per la Selezione ad Oggetto
#*!

$GET_LINK

  Gosub GET_LINK From YAX3MWSLIBOBJECT

Return

#########################################QUERY FILTER#################################################
#**
#*Sub per gestione ricerca nella Selezione (ad Oggetto/Custom) - MOBILE
#*!

$QUERY_FILTER

  Local Char TEMP_VALUES(250)(0..COUNT_VALUES, NUM_COLS)
  Local Shortint I, J, ADD_ITEM, INDEX_FILT_VALUES_X, INDEX_FILT_VALUES_Y

  If(vireblc(QUERY, 2) <> '')
    INDEX_FILT_VALUES_X = 0 : INDEX_FILT_VALUES_Y = 0
    For I = 0 To dim(VALUES, 1) - 1
      ADD_ITEM = 1
      For J = 0 To dim(VALUES, 2) - 1
        If instr(1, tolower(VALUES(I, J)), tolower(QUERY)) > 0
          ADD_ITEM = 2
          Break
        Endif
      Next J
      If(ADD_ITEM = 2)
        For J = 0 To NUM_COLS - 1
          TEMP_VALUES(INDEX_FILT_VALUES_Y, J) = VALUES(I, J)
        Next J
        INDEX_FILT_VALUES_Y += 1
      Endif
    Next I
  Endif

  Local Shortint COUNT_CUSTOM
  COUNT_CUSTOM = func YUTILS.COUNT_MULTI(TEMP_VALUES)

  If COUNT_CUSTOM > 0
    Local Char FILTERED_VALUES(250)(COUNT_CUSTOM, NUM_COLS)
    For I = 0 To COUNT_CUSTOM - 1
      For J = 0 To NUM_COLS - 1
        FILTERED_VALUES(I, J) = TEMP_VALUES(I, J)
      Next
    Next
  Endif

Return

#########################################SET_HEADERVALUES#################################################

$SET_HEADERVALUES
  Local Char COL_VALUE(250)
  # === FASE 1: Setup Header (identico all'originale) ===
  Local Shortint INDEX_HEADER
  For INDEX_HEADER = 0 To NUM_COLS - 1
    HEADER(INDEX_HEADER, 0) = FIELDS(INDEX_HEADER)
    HEADER(INDEX_HEADER, 1) = TIT(INDEX_HEADER)
  Next

  # === FASE 2: Popolazione VALUES (OTTIMIZZATA) ===
  Local Shortint INDEX_VALUES : INDEX_VALUES = 0
  Local Shortint HAS_ACTIONS_COL : HAS_ACTIONS_COL = 0
  Local Shortint ACTIONS_COL_IDX : ACTIONS_COL_IDX = -1

  # Pre-check: individua colonna "actions" se presente
  For INDEX_HEADER = 0 To NUM_COLS - 1
    If HEADER(INDEX_HEADER, 0) = "actions"
      HAS_ACTIONS_COL = 1
      ACTIONS_COL_IDX = INDEX_HEADER
      Break
    Endif
  Next

  # *** ATTRAVERSAMENTO SINGOLO DEL LINK ***
  For [LNK]
    # Per OGNI riga, processa TUTTE le colonne
    For INDEX_HEADER = 0 To NUM_COLS - 1
      # Gestione colonna "actions" (multimedia)
      If INDEX_HEADER = ACTIONS_COL_IDX
        VALUES(INDEX_VALUES, INDEX_HEADER) = YMEDIA(INDEX_VALUES)
      # Gestione colonne normali
      Else

        # Evalua il valore della colonna corrente
        If vireblc(COL(INDEX_HEADER), 2) = AVOID.ACHAR & vireblc(HEADER(INDEX_HEADER, 0), 2) <> AVOID.ACHAR
          # Colonna vuota/non disponibile
          COL_VALUE = AVOID.ACHAR
        Else
          # Converti il valore in stringa
          COL_VALUE = num$(evalue(COL(INDEX_HEADER)))
        Endif

        # Costruisci JSON key-value
        VALUES(INDEX_VALUES, INDEX_HEADER) = func YJSONSERIALIZE.GET_STR(HEADER(INDEX_HEADER, 0), COL_VALUE, 1)
      Endif

    Next

    INDEX_VALUES += 1
  Next

Return

#

#########################################CONFIG_GRID######################################################
#**
#*Sub per Configurazione Griglia di selezione(Custom) - X3/MOBILE
#*!

$CONFIG_GRID

  Gosub CONFIG_GRID From YAX3MWSLIBCUSTOM

Return

#########################################COUNT_ITEMS######################################################

#utilità
Funprog COUNT_ITEMS(SELZON, SELEXP)
  Value Char SELZON()
  Value Char SELEXP()

  Local Integer I
  Local Integer COUNT : COUNT = 0

  For I = 0 To dim(SELZON) - 1
    If(vireblc(SELZON(I),2) <> AVOID.ACHAR | vireblc(SELEXP(I),2) <> AVOID.ACHAR)
      COUNT+=1
    Endif
  Next I

End COUNT

###########################################################################################################
###########################################################################################################
#**
#* Sub per Selezione per Consultazioni (chiamata da YAX3MOB_ENDBUTTONACTION)
#*!

$SEL_CONS

  #qui arrivo con già settati: LNK ; Critere ; Count_values; NUM_COLS = num
  #ex INIT_GRID

  Local Char TIT(250)(NUM_COLS)
  Local Char COL(250)(NUM_COLS)
  Local Char FIELDS(20)(NUM_COLS)
  Local Integer NBCOL: NBCOL = 0

  If(vireblc(YFUNC_NAME,2)= AVOID.ACHAR)
    Call ECR_TRACE("Attenzione! Il nome dello script(funzione) non è stato dichiarato!",0) From GESECRAN
    YFUNC_NAME = "EMPTY_func_name"
  Else

    Gosub SET_AX3M_FIELDS From =YFUNC_NAME    #setting FIELDS per GRID
    Default File [LNK]
    Gosub SET_AX3M_TIT_COL From =YFUNC_NAME   #setting TIT & COL per GRID

    Local Char HEADER(250)( NUM_COLS, 2 )
    Local Char VALUES(250)( COUNT_VALUES, NUM_COLS )

    #Vengono settati gli array HEADER e VALUES necessari per la serializzazione del JSON
    Gosub SET_HEADERVALUES
    Gosub QUERY_FILTER

    Local Char EMPTY_FIELDS(0)(0..1,0..1)
    Local Char ALERT_WS(0)(0..1,0..1)

    #ATTENZIONE!! QUI: non necessario dichiarare YOPENFUNCTION: è un metodo per bottoni di Consultazione,
    #dunque già dichiarato nell'INIT_BUTTONACTION
    If(type(YOPENFUNCTION)<0)
      Local Char YOPENFUNCTION(250)(4)
    Endif

    If(type(YSELECTEDFIELDS)<0)
      Local Char YSELECTEDFIELDS(0)(1)
    Endif

    #caso in cui è stata inserita una query da mobile, se il count sul filtro è maggiore di 0 printiamo i filtrati su json
    If(COUNT_CUSTOM > 0)
      YRESPONSE = func YJSONSERIALIZE.GENERATE_JSON(0, AVOID.ACHAR, AVOID.ACHAR, ALERT_WS, YOPENFUNCTION, EMPTY_FIELDS, HEADER, FILTERED_VALUES, YSELECTEDFIELDS)

    #caso in cui NON c'è query, printiamo l'oggetto complessivo su json
    Elsif(COUNT_VALUES > 0 & vireblc(QUERY, 2) = AVOID.ACHAR)

      YRESPONSE = func YJSONSERIALIZE.GENERATE_JSON(0, AVOID.ACHAR, AVOID.ACHAR, ALERT_WS, YOPENFUNCTION,EMPTY_FIELDS, HEADER, VALUES, YSELECTEDFIELDS)

    #caso in cui non ci sono dati di output
    Else
      Local Char FIELDS(0)(1,1)
      Local Char HEADER(0)(1,1)
      Local Char DATA(0)(1,1)

      YRESPONSE = func YJSONSERIALIZE.GENERATE_JSON(1, "error", "La ricerca non ha prodotto risultati!", ALERT_WS, YOPENFUNCTION,FIELDS, HEADER, DATA,YSELECTEDFIELDS)

    Endif
  Endif


  #log-SEL_CONS
  #Call YPRINT_CLB(YRESPONSE, "YRESPONSE_" + "selcons_"+YFUNC_NAME, "json") From YUTILS

  #END_SELCONS
  Gosub YAX3MOB_SET_ENV From YAX3MLOG
  Call YPRINT_DIR_CLB(YPAYLOADDIRNAME, YRESPONSE, "YRESPONSE_" + "selcons_"+YFUNC_NAME, "json") From YUTILS
Return
**********
7,"TRT","YAX3MSEL",""
2,"TRT","YAX3MUSR",""
#<AdxTL>@(#)0.0.0.0 $Revision$
$ACTION

#If GUSER='ADMIN' : Infbox(ACTION) : Endif

  Case ACTION
    When "DEBUT"         : Gosub DEBUT
    When "BOUTON"        : Gosub BOUTON
    When "FIN"           : Gosub FIN
    When Default
  Endcase

Return


##############################################################################################################

$DEBUT

  If !clalev([F:YAUS]) : Local File AUTILIS [F:YAUS] : Endif
  If !clalev([F:YAX3MU]) : Local File YAX3MUSER [F:YAX3MU] : Endif

  Call OUVRE_TRACE ("YAX3MUSR - Gestione Utenti ArgoX3 Mobile - " - num$(date$)) From LECFIC
  Gosub YLOAD_USR

Return

###############################################################################################################

$BOUTON

  Case BOUT
    When "B"
      Gosub YUPSERT_USER
    When "R"
      Gosub YLOAD_USR
    When Default
  Endcase

  Affzo [M:YAX3MU]

Return

################################################################################################################

$FIN

  Raz [M:YAX3MU]
  Call FERME_TRACE From LECFIC

Return

################################################################################################################
#                                                   BOTTONI DI FINESTRA
################################################################################################################

#**
#* BF1 : POPOLAMENTO RIQUADRO/RICERCA: Popolamento Griglia Riquadro
#* a prima apertura/ con ricerca con campi-filtro (REPNAM : Nome Completo ; ADDEMLX3 : Mail X3)
#*
#*!

$YLOAD_USR

  Local Char YMESSAGE(250)
  Local Integer YI: YI = 0
  Local Char YCRITERE(250)(2): YCRITERE(0)= "1=1" : YCRITERE(1)= " & 1=1"

  If([M:YAX3MU]YUSRFILTER <> AVOID.ACHAR)
    YCRITERE(0) -= "& (tolower([F:YAUS]NOMUSR) = tolower([M:YAX3MU]YUSRFILTER) | instr(1,tolower([F:YAUS]NOMUSR),tolower([M:YAX3MU]YUSRFILTER))>0)"
  Endif

  If([M:YAX3MU]YEMLFILTER <> AVOID.ACHAR)
    YCRITERE(1) -= "& (tolower([F:YAUS]ADDEML) = tolower([M:YAX3MU]YEMLFILTER) | instr(1,tolower([F:YAUS]ADDEML),tolower([M:YAX3MU]YEMLFILTER))>0)"
  Endif

  #Popolamento Griglia di Riquadro & Gestione Bottoni di Riga
  Link [F:YAUS] With [F:YAX3MU]YAX3MU1=[F:YAUS]USR As [LNK]
&               Where evalue(YCRITERE) & [F:YAUS]ENAFLG = 2
&               Order By [YAUS]NOMUSR
  Columns [LNK] ([YAUS]USR,[YAUS]NOMUSR,[YAUS]ADDEML,[YAX3MU]USERNAME,[YAX3MU]EMAIL,[YAX3MU]ENAFLG) #

  nolign = 0

  For [LNK]
    nolign+=1
    [M:YAX3MU]USR(nolign-1)=[F:YAUS]USR
    [M:YAX3MU]NOMUSR(nolign-1)=[F:YAUS]NOMUSR
    [M:YAX3MU]ADDEMLX3(nolign-1)=[F:YAUS]ADDEML
    [M:YAX3MU]ENAFLG(nolign-1)=[F:YAX3MU]ENAFLG
    [M:YAX3MU]AX3MUSR(nolign-1)=[F:YAX3MU]USERNAME
    [M:YAX3MU]EMLAX3M(nolign-1)=[F:YAX3MU]EMAIL
  Next

  If(nolign > 0)
    [M:YAX3MU]NBLIG = nolign
     If([M:YAX3MU]ADDEMLX3(nolign-1) <> AVOID.ACHAR)
      Raz GBOUT1
     Else
      Raz GBOUT2,GBOUT3
    Endif
  Endif

  Affzo [M:YAX3MU]

Return

#################################################Subprog########################################################


#===============================================================================================================
#                                               BOTTONI DI FINESTRA
# BF1: Popolamento Riquadro, BF2: Creazione massiva in base a chkbox, BF3: Aggiornamento massivo in base a chkbox
#===============================================================================================================

#################################################################################################################
#**
#* Sub per Creazione utente/ Aggiornamento credenziali
#*!

$YUPSERT_USER

  Local Integer YC, YI, YJ : YC = 0
  Local Char YMESSAGE(250)
  Local Integer YSUCCESS : YSUCCESS = 1
  Local Char YUSERCRED(250)

  # Ottieni righe selezionate
  Local Char YUSERDATA(50)(100, 7) #ho inserito un massimo di 100 utenti
  Local Char YPASSWORD(250)

  Raz [M:YAX3MU]YCRED

  # Ciclo per riempire dati operazione
  For YI = 0 To [M:YAX3MU]NBLIG - 1
    If ([M:YAX3MU]YSELECT(YI) = 2)
      If vireblc([M:YAX3MU]ADDEMLX3(YI), 2) = AVOID.ACHAR
        Call ERREURT("Inserire l'indirizzo email per l'utente" - [M:YAX3MU]NOMUSR(YI), 0) From GESECRAN
        Return
      Endif
      YUSERDATA(YC, 0) = [M:YAX3MU]USR(YI) #utente x3
      YUSERDATA(YC, 1) = vireblc(func YUTILS.STR_IIF([M:YAX3MU]AX3MUSR(YI) = AVOID.ACHAR, YUSERDATA(YC, 0), [M:YAX3MU]AX3MUSR(YI)), 2)  #utente ax3m
      YUSERDATA(YC, 2) = func YUTILS.YGET_PASSWORD()
      YUSERDATA(YC, 3) = [M:YAX3MU]NOMUSR(YI)
      YUSERDATA(YC, 4) = [M:YAX3MU]ADDEMLX3(YI)
      YUSERDATA(YC, 5) = [M:YAX3MU]EMLAX3M(YI)
      YUSERDATA(YC, 6) = num$([M:YAX3MU]ENAFLG(YI))
      YC += 1
    Endif
  Next

  If (YC > 5)
    Call ERREURT("Selezionare al massimo 5 utenti!", 0) From GESECRAN
  Elsif (YC > 0)
    Call YUPSERT_USER(YUSERDATA, YSUCCESS, YMESSAGE) From YAX3MUSRLIB
    If (YSUCCESS = 1)
      Call ERREURT("Utenti aggiornati con successo!", 0) From GESECRAN
      For YJ = 0 To func YUTILS.COUNT_MULTI(YUSERDATA) - 1
        YUSERCRED = "Utente:" - YUSERDATA(YJ, 1) + " - Password:" - YUSERDATA(YJ, 2)
        [M:YAX3MU]YCRED += [L]YUSERCRED + chr$(10)
        Affzo [M:YAX3MU]YCRED
      Next
    Else
      Call ERREURT(YMESSAGE, 2) From GESECRAN
    Endif
  Else
    Call ERREURT("Non sono stati selezionati utenti, impossibile proseguire!", 1) From GESECRAN
  Endif

  Raz [M:YAX3MU]YSELECT
  Gosub YLOAD_USR

Return

######################################################################################
## Etichetta aggiunta dal supervisore (videata YAX3MUSR) 20/03/2025 09:21:00 (ARG01)
######################################################################################
Subprog B1_NBLIG

  Local Char NEW_PASSWORD (30), YMESSAGE(250)
  Local Integer YLENGTH
  Local Integer YSTAT, YSUCCESS : YSUCCESS = 1

  If [M:YAX3MU]ENAFLG(nolign - 1) <> 2
    Call ERREURT("L'utente non è attivo su ArgoX3 Mobile, procedere prima alla creazione!", 1) From GESECRAN
  Else
    Call SAICAR(NEW_PASSWORD, "Reset password", "Inserire la nuova password:", "YAX3MU", 1, YLENGTH, "", YSTAT) From GESECRAN
    If YSTAT = 2 # se premo ok
      If func YUTILS.YCHECK_PASSWORD(NEW_PASSWORD) <> 1
        Call ERREURT("La password deve essere lunga almeno 8 caratteri e contenere almeno una lettera maiuscola, una lettera minuscola, un numero e un carattere speciale (es. !@#$%^&*)!", 1) From
& GESECRAN
        Call B1_NBLIG()
      Else
        #aggiorna l'utente
        Call YRESET_USERPWD([M:YAX3MU]AX3MUSR(nolign-1), NEW_PASSWORD, YSUCCESS, YMESSAGE) From YAX3MUSRLIB
        If YSUCCESS = 1
          Call ERREURT("Reset password avvenuto con successo!", 0) From GESECRAN
        Else
          Call ERREURT(YMESSAGE, 1) From GESECRAN
        Endif
      Endif
    Endif
  Endif

End


######################################################################################
**********
7,"TRT","YAX3MUSR",""
2,"TRT","YAX3MUSRLIB",""
#<AdxTL>@(#)0.0.0.0 $Revision$
##Libreria backend utenti X3 per Argo X3 mobile####
###################################################
Subprog YUPSERT_USER(YUSERDATA, YSUCCESS, YMESSAGE)

  Variable Char YUSERDATA()(,)
  Variable Integer YSUCCESS
  Variable Char YMESSAGE

  Local File YAX3MUSER [F:YAX3MU]
  Local Integer YI
  Local Char YPASSWORD(50)
  Local Char YKEYVALUES(250)(2,3)
  Local Char YCREDENTIALS(250)(2)
  Local Char PCOD(100)(1), PVAL(100)(1)
  Local Char YRESPONSE_ARR(250)(func YJSONDESERIALIZE.F_MAXELEMENT(), func YJSONDESERIALIZE.F_DEEPLEVEL() + 1)
  Local Clbfile YRESPONSE_JSON(1), YBODY(1)
  Local Integer EXIST_USER : EXIST_USER = 0
  Local Char YDOSSIER(6): YDOSSIER = toupper(nomap(0))

  Call OUVRE_TRACE ("YAX3MUSR - Creazione/Aggiornamento Utente ArgoX3 Mobile -" - num$(date$)) From LECFIC

  Trbegin [F:YAX3MU]
  For YI = 0 To func YUTILS.COUNT_MULTI(YUSERDATA) - 1

    Readlock [F:YAX3MU]YAX3MU0 = YUSERDATA(YI, 1)
    EXIST_USER = func YUTILS.IIF(fstat = 0, 1, 0)
    # Insert record into table
    [F:YAX3MU]X3USERNAME   = YUSERDATA(YI, 0)
    [F:YAX3MU]USERNAME     = YUSERDATA(YI, 1)
    [F:YAX3MU]NOMUSR       = YUSERDATA(YI, 3)
    #[F:YAX3MU]EMAIL        = ""#func YUTILS.STR_IIF(EXIST_USER = 1, YUSERDATA(YI, 5), YUSERDATA(YI, 4))
    If EXIST_USER = 1 #esiste l'utente
      [F:YAX3MU]EMAIL = YUSERDATA(YI, 5)
    Else #non esiste l'utente
      # SE L'UTENTE IMPUTA L'EMAIL A MANO SALVO QUEL VALORE
      If vireblc(YUSERDATA(YI, 5), 2) <> AVOID.ACHAR
        [F:YAX3MU]EMAIL = YUSERDATA(YI, 5)
      Else
        #SE L'UTENTE LASCIA VUOTO IL CAMPO EMAIL COPIO IN AUTOMATICO IL VALORE EMAIL
        [F:YAX3MU]EMAIL = YUSERDATA(YI, 4)
      Endif
    Endif

    [F:YAX3MU]ENAFLG       = val(YUSERDATA(YI, 6))
    [F:YAX3MU]ISDEMO       = 1

    YBODY+=func YJSONSERIALIZE.GET_STR("username", YUSERDATA(YI, 1), 0)
    YBODY+=func YJSONSERIALIZE.GET_STR("password", YUSERDATA(YI, 2), 1)
    YBODY=func YJSONSERIALIZE.GET_JSON(YBODY)

    Call EXEC_NOTRACE("AX3M_API_" + YDOSSIER, "POST", "api", "/Auth/GetCredentials/", PCOD, PVAL, YBODY, YRESPONSE_JSON) From YRESTWS

    Call JSONPARSE(YRESPONSE_JSON, YRESPONSE_ARR) From YJSONDESERIALIZE

    If YRESPONSE_ARR(0, 1) = "true"
      [F:YAX3MU]PASSWORDHASH = YRESPONSE_ARR(2, 1)
      [F:YAX3MU]PASSWORDSALT = YRESPONSE_ARR(3, 1)
    Else
      fstat = 1
      Break
    Endif

    #non esiste l'utente
    If EXIST_USER <> 1 & YSUCCESS = 1
      Write [F:YAX3MU]
    Else
      Rewrite [F:YAX3MU]
    Endif
    If fstat
      Break
    Endif

    Raz YBODY, [F:YAX3MU]

  Next

  If fstat = 0
    Commit
    If fstat = 0
      YSUCCESS = 1
    Else
      Rollback
      YSUCCESS = 0
      YMESSAGE = "Errore interno!"
    Endif
  Else
    Rollback
    YSUCCESS = 0
    YMESSAGE = "Errore interno!"
  Endif

End

########################################################################################################

#**
#* Reset User Password (Single User)
#* @param YUSERDATA Single user data matrix
#* @param YMESSAGE Status message
#* @param YSUCCESS Success flag
#* @param YRESPONSEDATA Response data
#**
#* Update User Operation (Single or Bulk)
#* Phases:
#* 1) Start transaction
#* 2) Loop through user data
#* 3) Update records
#* 4) Commit or Rollback transaction
#* @param YUSERDATA Data matrix for users
#* @param YMESSAGE Status message
#* @param YSUCCESS Success flag
#* @param YRESPONSEDATA Response data
#*!

Subprog YRESET_USERPWD(YUSERNAME, YPASSWORD, YSUCCESS, YMESSAGE)
  Variable Char YUSERNAME
  Variable Char YPASSWORD
  Variable Integer YSUCCESS
  Variable Char YMESSAGE

  Local Integer EXIST_USER
  Local Char PCOD(100)(1), PVAL(100)(1)
  Local Char YRESPONSE_ARR(250)(func YJSONDESERIALIZE.F_MAXELEMENT(), func YJSONDESERIALIZE.F_DEEPLEVEL() + 1)
  Local Clbfile YRESPONSE_JSON(1), YBODY(1)
  Local Char YDOSSIER(6): YDOSSIER = toupper(nomap(0))

  Local File YAX3MUSER [F:YAX3MU]

  Readlock [F:YAX3MU]YAX3MU0 = YUSERNAME
  EXIST_USER = func YUTILS.IIF(fstat = 0, 1, 0)

  If EXIST_USER = 1

    YBODY+=func YJSONSERIALIZE.GET_STR("username", YUSERNAME, 0)
    YBODY+=func YJSONSERIALIZE.GET_STR("password", YPASSWORD, 1)
    YBODY=func YJSONSERIALIZE.GET_JSON(YBODY)

    Call EXEC("AX3M_API_" + YDOSSIER, "POST", "api", "/Auth/GetCredentials/", PCOD, PVAL, YBODY, YRESPONSE_JSON) From YRESTWS
    Call JSONPARSE(YRESPONSE_JSON, YRESPONSE_ARR) From YJSONDESERIALIZE
    #success = true
    If YRESPONSE_ARR(0, 1) = "true"
      [F:YAX3MU]PASSWORDHASH = YRESPONSE_ARR(2, 1)
      [F:YAX3MU]PASSWORDSALT = YRESPONSE_ARR(3, 1)
    Else
      fstat = 1
      YSUCCESS = 0
      YMESSAGE = "Errore interno!"
    Endif
    Trbegin [F:YAX3MU]
    #non esiste l'utente
    If EXIST_USER <> 1 & YSUCCESS = 1
      Write [F:YAX3MU]
    Else
      Rewrite [F:YAX3MU]
    Endif
    If fstat
      YSUCCESS = 0
      YMESSAGE = "Errore interno!"
    Endif

    If fstat = 0
      Commit
    Else
      Rollback
      YSUCCESS = 0
      YMESSAGE = "Errore interno!"
    Endif

  Else
    YSUCCESS = 0
    YMESSAGE = "L'utente non è attivo su ArgoX3 Mobile, procedere prima alla creazione!"
  Endif

End
**********
7,"TRT","YAX3MUSRLIB",""
2,"TRT","YAX3MUTILS",""
#<AdxTL>@(#)0.0.0.0 $Revision$
###############################################################################################
#
#LIBRERIA PER NUOVA GESTIONE MOBILE - Nuovo protocollo per AX3M
#
################################################################################################

#**
#* Inizializzazione variabili (X3/AX3M), matrici (lato AX3M) per ogni azione campo:
#* [X3]: iniz. YFIELDS(,)(solo param formale),
#* [AX3M]: iniz YALERT_WS(,);YHEADER(,); YDATA(,) ; YALERT_TYPE; YALERT_MESSAGE;
#* YMAXFLDCOUNT (max numero di fields per funzione);YFIELDS(,)& loro riempimento
#*!

$YAX3MOB_INIT_ACTIONFIELD

  Local Integer CURRENTROW : CURRENTROW = -1
  Local Char YMESSAGE(250)
  Local Char YALERT_MESSAGE(250): YALERT_MESSAGE = AVOID.ACHAR
  Local Char YALERT_TYPE(20): YALERT_TYPE = AVOID.ACHAR
  Local Char YFUNC_TYPE(10)

  # variabili utilizzate in modalità consultazione
  Local Char YMSKALIAS(10)
  Local Integer COUNT_VALUES: COUNT_VALUES = 0 #N°dati recordSet estrapolato
  Local Integer NUM_COLS #grid
  Local Char CRITERE(250)(10)
  Local Char PARAMS(250)(5)
  Local Char QUERY(250)

  #CurrentUser
  Local Char YCURRENTUSER(20)

  If(![V]GWEBSERV) #X3
    Local Char YFIELDS(1)(1,1)    #solo placeholder lato X3
    #mi serve da settare per le azioni di campi di testata in videata che hanno un riquadrO, se non setto nolign = 1 X3 crasha
    #perchè i W chiamano i params di riquadro CON nolign-1, es. Call C_GIACYCOD([M:YCGC1]FCY,VALEUR,[M:YCGC1]LOC,[M:YCGC1]ITMREF(nolign-1)...
    YCURRENTUSER = GUSER
    CURRENTROW = nolign - 1
  Else  #AX3M

    Local Char YALERT_WS(50)(1..3,1..3)
    Local Char YHEADER(0)(1,1)
    Local Char YDATA(0)(1,1)
    Local Char YSELECTEDFIELDS(0)(1) #Array per Selez Multi Campo,solo inizializzato
    Const Integer YMAXFLDCOUNT: YMAXFLDCOUNT = 1900 #2000#5850#700 #1900 #700

    #Modalità MODIFICA
    Local Integer YMODIF : YMODIF = 0 #FALSE
    Local Integer YMODIF_RIQUADRO_COUNT

    #Apertura altra FUNZIONE
    Local Char YOPENFUNCTION(250)(4)

    #Gestione CAMPI
    Local Char YFIELDS(250)(YMAXFLDCOUNT,10)        #aggiunta nuova Col(qui indicato se campo di T o D) #Local Char YFIELDS(250)(YFIELDCOUNT,8)
    Local Char YSCREENFIELDS(250)(YMAXFLDCOUNT,3)  #(idx=0: cod campo, idx=1:cod msk di appartenenza, idx= valore(char))

    #Deserializzazione YAX3MRESP
    Call YJSON2ARRAY(YAX3MRESP, YCURRENTUSER, YFIELDS) From YJSONDESERIALIZE

    #Popolamento da anagrafica: Matrice in INIT
    Call YINIT_SCREENFLDS(YFIELDS, YWINNAME)

    #Riga corrente nel caso di esistenza di un riquadro
    CURRENTROW = func YAX3MUTILS.FIND_CURRENTROW(YFIELDS)
  Endif

  #LOG
  Gosub YAX3MOB_INIT From YAX3MLOG

Return

#########################################################################################################
#**
#* Sub per Inizializzazione per Azioni Bottoni di Finestra
#*!

$YAX3MOB_INIT_BUTTONACTION

  Local Clbfile YCSVTEXT(2)
  Local Char YMEX_DOCTYPE(50), YFUNC_TYPE(10)
  Local Char YDESCR(20) : YDESCR = YMEX_DOCTYPE - "AX3M"
  Local Char YIMP_CODE(10)
  Local Integer YISBOUT: YISBOUT =0  #deprecato?

  Gosub YAX3MOB_INIT_ACTIONFIELD
Return

########################################################################################################
#**
#* Metodo per inizializzazione matrice YFIELDS  da anagrafica
#*
#* @param YFIELDS
#* @param YWINNAME
#*!

Subprog YINIT_SCREENFLDS(YFIELDS,YWINNAME)

  Variable Char YFIELDS()(,)
  Value Char YWINNAME

  Local File AWINDOW [YAWI]
  Local File AMSK [YAMK]
  Local File AMSKZON [YAMZ]
  Local File ATYPE [YATY]

  Local Integer YF,YI,YJ,INDEX,YDETTBLKCOUNT #num blocchi di tipo RIQ in una data maschera
  Local Char YMSKNAME(15),YPARBLKNAME(15)
  Local Integer YDETTBLKIDX:YDETTBLKIDX=-1

#-------------
  Local Integer YFHFLDIDX: YFHFLDIDX =-1 #qui registro idx 1°campo di testata
  Local Char YFHFLDCODE(10)   #qui registro code 1°campo di testata

  #--yfields-params-----------------------------#
  Const Integer YCOL_NAME : YCOL_NAME = 0
  Const Integer YCOL_TYPE : YCOL_TYPE = 1
  Const Integer YCOL_VALUE : YCOL_VALUE = 2
  Const Integer YCOL_VALID : YCOL_VALID = 3
  Const Integer YCOL_MEX : YCOL_MEX = 4
  Const Integer YCOL_FOCUS : YCOL_FOCUS = 5
  Const Integer YCOL_VIS : YCOL_VIS = 6
  Const Integer YCOL_ENA : YCOL_ENA = 7
  Const Integer YCOL_DETT : YCOL_DETT = 8   #colonna che accoglie "0" o "1" (se campo di dett)
  Const Integer YCOL_ROW : YCOL_ROW = 9     #colonna che accoglie "0" o "1" (se riga corrente)
  #---------------------------------------------#

  Read [F:YAWI]AWI0=YWINNAME
  Columns [F:YAWI](NOMMSK,NBMSK,MSKENT)    #NOMMSK: array con codici masks della finestra

  If(fstat=0)

    #VID TESTATA
    If([F:YAWI]MSKENT<>AVOID.ACHAR)
       YMSKNAME = [F:YAWI]MSKENT

       #estraggo blocchi della videata
       Read [F:YAMK]CODMSK=YMSKNAME
       Columns [F:YAMK](TYPBLOC,NBBLOC,NBLIGT,BASPAG)
       If(fstat=0)
         Gosub GET_MSKNBLIG_LIST  #lista nblig di mskent
         Gosub GET_MSKFLDS        # popolata yfields , INDEX ++
       Endif
    Endif

    #SCHEDE
    For YI=0 To [F:YAWI]NBMSK -1  #ciclo su N° mask
      YDETTBLKIDX =-1 #reset a -1, per ricerca eventuale nuovo indice Blocco Riquadro
      YMSKNAME = [F:YAWI]NOMMSK(YI)
      #estraggo blocchi
      Read [F:YAMK]CODMSK=YMSKNAME
      Columns [F:YAMK](TYPBLOC,NBBLOC,NBLIGT,BASPAG)

      If(fstat=0)
       Gosub GET_MSKNBLIG_LIST
       Gosub GET_MSKFLDS
      Endif
    Next
  Endif
End

##########################################################################################
#**
#* Sub per ricerca (nei blocchi) Parametri di Fondo Riquadro di una Videata
#*!

$GET_MSKNBLIG_LIST

   #Local Char YBLKPARAMS(10)(1..[F:YAMK]NBBLOC)
   Local Char YBLKPARAMS(10)([F:YAMK]NBBLOC)

   #ciclo sui blocchi per trovare l'eventuale campo di tipo parametro
   For YJ=0 To [F:YAMK]NBBLOC-1
     If([F:YAMK]TYPBLOC(YJ)=1)  #cerco blc di tipo Riquadro

        YDETTBLKIDX = YJ
        YBLKPARAMS(YJ) = [F:YAMK]BASPAG(YJ) # ci metto il param = campo fondo  riquadro(eg NBLIG)
        Break
     Endif
   Next

Return

################################################################################################
#**
#* Estraggo i campi dei blocchi (Lista/Riquadro) di una maschera (ad esclusione degli NBLIG)
#*!

$GET_MSKFLDS

 Local Integer YFLDOCCNUM   #N°occorrenze di un campo nella matrice YFIELDS
 Local Integer YFLDOCC(2000)  #Array delle occorrenze #50

 # Local Integer YFLDOCC(dim(YFIELDS,1))

 #FILTRO su cod Msk e su campi con cod <> param blocco
 Filter [F:YAMZ] Where ([F:YAMZ]CODMSK = YMSKNAME & find([F:YAMZ]CODZON, YBLKPARAMS) = 0) Order By [F:YAMZ]NUMLIG
 Columns [F:YAMZ](CODMSK,CODZON,CODTYP,SAIAFF,NUMBLOC)

 #ciclo sui campi della Videata in esame
 For [F:YAMZ]
  Local Integer YK
  Call YINIT_INTARR(YFLDOCC,-1) From YUTILS
  #popolo matrice occorrenze con indici del cod campo [F:YAMZ]CODZON
  Call YFIND_OCCS(YFIELDS, [F:YAMZ]CODZON, YFLDOCC) From YUTILS

  #ciclo su indici occorrenze del cod campo(= [F:YAMZ]CODZON) e setto il FldItem
  For YK = 0 To dim(YFLDOCC, 1) -1
    If(YFLDOCC(YK) = -1)
      Break
    Else
      Call YSETFIELDITEM(YFIELDS,YFLDOCC(YK),[F:YAMZ]CODZON,[F:YAMZ]CODTYP,[F:YAMZ]SAIAFF,[F:YAMZ]NUMBLOC,YDETTBLKIDX)
    Endif
  Next
 Next
 Filter [F:YAMZ]

Return

####################################################################################################################
#**
#* Sub per parametri del FldItem (Oggetto-Campo):
#* 0)Cod Campo; 1)Tipo dato campo; 2)Valore Campo; 3)Validità Campo; 4)Messaggio associato a Campo;
#* 5)Focus campo; 6)Visibilità Campo; 7)Dis/abilitazione Campo; 8)Campo Dettaglio/Testata; 9)Riga Corrente
#*!

$YSET_FLDPARAMS

  #--yfields-params---------------------------------------------------#
  Const Integer YCOL_NAME : YCOL_NAME = 0
  Const Integer YCOL_TYPE : YCOL_TYPE = 1
  Const Integer YCOL_VALUE : YCOL_VALUE = 2
  Const Integer YCOL_VALID : YCOL_VALID = 3
  Const Integer YCOL_MEX : YCOL_MEX = 4
  Const Integer YCOL_FOCUS : YCOL_FOCUS = 5
  Const Integer YCOL_VIS : YCOL_VIS = 6
  Const Integer YCOL_ENA : YCOL_ENA = 7
  Const Integer YCOL_DETT : YCOL_DETT = 8   #colonna che accoglie "0" o "1" (se campo di dett)
  Const Integer YCOL_ROW : YCOL_ROW = 9     #colonna che accoglie "0" o "1" (se riga corrente)

Return

####################################################################################################################
#**
#* Subprog per setting Oggetto-Campo nella matrice YFIELDS
#*
#* @param YFIELDS Matrice dei campi
#* @param YFLDIDX Indice del campo nella matrice YFIELDS
#* @param YCODZON Codice Campo
#* @param YCODTYP Codice Tipo-dato del Campo
#* @param YSAIAFF Codice per gardo visibilità/editabilità
#* @param YNUMBLOC Numero del Blocco di appartenenza
#* @param YDETTBLKIDX Indice dell'eventuale blocco di Riquadro presente
#*!

Subprog YSETFIELDITEM(YFIELDS,YFLDIDX,YCODZON,YCODTYP,YSAIAFF,YNUMBLOC,YDETTBLKIDX)

  Variable Char YFIELDS()(,)
  Value Char YCODZON
  Value Char YCODTYP
  Value Integer YSAIAFF
  Value Integer YNUMBLOC
  Value Integer YFLDIDX
  Value Integer YDETTBLKIDX

  Local File ATYPE [YATY]
  Gosub YSET_FLDPARAMS

  ## Cod- name
  If(YFIELDS(YFLDIDX,YCOL_NAME)= AVOID.ACHAR)
    YFIELDS(YFLDIDX,YCOL_NAME) = YCODZON
  Endif

  ## Valid
  If(YFIELDS(YFLDIDX, YCOL_VALID)= AVOID.ACHAR)
    YFIELDS(YFLDIDX, YCOL_VALID) = "1"  #tutti i campi validi all'inizio
  Endif

  ## Tipo Campo
  Read [F:YATY]CODTYP = YCODTYP

  #TYPTYP menu locale 30
  If find([F:YATY]TYPTYP,1,2,3) <> 0
    YFIELDS(YFLDIDX, YCOL_TYPE) = "integer"
  Elsif find([F:YATY]TYPTYP,4,5,6)
    YFIELDS(YFLDIDX, YCOL_TYPE) = "decimal"
  Elsif find([F:YATY]TYPTYP,7,10)
    YFIELDS(YFLDIDX, YCOL_TYPE) = "char"
  Elsif [F:YATY]TYPTYP = 8
    YFIELDS(YFLDIDX, YCOL_TYPE) = "date"
  Endif

  ##Visibilità
  If (YSAIAFF <> 3 & YFIELDS(YFLDIDX, YCOL_VIS) = AVOID.ACHAR)#NASCOSTO
    YFIELDS(YFLDIDX, YCOL_VIS) =  "1"
  Else
    If YFIELDS(YFLDIDX, YCOL_VIS) = AVOID.ACHAR
      YFIELDS(YFLDIDX, YCOL_VIS) = "0"
    Endif
  Endif

  #Editabilità
  If(YSAIAFF = 1 & YFIELDS(YFLDIDX, YCOL_ENA) = AVOID.ACHAR) #INSERITO
    YFIELDS(YFLDIDX, YCOL_ENA) = "1"
  Else
    If YFIELDS(YFLDIDX, YCOL_ENA) = AVOID.ACHAR
      YFIELDS(YFLDIDX, YCOL_ENA) = "0"
    Endif
  Endif

  ##Tipo Campo Test/Dett
  If(YDETTBLKIDX=-1)
    YFIELDS(YFLDIDX, YCOL_DETT)="0"
  Else
    YFIELDS(YFLDIDX, YCOL_DETT) = func YUTILS.STR_IIF(YNUMBLOC = YDETTBLKIDX+1, "1", "0")
  Endif

  ## Current ROW : correttivo nel caso di json con prima il dettaglio
  If(YFIELDS(YFLDIDX, YCOL_DETT) = "0") #campi di testata non sono mai sulla riga corrente
    YFIELDS(YFLDIDX, YCOL_ROW)="0"
  Endif
End

#########################################################################################################
#**
#* Funzione che restituisce il numero di campi di una Finestra - (vengono contati i parametri di ogni az.campo, in ugual n° ai campi di finestra, escludendo NBLIG,YAX3MRESP,YRESPONSE)
#*
#* @param YACTION Codice dell'azione (legata ad az. campo)
#*!

Funprog YCOUNT_WINFIELDS(YACTION)
  Value Char YACTION

  Local File ACTPAR [F:YATR] Where [F:YATR]ACTION = YACTION

#IL -2 E' DOVUTO AL FATTO CHE NEL CONTEGGIO COMPLESSIVO DEI CAMPI DELLA FUNZIONE, SI ESCLUDONO YRESPONSE E YAX3MRESPONSE
End rowcount ([F:YATR]) - 2


##########################################################################################################
#**
#* Gestione FOCUS AX3M per campo corrente azione campo
#*
#* @param YFIELDS  Matrice dei campi
#* @param YFIELDCODE Codice campo corrente
#* @param YMKSTAT Valore mkstat/intero per gestione di errore
#*!

Subprog YAX3MOB_FOCUS(YFIELDS,YFIELDCODE,YMKSTAT)

  Variable Char YFIELDS()(,)
  Value Char YFIELDCODE
  Value Integer YMKSTAT

  Local Integer YI, Y1EN  # Y1EN: indice primo campo abilitato (=editabile)
  Const Integer YCOL_FOCUS : YCOL_FOCUS = 5  #focus

  YI = func YUTILS.FIND_ITEM(YFIELDS,YFIELDCODE)   #indice del campo corrente nella matrice YFIELDS
  Y1EN = func YFIND_FIRST_EN(YFIELDS,YI)           #calcolo indice 1° campo editabile (>=1)

  If(Y1EN >0)
     Case YMKSTAT
        When 0,1 #ok (=0),warning (=1)
          YFIELDS(YI,YCOL_FOCUS)= "0" #"1"      #focus non più sul campo corrente
          YFIELDS(Y1EN,YCOL_FOCUS)= "1" # "0"   #focus spostato su primo campo editabile

        When 2  #errore (=2)
          YFIELDS(YI,YCOL_FOCUS)= "1" # "0" #focus su campo corrente
        When Default
     Endcase
  Endif
End

#############################################################################################################
#**
#* Gestione FOCUS AX3M per campo corrente (di RIQUADRO)azione campo
#*
#* @param YFIELDS  Matrice dei campi
#* @param YFIELDCODE Codice campo corrente
#* @param YMKSTAT Valore mkstat/intero per gestione di errore
#* @param YPOS Posizione (=0 : riga1, =1 :riga2)
#*!

Subprog YAX3MOB_FOCUS_RIQUADRO(YFIELDS,YFIELDCODE,YMKSTAT,YPOS)

  Variable Char YFIELDS()(,)
  Value Char YFIELDCODE
  Value Integer YMKSTAT
  Value Integer YPOS

  Local Integer YI, Y1EN  # Y1EN: indice primo campo abilitato (=editabile)
  Const Integer YCOL_FOCUS : YCOL_FOCUS = 5  #focus

  YI = func YUTILS.FIND_MULTITEM(YFIELDS,YFIELDCODE,YPOS)   #indice del campo corrente nella matrice YFIELDS
  Y1EN = func YAX3MUTILS.YFIND_FIRST_EN(YFIELDS,YI)           #calcolo indice 1° campo editabile (>=1)

  If(Y1EN >0)
     Case YMKSTAT
        When 0,1 #ok (=0),warning (=1)
          YFIELDS(YI,YCOL_FOCUS)= "0" #"1"      #focus non più sul campo corrente
          YFIELDS(Y1EN,YCOL_FOCUS)= "1" # "0"   #focus spostato su primo campo editabile
        When 2  #errore (=2)
          YFIELDS(YI,YCOL_FOCUS)= "1" # "0" #focus su campo corrente
        When Default
     Endcase
  Endif
End

#############################################################################################################
#**
#* Ricerca Indice del primo campo visualizzato paretndo da quello corrente
#*
#* @param YFIELDS  Matrice dei campi
#* @param YCURRINDEX Indice campo corrente nella YFIELDS
#*!

Funprog YFIND_FIRST_EN(YFIELDS,YCURRINDEX)

  Variable Char YFIELDS()(,)
  Value Integer YCURRINDEX
  Local Integer YI,YINDEX
  YINDEX= -1

  Const Integer YCOL_ENA : YCOL_ENA = 7
  #Const Integer YCOL_VALID : YCOL_VALID = 3

  For YI = YCURRINDEX+1 To dim(YFIELDS,1)-1
    If(YFIELDS(YI,YCOL_ENA)="1")
      YINDEX = YI
      Break
    Endif
  Next

End YINDEX

#############################################################################################################
#**
#* Gestione ACTZO per X3/AX3M per un campo di maschera
#*
#* @param YFIELDS  Matrice dei campi
#* @param YMSKALIAS Codice videata corrente, in esame
#* @param YFIELDCODE Codice campo da abilitare
#*!

Subprog YAX3MOB_ACTZO(YFIELDS,YMSKALIAS,YFIELDCODE)

  Variable Char YFIELDS()(,)
  Value Char YMSKALIAS
  Value Char YFIELDCODE
  Local Integer YI
  Const Integer YCOL_ENA : YCOL_ENA = 7

  If(![V]GWEBSERV) #X3
    Actzo = "[M:"+YMSKALIAS+"]"+YFIELDCODE
  Else #AX3M
    YI = func YUTILS.FIND_ITEM(YFIELDS,YFIELDCODE)
    YFIELDS(YI,YCOL_ENA)= "1"  #"0"
  Endif
End

#############################################################################################################
#**
#* Gestione ACTZO per X3/AX3M per un campo di RIQUADRO
#*
#* @param YFIELDS  Matrice dei campi
#* @param YMSKALIAS Codice videata corrente, in esame
#* @param YFIELDCODE Codice campo da abilitare
#* @param CURRENTROW riga del riquadro
#*!

Subprog YAX3MOB_ACTZO_RIQUADRO(YFIELDS,YMSKALIAS,YFIELDCODE,CURRENTROW)

  Variable Char YFIELDS()(,)
  Value Char YMSKALIAS
  Value Char YFIELDCODE
  Value Integer CURRENTROW

  Local Integer YI
  Const Integer YCOL_ENA : YCOL_ENA = 7

  If(![V]GWEBSERV) #X3
    Actzo = "[M:"+YMSKALIAS+"]"+YFIELDCODE + "(" + num$(CURRENTROW) + ")"
  Else #AX3M
    If(CURRENTROW=-1)
      YI = func YUTILS.FIND_MULTITEM(YFIELDS,YFIELDCODE,0)
    Else
      YI = func YUTILS.FIND_MULTITEM(YFIELDS,YFIELDCODE,CURRENTROW)
    Endif
    If(YI>0)
      YFIELDS(YI,YCOL_ENA)= "1"
    Endif
  Endif
End

##############################################################################################################
#**
#* Gestione DISZO per X3/AX3M per un campo di maschera
#*
#* @param YFIELDS  Matrice dei campi
#* @param YMSKALIAS Codice videata corrente, in esame
#* @param YFIELDCODE Codice campo da abilitare
#*!

Subprog YAX3MOB_DISZO(YFIELDS,YMSKALIAS,YFIELDCODE)

  Variable Char YFIELDS()(,)
  Value Char YMSKALIAS
  Value Char YFIELDCODE

  Local Integer YI
  Const Integer YCOL_ENA : YCOL_ENA = 7

  If(![V]GWEBSERV) #X3
    Diszo = "[M:"+YMSKALIAS+"]"+YFIELDCODE
  Else #AX3M
    YI = func YUTILS.FIND_ITEM(YFIELDS,YFIELDCODE)
    YFIELDS(YI,YCOL_ENA)= "0"
  Endif
End

##############################################################################################################
#**
#* Gestione DISZO per X3/AX3M per un campo di maschera di RIQUADRO
#*
#* @param YFIELDS  Matrice dei campi
#* @param YMSKALIAS Codice videata corrente/in esame
#* @param YFIELDCODE Codice campo da abilitare
#* @param CURRENTROW Riga corrente
#*!

Subprog YAX3MOB_DISZO_RIQUADRO(YFIELDS,YMSKALIAS,YFIELDCODE,CURRENTROW)

  Variable Char YFIELDS()(,)
  Value Char YMSKALIAS
  Value Char YFIELDCODE
  Value Integer CURRENTROW

  Local Integer YI
  Const Integer YCOL_ENA : YCOL_ENA = 7

  If(![V]GWEBSERV) #X3
    Diszo = "[M:"+YMSKALIAS+"]"+YFIELDCODE + "(" + num$(CURRENTROW) + ")"
  Else #AX3M
    If(CURRENTROW=-1)
      YI = func YUTILS.FIND_MULTITEM(YFIELDS,YFIELDCODE,0)
    Else
      YI = func YUTILS.FIND_MULTITEM(YFIELDS,YFIELDCODE,CURRENTROW)
    Endif
    YFIELDS(YI,YCOL_ENA)= "0" #"1"
  Endif
End

###############################################################################################################
#**
#* Gestione Visibilità/Invisibilità Campo di maschera
#*
#* @param YFIELDS Matrice dei campi
#* @param YMSKNAME nOME videata corrente, in esame
#* @param YFIELD Codice campo da mostrare/nascondere
#* @param YVISIBLE flag per visibile/nascosto ( =1: visibile; =0: nascosto)
#*!

Subprog YAX3MOB_SETVISIBLE(YFIELDS,YMSKNAME,YMSKALIAS,YFIELDCODE,YVISIBLE)

  Variable Char YFIELDS()(,)
  Value Char YMSKNAME
  Value Char YMSKALIAS
  Value Char YFIELDCODE
  Value Integer YVISIBLE

  Local File AMSKZON [F:YAMZ]
  Local File ATYPE [F:YATY]

  Const Integer YCOL_TYPE : YCOL_TYPE = 1
  Const Integer YCOL_VIS : YCOL_VIS = 6

  Local Integer YI:YI = func YUTILS.FIND_ITEM(YFIELDS,YFIELDCODE)  #trovo riga
  Local Char YTYPE(10): YTYPE = YFIELDS(YI,YCOL_TYPE)              #trovo tipo
  Local Char YFIELDLEN(5)

  If(![V]GWEBSERV)
    Read [F:YAMZ]CODE = YMSKNAME;YFIELDCODE
    Columns [F:YAMZ](CODMSK,CODZON,CODTYP)

    Case YTYPE
      When "char"
         Default Mask "[M:"+YMSKALIAS+"]"
      When "integer","decimal"
      When "date"
        #https://communityhub.sage.com/us/sage_x3/f/general-discussion/105244/dynamically-hiding-showing-screen-fields
        Affzo = "[M:"+YMSKALIAS+"]"

      When Default
    Endcase
  Else
    YFIELDS(YI,YCOL_VIS)= num$(YVISIBLE)
  Endif
End
#TODO: DA FINIRE & TESTARE!

###############################################################################################################
#**
#* Gestione RAZ per X3/AX3M per un campo di maschera
#*
#* @param YFIELDS  matrice dei campi
#* @param YMSKALIAS codice videata corrente, in esame
#* @param YFIELDCODE codice campo da abilitare
#*!

Subprog YAX3MOB_RAZ(YFIELDS,YMSKALIAS,YMSKNAME,YFIELDCODE)

  Variable Char YFIELDS()(,)
  Value Char YMSKALIAS
  Value Char YMSKNAME
  Value Char YFIELDCODE

  Local File AMSKZON [YAMZ]
  Local File ATYPE [YATY]

  Const Integer YCOL_TYPE : YCOL_TYPE = 1
  Const Integer YCOL_VALUE : YCOL_VALUE = 2
  Local Char YTYPE(10)

  If(![V]GWEBSERV) #X3

    Filter [F:YAMZ] Where ([F:YAMZ]CODMSK = YMSKNAME & [F:YAMZ]CODZON = YFIELDCODE)
    #Tipo
    Read [F:YATY]CODTYP = [F:YAMZ]CODTYP
    #TYPTYP menu locale 30
    If find([F:YATY]TYPTYP,1,2,3) <> 0
      YTYPE = "integer"
    Elsif find([F:YATY]TYPTYP,4,5,6)
      YTYPE = "decimal"
    Elsif find([F:YATY]TYPTYP,7,10)
      YTYPE = "char"
    Elsif [F:YATY]TYPTYP = 8
      YTYPE = "date"
    Endif

    Default Mask "[M:"+YMSKALIAS+"]"
    Case YTYPE
      When "integer","decimal"
        Assign "[M]"+YFIELDCODE With 0
      When "char"
        Assign "[M]"+YFIELDCODE With AVOID.ACHAR
      When "date"
        Assign "[M]"+YFIELDCODE With AVOID.ADATE
      When Default
    Endcase
  Else #AX3M
    Local Integer YI:YI = func YUTILS.FIND_ITEM(YFIELDS,YFIELDCODE)  #trovo riga
    YTYPE = YFIELDS(YI,YCOL_TYPE)              #trovo tipo
    YFIELDS(YI,YCOL_VALUE)= AVOID.ACHAR
  Endif
End

###############################################################################################################
#**
#* Gestione RAZ per X3/AX3M per un campo di maschera
#*
#* @param YFIELDS  matrice dei campi
#* @param YMSKALIAS codice videata corrente, in esame
#* @param YFIELDCODE codice campo da abilitare
#*!

Subprog YAX3MOB_RAZ_RIQUADRO(YFIELDS,YMSKALIAS,YMSKNAME,YFIELDCODE,CURRENTROW)

  Variable Char YFIELDS()(,)
  Value Char YMSKALIAS
  Value Char YMSKNAME
  Value Char YFIELDCODE
  Value Integer CURRENTROW

  Local File AMSKZON [YAMZ]
  Local File ATYPE [YATY]

  Const Integer YCOL_TYPE : YCOL_TYPE = 1
  Const Integer YCOL_VALUE : YCOL_VALUE = 2
  Local Char YTYPE(10)

  If(![V]GWEBSERV) #X3

    Filter [F:YAMZ] Where ([F:YAMZ]CODMSK = YMSKNAME & [F:YAMZ]CODZON = YFIELDCODE)
    #Tipo
    Read [F:YATY]CODTYP = [F:YAMZ]CODTYP
    #TYPTYP menu locale 30
    If find([F:YATY]TYPTYP,1,2,3) <> 0
      YTYPE = "integer"
    Elsif find([F:YATY]TYPTYP,4,5,6)
      YTYPE = "decimal"
    Elsif find([F:YATY]TYPTYP,7,10)
      YTYPE = "char"
    Elsif [F:YATY]TYPTYP = 8
      YTYPE = "date"
    Endif

    Default Mask "[M:"+YMSKALIAS+"]"
    Case YTYPE
      When "integer","decimal"
        Assign "[M]" + YFIELDCODE + "(" + num$(CURRENTROW) + ")" With 0
      When "char"
        Assign "[M]" + YFIELDCODE + "(" + num$(CURRENTROW) + ")" With AVOID.ACHAR
      When "date"
        Assign "[M]" + YFIELDCODE + "(" + num$(CURRENTROW) + ")" With AVOID.ADATE
      When Default
    Endcase
  Else #AX3M
    Local Integer YI:YI = func YUTILS.FIND_ITEM(YFIELDS,YFIELDCODE)  #trovo riga
    YTYPE = YFIELDS(YI,YCOL_TYPE)              #trovo tipo
    YFIELDS(YI,YCOL_VALUE)= AVOID.ACHAR
  Endif
End

###################################################################################################################
#**
#* Gestione AFFZO per X3 (SOLO X3) per un campo di maschera
#*
#* @param YMSKALIAS  Alias videata corrente/in esame
#* @param YFIELDCODE  Codice campo su cui fare AFFZO
#*!

Subprog YAX3MOB_AFFZO(YMSKALIAS,YFIELDCODE)
  Value Char YMSKALIAS
  Value Char YFIELDCODE

  If(![V]GWEBSERV)
    Affzo ="[M:"+YMSKALIAS+"]"+YFIELDCODE
  Endif
End

###################################################################################################################
#**
#* Gestione AFFZO per X3 (SOLO X3) per un campo di riquadro
#*
#* @param YMSKALIAS  Alias videata corrente/in esame
#* @param YFIELDCODE  Codice campo su cui fare AFFZO
#* @param CURRENTROW  Riga corrente riquadro
#*!

Subprog YAX3MOB_AFFZO_RIQUADRO(YMSKALIAS, YFIELDCODE, CURRENTROW)
  Value Char YMSKALIAS
  Value Char YFIELDCODE
  Value Integer CURRENTROW

  If(![V]GWEBSERV)
    Affzo ="[M:"+YMSKALIAS+"]" + YFIELDCODE + "(" + num$(CURRENTROW) + ")"
  Endif
End

###################################################################################################################
#**
#* Affzo della DEFAULT MASK (maschera corrente su cui si sta lavorando)(solo X3)
#*!

$YAX3MOB_AFFZO_CURRENTMSK

  If(![V]GWEBSERV)
    Default Mask [M]
    Affzo [M]
  Endif
Return

###################################################################################################################
#**
#* Gestione AFFZO per X3 (SOLO X3) per aggiornamento variabile Fondo Riquadro
#* (usato per Riquadro delle Consultazioni)
#*
#* @param YMSKALIAS  Alias videata corrente/in esame
#* @param YNBLIGCODE Codice Campo associato avariabile fondo riquadro della videata in esame
#* @param YNBLIGVAL  Valore da assegnare a variabile di fondo Riquadro(N° righe da mostrare)
#*!

Subprog YAX3MOB_SET_NBLIG(YMSKALIAS,YNBLIGCODE,YNBLIGVAL)

  Value Char YMSKALIAS
  Value Char YNBLIGCODE
  Value Integer YNBLIGVAL

  If(![V]GWEBSERV)
    Default Mask "[M:"+YMSKALIAS+"]"
    Assign "[M]"+YNBLIGCODE With YNBLIGVAL
    Call YAX3MOB_AFFZO(YMSKALIAS,YNBLIGCODE)
    #Affzo = "[M:"+YMSKALIAS+"]"+YNBLIGCODE
  Endif
End


###################################################################################################################
#deprecato

#**
#* Gestione AFFZO per X3 (SOLO X3) per aggiornamento variabile Fondo Riquadro
#* (usato per Riquadro delle Consultazioni)
#*
#* @param YMSKALIAS  Alias videata corrente/in esame
#* @param YNBLIGCODE Codice Campo associato avariabile fondo riquadro della videata in esame
#* @param YNBLIGVAL  Valore da assegnare a variabile fondo Riquadro( N° righe da mostrare)
#*!

Subprog YAX3MOB_UPDATE_NBLIG(YMSKALIAS,YNBLIGCODE,YNBLIGVAL)

  Value Char YMSKALIAS
  Value Char YNBLIGCODE
  Value Integer YNBLIGVAL

  If(![V]GWEBSERV)
    Default Mask "[M:"+YMSKALIAS+"]"
    Assign "[M]"+YNBLIGCODE With YNBLIGVAL
    Affzo = "[M:"+YMSKALIAS+"]"+YNBLIGCODE
  Endif
End

###################################################################################################################

#DA STUDIARE
Subprog YAX3MOB_UPDATE_MSK(YMSKALIAS)

  Value Char YMSKALIAS
#  If(![V]GWEBSERV)
#    Default Mask "["+YMSKALIAS+"]"
#    #Affzo = "[M:"+YMSKALIAS+"]"
#    Affzo = "["+YMSKALIAS+"]"
#  Endif
End

###################################
#deprecato
#**
#* Affzo della DEFAULT MASK
#*!
$YAX3MOB_UPDATE_DEFMSK

  If(![V]GWEBSERV)
    Default Mask [M]
    Affzo [M]
  Endif
Return


###################################################################################################################
#**
#* Gestione EFFZO per X3/AX3M per un campo di maschera
#*
#* @param YFIELDS  Matrice dei campi
#* @param YMSKALIAS  Alias videata corrente, in esame
#* @param YFIELDCODE  Codice campo su cui fare EFFZO
#*!

Subprog YAX3MOB_EFFZO(YFIELDS,YMSKALIAS,YFIELDCODE)
  Variable Char YFIELDS()(,)
  Value Char YMSKALIAS
  Value Char YFIELDCODE

  If(![V]GWEBSERV) #solo su X3
    Effzo = "[M:"+YMSKALIAS+"]"+YFIELDCODE
  Else
    # VA SETTATO YFIELDS SUL FIELDENTER
    #Call YAX3MOB_RAZ(YFIELDS,YMSKALIAS,YFIELDCODE)
    #da implementare logica mobile
  Endif
End

###################################################################################################################
#**
#* Gestione GRIZO per X3/AX3M per un campo di maschera
#*
#* @param YFIELDS   Matrice dei campi
#* @param YMSKALIAS Alias videata corrente, in esame
#* @param YFIELDCODE Codice campo su cui fare GRIZO
#*!

Subprog YAX3MOB_GRIZO(YFIELDS,YMSKALIAS,YFIELDCODE)
  Variable Char YFIELDS()(,)
  Value Char YMSKALIAS
  Value Char YFIELDCODE

  If(![V]GWEBSERV) #X3
    Grizo = "[M:"+YMSKALIAS+"]"+YFIELDCODE
  Else #AX3M
    Call YAX3MOB_DISZO(YFIELDS,YMSKALIAS,YFIELDCODE)
  Endif
End

###############################################################################################################

#**
#* Gestione GRIZO per X3/AX3M per un campo di riquadro
#*
#* @param YFIELDS   Matrice dei campi
#* @param YMSKALIAS Alias videata corrente, in esame
#* @param YFIELDCODE Codice campo su cui fare GRIZO
#* @param CURRENTROW  Riga corrente riquadro
#*!

Subprog YAX3MOB_GRIZO_RIQUADRO(YFIELDS,YMSKALIAS,YFIELDCODE,CURRENTROW)
  Variable Char YFIELDS()(,)
  Value Char YMSKALIAS
  Value Char YFIELDCODE
  Value Integer CURRENTROW

  If(![V]GWEBSERV) #X3
    Grizo = "[M:"+YMSKALIAS+"]"+YFIELDCODE + "(" + num$(CURRENTROW) + ")"
  Else #AX3M
    Call YAX3MOB_DISZO_RIQUADRO(YFIELDS,YMSKALIAS,YFIELDCODE,CURRENTROW)
  Endif
End

###############################################################################################################
#**
#*
# Function to find the first row with currentRow = 1
#*!
Funprog FIND_CURRENTROW(YFIELDS)
  Variable Char YFIELDS()(,)

  Local Integer YCURRENTROW : YCURRENTROW=-1

    # Initializations
  Local Integer I, NUMROWS, NUMCOLS, ROW_FOUND : [L]ROW_FOUND = 0
  Local Char YFIELDNAME(50)

  # Get the number of rows and columns in the array
  NUMROWS = func YUTILS.COUNT_MULTI(YFIELDS)  # Length of the array for rows
  NUMCOLS = dim(YFIELDS, 2)  # Length of the array for columns

  For I = 0 To NUMROWS
    #fieldRiquadro
    If YFIELDS(I, 8) = "1"
      If YFIELDNAME = AVOID.ACHAR
        YFIELDNAME = YFIELDS(I, 0)
      Endif
      If YFIELDS(I, 0) = YFIELDNAME
        YCURRENTROW += 1
        If YFIELDS(I, 9) = "1" #currentRow
          ROW_FOUND = 1
          Break
        Endif
      Endif
    Endif
  Next

  If YCURRENTROW >= 0 & ROW_FOUND = 0
    End -1
  Endif

End YCURRENTROW

############################################################################################################
#**
#* Gestione valore campo durante az campo (SOLO AX3M)
#*
#* @param YFIELDS  Matrice dei campi
#* @param YMSKALIAS Codice videata corrente/in esame
#* @param YFIELDCODE Codice campo corrente/in esame
#* @param YFIELDVALUE Valore campo corrente
#*!

Subprog YAX3MOB_SETVALUE(YFIELDS,YMSKALIAS,YFIELDCODE,YFIELDVALUE)
  Variable Char YFIELDS()(,)
  Value Char YMSKALIAS
  Value Char YFIELDCODE
  Variable Char YFIELDVALUE

  Local Integer YI

  YI = func YUTILS.FIND_ITEM(YFIELDS,YFIELDCODE)
  YFIELDS(YI,2)= YFIELDVALUE
End

#################################################################################################################
#**
#* Gestione Validità per campo corrente azione campo (SOLO AX3M)
#*
#* @param YFIELDS  matrice dei campi
#* @param YFIELDCODE codice campo corrente
#* @param YMKSTAT valore mkstat/intero per gestione errore
#*!

Subprog YAX3MOB_SETVALID(YFIELDS,YFIELDCODE,YMKSTAT)
  Variable Char YFIELDS()(,)
  Value Char YFIELDCODE
  Value Integer YMKSTAT

  Const Integer YCOL_VALID : YCOL_VALID=3
  Local Integer YI : YI = func YUTILS.FIND_ITEM(YFIELDS,YFIELDCODE)

  Case YMKSTAT
    When 0  #ok
      YFIELDS(YI,YCOL_VALID)= "1" #"0" #valid
    When 1,2  #warning,errore
      YFIELDS(YI,YCOL_VALID)= "0" #"1"
    When Default
  Endcase
End

#################################################################################################################
#**
#* Gestione Validità per campo corrente azione campo (SOLO AX3M)
#*
#* @param YFIELDS  matrice dei campi
#* @param YFIELDCODE codice campo corrente
#* @param YMKSTAT valore mkstat/intero per gestione errore
#* @param YPOS Posizione (=0 : riga1, =1 :riga2)
#*!

Subprog YAX3MOB_SETVALID_RIQUADRO(YFIELDS,YCURRFIELD,YMKSTAT, YPOS)

  Variable Char YFIELDS()(,)
  Value Char YCURRFIELD
  Value Integer YMKSTAT
  Value Integer YPOS

  Const Integer YCOL_VALID : YCOL_VALID=3
  Local Integer YI : YI = func YUTILS.FIND_MULTITEM(YFIELDS,YCURRFIELD,YPOS)  #prendo il 1°:se T o D

  Case YMKSTAT
    When 0  #ok
      YFIELDS(YI,YCOL_VALID)= "1" #"0" #valid
    When 1,2  #warning,errore
      YFIELDS(YI,YCOL_VALID)= "0" #"1"
    When Default
  Endcase
End

##################################################################################################################
#**
#* Gestione a fine Az Campo:
#* 1) Eventuale gestione in Modifica
#* 2) Aggiornamento matrice YFIELDS post az.campo;
#* 3) Valorizzazione YRESPONSE;
#* 4) [LOG] Stampa END_MATRIX, YRESPONSE su files nella crt per Log
#*!

$YAX3MOB_END_ACTIONFIELD

  If(GWEBSERV)
    #Nel caso ci sia un caricamento dei dati di riquadro, andiamo ad aggiornare la YFIELDS
    If (YMODIF = 1)
      Gosub YAX3MOB_MODIF
    Endif

    Gosub YAX3MOB_GLOBALSET

    YRESPONSE = func YJSONSERIALIZE.GENERATE_JSON(mkstat,YALERT_TYPE,YALERT_MESSAGE,YALERT_WS,YOPENFUNCTION,YFIELDS,YHEADER,YDATA,YSELECTEDFIELDS)
  Endif

  #LOG (END):
  Gosub YAX3MOB_END From YAX3MLOG
Return

##################################################################################################################
#**
#* Gestione a fine Az Campo SENZA Impostazione automatica del Focus:
#* 1) Eventuale gestione in Modifica
#* 2) Aggiornamento matrice YFIELDS post az.campo;
#* 3) Valorizzazione YRESPONSE;
#* 4) [LOG] Stampa END_MATRIX, YRESPONSE su files nella crt per Log
#*!

$YAX3MOB_END_ACTIONFIELD_NOFOCUS

  If(GWEBSERV)

    #Nel caso ci sia un caricamento dei dati di riquadro, andiamo ad aggiornare la YFIELDS
    If (YMODIF = 1)
      Gosub YAX3MOB_MODIF
    Endif

    Gosub YAX3MOB_GLOBALSET_NOFOCUS
    YRESPONSE = func YJSONSERIALIZE.GENERATE_JSON(mkstat,YALERT_TYPE,YALERT_MESSAGE,YALERT_WS,YOPENFUNCTION,YFIELDS,YHEADER,YDATA,YSELECTEDFIELDS)
    #YRESPONSE = func YJSONSERIALIZE.GENERATE_JSON(mkstat,YALERT_TYPE,YALERT_MESSAGE,YALERT_WS,YOPENFUNCTION,YFIELDS,YHEADER,YDATA)
  Endif

  #LOG (END):
  Gosub YAX3MOB_END From YAX3MLOG
Return

####################################################################################################################
#**
#* Sub per gestione in modalità MODIFICA
#*!

$YAX3MOB_MODIF

  If clalev([F:YATR])=0 : Local File ACTPAR [F:YATR] : Endif

  Local Char YEXCLUDE_PARAMS(20)(2)   #array con codici dei parametri da escludere
  YEXCLUDE_PARAMS(0)="YAX3MRESP"
  YEXCLUDE_PARAMS(1)="YRESPONSE"

  Columns [F:YATR] (CODPAR,TYPPAR)
  Filter [F:YATR] Where ([F:YATR]ACTION = YACTION & !find([F:YATR]CODPAR,YEXCLUDE_PARAMS))  #considero solo parametri(azione)omonimi a campi videata

  Local Char YPARAM(50)
  Local Integer I,J,YF,YCURRENTROW_INDEX,YFIRSTROW_INDEX,YROW_INDEX

  #ciclo su tutte le righe di riquadro ricavate
  For I = 0 To YMODIF_RIQUADRO_COUNT - 1

    For [F:YATR]
      YCURRENTROW_INDEX = -1
      YPARAM = evalue("[F:YATR]CODPAR")            #ricavo il codice del Parametro dell'azione
      YF = func YUTILS.FIND_ITEM(YFIELDS, YPARAM)  #prendo il 1°:se T o D


Call ECR_TRACE("YPARAM :" -YPARAM ,0) From GESECRAN

      If(YFIELDS(YF,8)="1")#DETT

        YCURRENTROW_INDEX = func YUTILS.FIND_MULTITEM(YFIELDS, YPARAM, I)
        YROW_INDEX = I

        If(YCURRENTROW_INDEX >= 0)
          Gosub YAX3MOB_SETFIELD    #vecchia modalità (aggiornamento righe di dettaglio già presenti)
        Else
          #creo un nuovo item
          YCURRENTROW_INDEX = func YUTILS.COUNT_MULTI(YFIELDS)      #indice nuovo elemento
          YFIRSTROW_INDEX = YF#func YUTILS.FIND_ITEM(YFIELDS, YPARAM)  #calcolo indice primo elemento di riquadro
          #inizio a copiare l'ergonomia dei campi a venire, che ereditiamo da protocollo (esclusi i valori che sono settati nell'azione campo)
          For J = 0 To dim(YFIELDS, 2) - 1
            YFIELDS(YCURRENTROW_INDEX, J) = YFIELDS(YFIRSTROW_INDEX, J)
          Next
          Gosub YAX3MOB_SETFIELD_RIQUADRO_MODIF

        Endif

        #gestione messaggi in precaricamento
        If(type(YMEX_FIELDS) >0)
          YFIELDS(YCURRENTROW_INDEX, 4) = YMEX_FIELDS(func YUTILS.FIND_ITEM(YMEX_FIELDS, YPARAM),I+1)
        Endif
      Endif
      #Fine gestione singolo acT_PARAM
    Next
  Next
Return

####################################################################################################################
#**
#* Gestione a fine Bottone Finestra con setting campi videata/e:
#* 1) Aggiornamento matrice YFIELDS post az.campo;
#* 2) Stampa matrice YFIELDS (END) su CRT:tmp;
#* 3) valorizzazione YRESPONSE;
#* 4) Stampa YRESPONSE su CRT: tmp
#*!

$YAX3MOB_END_BUTTONACTION

  If(GWEBSERV)

    If(toupper(YFUNC_TYPE)="CONS")

      #Esiste anche la chiave "actions" (per gestione Multimedia)
      #If(func YUTILS.COUNT(YMEDIA)>0 & COUNT_VALUES >0)
      If(type(YMEDIA)>0 & func YUTILS.COUNT(YMEDIA)>0 & COUNT_VALUES >0)
        NUM_COLS +=1
        Call ECR_TRACE("Num Col Griglia(con MEDIA):"-num$(NUM_COLS),0) From GESECRAN
      Endif

      #If(COUNT_VALUES >0)
        Gosub SEL_CONS From YAX3MSEL
      #Endif
    Else
      Gosub YAX3MOB_BUTTONGLOBALSET

#      If(CURRENTROW =-1)
#        Call YAX3MOB_PRINT_YFIELDS("end", YFIELDS, YACTION)
#      Else
#        Call YAX3MOB_PRINT_YFIELDS("end", YFIELDS, YACTION-"- row"-num$(CURRENTROW))
#      Endif

      YRESPONSE = func YJSONSERIALIZE.GENERATE_JSON(mkstat,YALERT_TYPE,YALERT_MESSAGE,YALERT_WS,YOPENFUNCTION,YFIELDS,YHEADER,YDATA,YSELECTEDFIELDS)

      #LOG YRESPONSE (vecchia versione)
      #Call YPRINT_CLB(YRESPONSE, "YRESPONSE_" + YACTION, "json") From YUTILS

      #LOG (END):
      Gosub YAX3MOB_END From YAX3MLOG
    Endif

  Endif
Return

##################################################################################################################
#**
#* Sub collettrice : Aggiornamento matrice YFIELDS con 1) nuovi valori impostati durante az.campo, 2)impostazione validità campi, 3)impostazione focus sui campi
#*!

#$YAX3MOB_GLOBALSET
#
#  #1-values
#  Gosub YAX3MOB_SETVALUES
#
#  If(vireblc(YCURRFIELD,2) <> AVOID.ACHAR)
#    Local Integer YK: YK = func YUTILS.FIND_ITEM(YFIELDS,YCURRFIELD) #prendo il 1°:se T o D
#    #2-valid
#    Call YAX3MOB_SETVALID(YFIELDS,YCURRFIELD,mkstat) From YAX3MUTILS
#    #3-focus
#    Call YAX3MOB_FOCUS(YFIELDS,YCURRFIELD,mkstat) From YAX3MUTILS
#  Endif
#
#Return

############################################################################################################
#**
#* Sub collettrice : Aggiornamento matrice YFIELDS (a fine az. campo) con:
#*  1) nuovi valori impostati durante az.campo,
#*  2)impostazione validità campi,
#*  3)impostazione focus sui campi
#*!

$YAX3MOB_GLOBALSET

  Local Integer YK: YK = func YUTILS.FIND_ITEM(YFIELDS,YCURRFIELD) #prendo il 1°:se T o D

  #1-values
  If(YFIELDS(YK,8) = "0") #testata
    Gosub YAX3MOB_SETVALUES
  Else #dettaglio
    Gosub YAX3MOB_SETVALUES_RIQUADRO
  Endif

  If(vireblc(YCURRFIELD,2)<>AVOID.ACHAR)
    #2-valid
    If(YFIELDS(YK,8) = "0") #testata
      Call YAX3MOB_SETVALID(YFIELDS,YCURRFIELD,mkstat) From YAX3MUTILS
    Else #dettaglio
      YPOS = CURRENTROW
      Call YAX3MOB_SETVALID_RIQUADRO(YFIELDS,YCURRFIELD,mkstat,YPOS)
    Endif

    #3-focus
    If(YFIELDS(YK,8) = "0") #testata
      Call YAX3MOB_FOCUS(YFIELDS,YCURRFIELD,mkstat) From YAX3MUTILS
    Else #dettaglio
      YPOS = CURRENTROW
      Call YAX3MOB_FOCUS_RIQUADRO(YFIELDS,YCURRFIELD,mkstat,YPOS)
    Endif
  Endif
Return

############################################################################################################
#**
#* Sub collettrice : Aggiornamento matrice YFIELDS (a fine az. bottone di finestra) con:
#*  1) nuovi valori impostati durante az.campo,
#*  2)impostazione validità campi,
#*  3)impostazione focus sui campi
#*!

$YAX3MOB_BUTTONGLOBALSET

  Gosub YAX3MOB_SETVALUES_FROMBUTTON

  If(vireblc(YCURRFIELD,2) <> AVOID.ACHAR)
    Local Integer YK: YK = func YUTILS.FIND_ITEM(YFIELDS,YCURRFIELD) #prendo il 1°:se T o D
    #2-valid
    Call YAX3MOB_SETVALID(YFIELDS,YCURRFIELD,mkstat) From YAX3MUTILS
    #3-focus
    Call YAX3MOB_FOCUS(YFIELDS,YCURRFIELD,mkstat) From YAX3MUTILS
  Endif

Return

##################################################################################################################
#**
#* Sub collettrice : Aggiornamento matrice YFIELDS (SENZA Focus)con 1) nuovi valori impostati durante az.campo, 2)impostazione validità campi, 3)impostazione focus sui campi
#*!

$YAX3MOB_GLOBALSET_NOFOCUS

  Local Integer YK: YK = func YUTILS.FIND_ITEM(YFIELDS,YCURRFIELD) #prendo il 1°:se T o D
  #1-values
  If(YFIELDS(YK,8)="0")#testata
    Gosub YAX3MOB_SETVALUES
  Else #dettaglio
    Gosub YAX3MOB_SETVALUES_RIQUADRO
  Endif

  If(vireblc(YCURRFIELD,2)<>AVOID.ACHAR)
    #2-valid
    If(YFIELDS(YK,8)="0")#testata
      Call YAX3MOB_SETVALID(YFIELDS,YCURRFIELD,mkstat) From YAX3MUTILS
    Else #dettaglio
      YPOS = CURRENTROW
      Call YAX3MOB_SETVALID_RIQUADRO(YFIELDS,YCURRFIELD,mkstat,YPOS)
    Endif
  Endif

Return

################################################################################################################

$YAX3MOB_RAZFIELDMESSAGES

  Local Integer YI
  Const Integer YCOL_MEX : YCOL_MEX= 4
  For YI = 0 To dim(YFIELDS,1)-1
    YFIELDS(YI,YCOL_MEX) = AVOID.ACHAR
  Next
Return

#################################################################################################################
#**
#* Aggiornamento matrice YFIELDS con valori di parametri dell'az.campo, esclusione di "YAX3MRESP", "YRESPONSE"
#*!

$YAX3MOB_SETVALUES

  If clalev([F:YATR])=0 : Local File ACTPAR [F:YATR] : Endif
  Local Char YEXCLUDE_PARAMS(20)(2)   #array con codici dei parametri da escludere

  YEXCLUDE_PARAMS(0)="YAX3MRESP"
  YEXCLUDE_PARAMS(1)="YRESPONSE"

  #filtro i parametri dell'azione
  Columns [F:YATR] (CODPAR)
  Filter [F:YATR] Where ([F:YATR]ACTION = YACTION & !find([F:YATR]CODPAR,YEXCLUDE_PARAMS))  #considero solo parametri(azione)omonimi a campi videata

  Local Char YPARAM(50)
  Local Integer YCURRENTROW_INDEX
  Local Integer YPOS #posizione da cercare nella matrice, CURRENTROW =-1,0,1,2,eec

  For [F:YATR]
    YPARAM = evalue("[F:YATR]CODPAR")

    If(CURRENTROW = -1)
      YPOS = 0
    Else
      YPOS = CURRENTROW
    Endif

    If type(CURRENTROW) >= 0 & CURRENTROW >= 0
      YCURRENTROW_INDEX = func YUTILS.FIND_MULTITEM(YFIELDS, YPARAM, YPOS)
    Else
      YCURRENTROW_INDEX = func YUTILS.FIND_ITEM(YFIELDS, YPARAM)
    Endif

    If(YCURRENTROW_INDEX >= 0)
      Gosub YAX3MOB_SETFIELD
    Endif
  Next
Return

#########################################################################################
#**
#* Aggiornamento matrice YFIELDS con valori di parametri dell'az.campo, esclusione di "YAX3MRESP", "YRESPONSE", per RIQUADRO
#*!

$YAX3MOB_SETVALUES_RIQUADRO

  If clalev([F:YATR])=0 : Local File ACTPAR [F:YATR] : Endif
  Local Char YEXCLUDE_PARAMS(20)(2)   #array con codici dei parametri da escludere

  YEXCLUDE_PARAMS(0)="YAX3MRESP"
  YEXCLUDE_PARAMS(1)="YRESPONSE"

  Columns [F:YATR] (CODPAR)
  Filter [F:YATR] Where ([F:YATR]ACTION = YACTION & !find([F:YATR]CODPAR,YEXCLUDE_PARAMS))  #considero solo parametri(azione)omonimi a campi videata

  Local Char YPARAM(50)

  For [F:YATR]
    YPARAM = evalue("[F:YATR]CODPAR")
    Local Integer YCURRENTROW_INDEX

    Local Integer YPOS
    Local Integer YZ : YZ = func YUTILS.FIND_ITEM(YFIELDS,YPARAM)

    If(CURRENTROW = -1)
      YPOS = 0
    Else
      If(YFIELDS(YZ,8) = "0")#testata
        YPOS = 0
      Else #dettaglio
        YPOS = CURRENTROW
      Endif
    Endif

    If(YFIELDS(YZ,8) = "0") #TESTATA
        If type(CURRENTROW) >= 0 & CURRENTROW >= 0
          YCURRENTROW_INDEX = func YUTILS.FIND_MULTITEM(YFIELDS, YPARAM, YPOS)
          If(YCURRENTROW_INDEX >= 0)
            Gosub YAX3MOB_SETFIELD
          Endif
        Else
          YCURRENTROW_INDEX = func YUTILS.FIND_ITEM(YFIELDS, YPARAM)
          If(YCURRENTROW_INDEX >= 0)
            Gosub YAX3MOB_SETFIELD
          Endif
        Endif
    Else
      If type(CURRENTROW) >= 0 & CURRENTROW >= 0
          YCURRENTROW_INDEX = func YUTILS.FIND_MULTITEM(YFIELDS, YPARAM, YPOS)
          If(YCURRENTROW_INDEX >= 0)
            Gosub YAX3MOB_SETFIELD_RIQUADRO
          Endif
        Else
          YCURRENTROW_INDEX = func YUTILS.FIND_ITEM(YFIELDS, YPARAM)
          If(YCURRENTROW_INDEX >= 0)
            Gosub YAX3MOB_SETFIELD_RIQUADRO
          Endif
        Endif
    Endif
  Next
Return

#################################################################################
#**
#* Aggiornamento matrice YFIELDS con valori di parametri dell'az.campo, esclusione di "YAX3MRESP", "YRESPONSE",
#* per Azione Bottone di Finestra, aggiornamento dei valori dei campi in YFIELDS  post Azione bottone
#*!

$YAX3MOB_SETVALUES_FROMBUTTON

  If clalev([F:YATR])=0 : Local File ACTPAR [F:YATR] : Endif
  Local Char YEXCLUDE_PARAMS(20)(2)   # Array con codici dei parametri da escludere
  Local Integer YPOS, YCURRENTROW_INDEX, I, YITEM_POS, RIQUADRO_COUNT
  Local Char YPARAM(50), YPARAMTMP(50)

  YEXCLUDE_PARAMS(0)="YAX3MRESP"
  YEXCLUDE_PARAMS(1)="YRESPONSE"

  # Filtro i parametri dell'azione
  Columns [F:YATR] (CODPAR)
  Filter [F:YATR] Where ([F:YATR]ACTION = YACTION & !find([F:YATR]CODPAR,YEXCLUDE_PARAMS))

  YPARAMTMP = AVOID.ACHAR
  RIQUADRO_COUNT = 0

  For J = 0 To func YUTILS.COUNT_MULTI(YFIELDS)
    If YFIELDS(J, 8) = "1" & (YPARAMTMP = AVOID.ACHAR | YFIELDS(J, 0) = YPARAMTMP) # Elemento di riquadro
      YPARAMTMP = YFIELDS(J, 0)
      RIQUADRO_COUNT+=1
    Endif
  Next

  For [F:YATR]
    YPARAM = evalue("[F:YATR]CODPAR")
    YITEM_POS = func YUTILS.FIND_ITEM(YFIELDS, YPARAM)

    If YITEM_POS >= 0

      If YFIELDS(YITEM_POS,8) = "0" # Elemento Testata
        YCURRENTROW_INDEX = func YUTILS.FIND_ITEM(YFIELDS, YPARAM)
        If YCURRENTROW_INDEX >= 0
          Gosub YAX3MOB_SETFIELD
        Endif
      Else
        For I = 0 To RIQUADRO_COUNT - 1
          YCURRENTROW_INDEX = func YUTILS.FIND_MULTITEM(YFIELDS, YPARAM, I)
          YROW_INDEX = I #(aggiunta)

          If YCURRENTROW_INDEX >= 0
            Gosub YAX3MOB_SETFIELD_RIQUADRO_MODIF
          Endif
        Next
      Endif
    Endif
  Next

  Filter [F:YATR] # pulisco l'alias
Return

##################################################################################################
#**
#* Imposto il valore nella matrice YFIELDS (fieldValue) in base al tipo dato(date, char, integer, decimal) e Valore di default
#*!

$YAX3MOB_SETFIELD

  If(YFIELDS(YCURRENTROW_INDEX, 1) = "date")
    If evalue(YPARAM) <> AVOID.ADATE
      YFIELDS(YCURRENTROW_INDEX, 2) = format$("D:YYYY[-]MM[-]DD[T]hh[:]mm[:]ss[Z]", evalue(YPARAM))
    Else
      YFIELDS(YCURRENTROW_INDEX, 2) = format$("D:YYYY[-]MM[-]DD[T]hh[:]mm[:]ss[Z]", date$)
    Endif
  Elsif(YFIELDS(YCURRENTROW_INDEX, 1) = "char")
    If vireblc(evalue(YPARAM), 2) = AVOID.ACHAR
      YFIELDS(YCURRENTROW_INDEX, 2) = AVOID.ACHAR
    Else
      YFIELDS(YCURRENTROW_INDEX, 2) = num$(evalue(YPARAM))
    Endif
  Else
    YFIELDS(YCURRENTROW_INDEX, 2) = num$(evalue(YPARAM))
  Endif
Return

##########################################################################################################
#**
#* Imposto il valore nella matrice YFIELDS (fieldValue) in base al tipo dato(date, char, integer, decimal) e Valore di default, per RIQUADRO
#*!

$YAX3MOB_SETFIELD_RIQUADRO

  If(YFIELDS(YCURRENTROW_INDEX, 1) = "date")
    If evalue(YPARAM) <> AVOID.ADATE
      YFIELDS(YCURRENTROW_INDEX, 2) = format$("D:YYYY[-]MM[-]DD[T]hh[:]mm[:]ss[Z]", evalue(YPARAM+"("+num$(CURRENTROW)+")"))
    Else
      YFIELDS(YCURRENTROW_INDEX, 2) = format$("D:YYYY[-]MM[-]DD[T]hh[:]mm[:]ss[Z]", date$)
    Endif
  Elsif(YFIELDS(YCURRENTROW_INDEX, 1) = "char")
    If vireblc(evalue(YPARAM+"("+num$(CURRENTROW)+")"), 2) = AVOID.ACHAR #
      YFIELDS(YCURRENTROW_INDEX, 2) = AVOID.ACHAR
    Else
      YFIELDS(YCURRENTROW_INDEX, 2) = num$(evalue(YPARAM+"("+num$(CURRENTROW)+")"))
    Endif
  Else #decimal & int
    YFIELDS(YCURRENTROW_INDEX, 2) = num$(evalue(YPARAM+"("+num$(CURRENTROW)+")"))
  Endif
Return

###############################################################################################################
#**
#* Valorizzazione Valore campo Riquadro in Modalità: MODIFICA
#*!

$YAX3MOB_SETFIELD_RIQUADRO_MODIF

  If(YFIELDS(YCURRENTROW_INDEX, 1) = "date")
    If evalue(YPARAM) <> AVOID.ADATE
      YFIELDS(YCURRENTROW_INDEX, 2) = format$("D:YYYY[-]MM[-]DD[T]hh[:]mm[:]ss[Z]", evalue(YPARAM+"("+num$(YROW_INDEX)+")"))
    Else
      YFIELDS(YCURRENTROW_INDEX, 2) = format$("D:YYYY[-]MM[-]DD[T]hh[:]mm[:]ss[Z]", date$)
    Endif
  Elsif(YFIELDS(YCURRENTROW_INDEX, 1) = "char")
    #If vireblc(evalue(YPARAM), 2) = AVOID.ACHAR
    If vireblc(evalue(YPARAM+"("+num$(YROW_INDEX)+")"), 2) = AVOID.ACHAR
      YFIELDS(YCURRENTROW_INDEX, 2) = AVOID.ACHAR
    Else
      YFIELDS(YCURRENTROW_INDEX, 2) = num$(evalue(YPARAM+"("+num$(YROW_INDEX)+")"))
    Endif
  Else #decimal & int
    YFIELDS(YCURRENTROW_INDEX, 2) = num$(evalue(YPARAM+"("+num$(YROW_INDEX)+")"))
  Endif
Return

#############################################################################################################
#**
#* Funzione per azzerare/pulire il riquadro Lato X3/lato Mobile
#*
#* @param YFIELDS Matrice dei campi di videata
#* @param YMSKALIAS  Alias videata
#*
#*!

Subprog YAX3MOB_RAZRIQUADRO(YFIELDS,YMSKALIAS)

  Variable Char YFIELDS()(,)
  Value Char YMSKALIAS

  Local File AMSKZON [F:YAMZ]
  Local Integer YI,YJ,YK
  Local Char YDETTFLDCODES(250)(50)
  Local Char YDFLDCODE(250)
  Local Char YTMPFIELDS(250)(dim(YFIELDS,1),dim(YFIELDS,2))

  If(GWEBSERV)

    For YI =0 To func YUTILS.COUNT_MULTI(YFIELDS) - 1
      #campo riquadro
      If(YFIELDS(YI,8) = "1")

        YDFLDCODE = YFIELDS(YI,0)
        If(find(YDFLDCODE, YDETTFLDCODES) = 0)
          YDETTFLDCODES(YK) = YDFLDCODE
          YK += 1
        Else
          #razzo tutta la riga matrice : YI (codice campo compreso)
          For YJ=0 To dim(YFIELDS,2)-1
            Raz YFIELDS(YI,YJ)
          Next
        Endif
      Endif
    Next
    Call YHANDLEMAT(YFIELDS,YTMPFIELDS) From YUTILS  #qui tolgo le righe vuote , riconfiguro la matrice
  Else
    #imposto  a 0(esempio: NBLIG = 0)
    Filter [F:YAMZ] Where ([F:YAMZ]CODMSK = YMSKALIAS & [F:YAMZ]DIME = 0)
    Read [F:YAMZ] First
    YNBLIGCODE = [F:YAMZ]CODZON # assumiamo un solo riquadro per videata

    Default Mask "[M:"+YMSKALIAS+"]"
    Assign "[M]"+YNBLIGCODE With 0
    Affzo = "[M:"+YMSKALIAS+"]"+YNBLIGCODE
  Endif
End


##########################################################################################################
#                                     GESTIONE BOTTONE DI FINESTRA
##########################################################################################################
#**
#* Metodo per composizione contenuto .csv
#*
#* @param YCSVTEXT Contenuto .csv da comporre
#* @param YTEXT Testo da concatenare
#* @param IS_LASTFIELD  Intero(booleano) per aggiungere o meno il separatore
#*!

Subprog YAX3MOB_APPEND(YCSVTEXT, YTEXT, IS_LASTFIELD)

  Variable Clbfile YCSVTEXT
  Value Char YTEXT
  Value Integer IS_LASTFIELD

  Append  YCSVTEXT, YTEXT
  #Appendo il separaratore solo se non è l'ultimo campo, sennò aggiungo un LF
  If(IS_LASTFIELD = 0)
    Append  YCSVTEXT, ";"
  Else
    Append  YCSVTEXT, chr$(10)
  Endif
End

##########################################################################################################
#**
#* Lancio modello di Import e memorizzazione contatore alla Creaz del Documento
#*
#* @param YIMPORT_MODEL Codice Modello di Import
#* @param YCSVTEXT Contenuto csv
#* @param YSTATUS Booleano
#* @param YMESSAGE Messaggio da valorizzare
#*!

Subprog YAX3MOB_IMPORTSIL(YIMPORT_MODEL, YCSVTEXT, YSUCCESS, YMESSAGE)

  Value Char YIMPORT_MODEL
  Value Clbfile YCSVTEXT
  Variable Integer YSUCCESS
  Variable Char YMESSAGE

  Local Integer YREQUEST_NUMBER
  Local Char YEND(3) : YEND = "END"
  #Local Char YMESSAGEIMP(250)

  Append YCSVTEXT, YEND

  #Lancio Modello di Import
  If(vireblc(YIMPORT_MODEL,2)<> AVOID.ACHAR)

    Call IMPORT(YIMPORT_MODEL, "NO", "REALTIME", chr$(10), YCSVTEXT, YREQUEST_NUMBER, YSUCCESS, YMESSAGE) From AOWSIMPORT
    #YMESSAGE = func YUTILS.IIF(vireblc(YMESSAGE, 2) <> AVOID.ACHAR, YMESSAGE, func YAX3MOBGET_TRACE(GTRACE))

    Call ECR_TRACE("Stato import:" - num$(YSUCCESS) - " - Messaggio:" - YMESSAGE,0) From GESECRAN
    Call YAX3MOB_ECRTRACE(0,"Stato import:" - num$(YSUCCESS) - " - Messaggio:" - YMESSAGE) From  YAX3MLOG  #log
  Else
    #Call ECR_TRACE("Modello di Import non esistente",0) From GESECRAN
    Call YAX3MOB_ECRTRACE(2,"Modello di Import non esistente") From YAX3MLOG     #log
  Endif
End

########################################################################################################
#**
#* Funzione per estrarre Errori da file di Traccia
#*
#* @param YFILNAM Nome file di traccia
#*!

Funprog YAX3MOBGET_TRACE(YFILNAM)
  Value Char YFILNAM
  # la risposta è di length 200 perchè uso già un'altra chiave status nel payload di risposta
  Local Char YMESSAGE(250), YFILTRACE(250), YTRACETEXT(250)(100)
  Local Integer ISFIRST, I

  ISFIRST = 2
  YFILTRACE= filpath("TRA", YFILNAM, "tra")

  If filinfo(YFILTRACE, 0)>=0
    Openi YFILTRACE Using [RL]
    Iomode adxifs "" Using [RL]
    Iomode adxirs chr$(10) Using [RL]
    Iomode adxium GASCII Using [RL]
    Repeat
      Rdseq YTRACETEXT(I) Using [RL]
      If instr(1, YTRACETEXT(I), "<0001") > 0
        Call REPLACE(YTRACETEXT(I), "<0001", "") From YUTILS
        If ISFIRST <> 2
          YMESSAGE -= "-"
        Endif
        YMESSAGE -= YTRACETEXT(I)
        ISFIRST = 1
        If len(YMESSAGE) > 200
          End escJson(mid$(YMESSAGE, 1, 200))
        Endif
      Endif
      I+=1
    Until fstat <> 0
  Endif

End escJson(YMESSAGE)

#########################################################################################################
#**
#* Gestione messaggio dell'azione campo - X3/AX3M
#*
#* @param YFIELDS  matrice dei campi (lato X3: SOLO parametro formale)
#* @param YFIELDCODE codice campo corrente/in esame (passato come stringa) (lato X3: SOLO parametro formale)
#* @param YMKSTAT valore mkstat/intero per gestione di errore [X3/AX3M]
#* @param YMESS testo messaggio da visualizzare [X3/AX3M]
#*!

Subprog YAX3MOB_SHOWMESS(YFIELDS,YFIELDCODE,YMKSTAT,YMESS)

  Variable Char YFIELDS()(,)
  Value Char YFIELDCODE
  Value Integer YMKSTAT
  Value Char YMESS

  If(GTRACE <> AVOID.ACHAR)
    #Gestione Traccia con messaggi in ROSSO(Errore), BLU (Warning), NERO(default)
    Local Integer YTRACE_COLOR: YTRACE_COLOR =0
    If(YMKSTAT=2 | YMKSTAT=1) #errore, warning
      YTRACE_COLOR =1
    Endif
    Call ECR_TRACE("Campo :"-YFIELDCODE-" - Messaggio :"-YMESS, YTRACE_COLOR) From GESECRAN
  Endif

  If(!GWEBSERV)  #X3

    #If(GTRACE = AVOID.ACHAR) #per gestione NON Batch
      Case YMKSTAT
        When 0  #ok
          Call MESSAGE(YMESS) From GESECRAN
        When 1  #warning
          Local Integer OKCAN : OKCAN = 2
          Call AVERTIR(YMESS,OKCAN) From GESECRAN
        When 2  #errore
          Call ERREUR(YMESS) From GESECRAN
        When Default
      Endcase
   # Endif
  Else #AX3M
    Const Integer YCOL_MEX : YCOL_MEX= 4
    Local Integer YI : YI = func YUTILS.FIND_ITEM(YFIELDS, YFIELDCODE)
    If (YI >= 0)
      YFIELDS(YI, YCOL_MEX) = YMESS  #mex
    Else
      Call ECR_TRACE("Campo" - YFIELDCODE - "non trovato!", 0) From GESECRAN
    Endif
  Endif

End

########################################################################################################
#**
#* Gestione della label (Solo lato Mobile)
#*
#* @param YFIELDS Matrice dei campi
#* @param YFIELDCODE Codice del campo a cui applicare la label
#* @param YMKSTAT Intero(booleano) per tipologia di label (rossa(errore)/blu(informativa))
#* @param YMESS Messaggio da visualizzare nella label
#* @param CURRENTROW Riga corrente
#*!

Subprog YAX3MOB_SETLABEL(YFIELDS,YFIELDCODE,YMKSTAT,YMESS,CURRENTROW)

  Variable Char YFIELDS()(,)
  Value Char YFIELDCODE
  Value Integer YMKSTAT
  Value Char YMESS
  Value Integer CURRENTROW

  If(GWEBSERV)
    Const Integer YCOL_MEX : YCOL_MEX= 4
    Local Integer YK: YK = func YUTILS.FIND_ITEM(YFIELDS, YFIELDCODE)

    If (YK >= 0)
       If(YFIELDS(YK,8)="0")#testata
        YFIELDS(YK, YCOL_MEX) = YMESS  #mex
       Else
        Local Integer YI : YI = func YUTILS.FIND_MULTITEM(YFIELDS, YFIELDCODE,CURRENTROW)
        YFIELDS(YI, YCOL_MEX) = YMESS  #mex
       Endif
    Else
      Call ECR_TRACE("Campo" - YFIELDCODE - "non trovato!", 0) From GESECRAN
    Endif
  Endif
End

#################################################################################
#**
#* Funzione per pulire Label di un campo (YFIELDCODE) [funzionalità solo lato Mobile]
#*
#* @param YFIELDS Matrice dei campi di videata
#* @param YFIELDCODE Codice campo di cui pulire la label
#* @param CURRENTROW Riga
#*!
Subprog YAX3MOB_RAZLABEL(YFIELDS,YFIELDCODE,CURRENTROW)

  Variable Char YFIELDS()(,)
  Value Char YFIELDCODE
  Value Integer CURRENTROW
  Call YAX3MOB_SETLABEL(YFIELDS,YFIELDCODE,0,AVOID.ACHAR,CURRENTROW)
End

#################################################################################
#**
#* Funzione per pulire tutti messaggi/label lato Mobile
#*
#* @param YFIELDS Matrice dei campi di videata
#*!

Subprog YAX3MOB_RAZMESSAGES(YFIELDS)

  Variable Char YFIELDS()(,)
  Local Integer YI
  Const Integer YCOL_MEX : YCOL_MEX = 4

  If(GWEBSERV)
    For YI =0 To dim(YFIELDS,1)-1
      YFIELDS(YI, YCOL_MEX) = AVOID.ACHAR  #mex/label
    Next
  Endif
End

########################################################################################################
#**
#* Gestione messaggio per campo di Riquadro
#*
#* @param YFIELDS Matrice dei campi
#* @param YFIELDCODE Codice del campo a cui è associato il messagio
#* @param YMKSTAT Intero(booleano) per status (Information, warning , error)
#* @param YMESS Messaggio da visualizzare
#* @param CURRENTROW Riga corrente
#*!

Subprog YAX3MOB_SHOWMESS_RIQUADRO(YFIELDS,YFIELDCODE,YMKSTAT,YMESS,CURRENTROW)

  Variable Char YFIELDS()(,)
  Value Char YFIELDCODE
  Value Integer YMKSTAT
  Value Char YMESS
  Value Integer CURRENTROW

  If(GTRACE <> AVOID.ACHAR)
    #Gestione Traccia con messaggi in ROSSO(Errore), BLU (Warning), NERO(default)
    Local Integer YTRACE_COLOR: YTRACE_COLOR =0
    If(YMKSTAT=2 | YMKSTAT=1) #errore, warning
      YTRACE_COLOR =1
    Endif
    #Call ECR_TRACE("Campo :"-YFIELDCODE-" - Messaggio :"-YMESS, YTRACE_COLOR) From GESECRAN
  Endif

  If(!GWEBSERV)  #X3
    #If(GTRACE = AVOID.ACHAR) #per gestione NON Batch
      Case YMKSTAT
        When 0  #ok
          Call MESSAGE(YMESS) From GESECRAN
        When 1  #warning
          Local Integer OKCAN : OKCAN = 2
          Call AVERTIR(YMESS,OKCAN) From GESECRAN
        When 2  #errore
          Call ERREUR(YMESS) From GESECRAN
        When Default
      Endcase
   # Endif
  Else #AX3M
    Const Integer YCOL_MEX : YCOL_MEX= 4
    Local Integer YI : YI = func YUTILS.FIND_MULTITEM(YFIELDS, YFIELDCODE,CURRENTROW)
    If (YI >= 0)
      YFIELDS(YI, YCOL_MEX) = YMESS  #mex
    Else
      #Call ECR_TRACE("Campo" - YFIELDCODE - "non trovato!", 0) From GESECRAN
    Endif
  Endif
End

#########################################################################################################
#########################################################################################################
##Con questa funzione setto esclusivamente le variabili ALERT_TYPE E ALERT_MESSAGE per riferimento

#**
#* Visualizzazione eventuale Messaggio per azione Bottone di Finestra, a video (X3/Mobile).
#* ( Con questa funzione setto esclusivamente le variabili ALERT_TYPE E ALERT_MESSAGE per riferimento )
#*
#* @param YMKSTAT  Intero (booleano)
#* @param ALERT_TYPE Tipo Alert
#* @param ALERT_MESSAGE Messaggio da visualizzare nell'Alert
#*!

Subprog YAX3MOB_SHOWALERT(YMKSTAT,ALERT_TYPE,ALERT_MESSAGE)

  Value Integer YMKSTAT
  Variable Char ALERT_TYPE
  Variable Char ALERT_MESSAGE

  If(!GWEBSERV)#X3
    Case YMKSTAT
      When 0  #ok
        Call MESSAGE(ALERT_MESSAGE) From GESECRAN
      When 1  #warning
        Local Integer OKCAN : OKCAN = 2
        Call AVERTIR(ALERT_MESSAGE, OKCAN) From GESECRAN
      When 2  #errore
        Call ERREUR(ALERT_MESSAGE) From GESECRAN
      When Default
    Endcase
  Else #Mobile
    Case YMKSTAT
      When 0  #ok
        ALERT_TYPE = "toast"
      When 1  #warning/info
        ALERT_TYPE = "info"
      When 2  #errore
        ALERT_TYPE = "error"
      When Default
    Endcase
  Endif
End

##########################################################################################################
##########################################################################################################

Subprog YSTRVALEUR(YVALEURARR,YVALEURVAR,CURRENTROW)

  Variable Char YVALEURARR()()
  Variable Char YVALEURVAR
  Value Integer CURRENTROW

  If(!GWEBSERV)
    YVALEURVAR =YVALEURARR(0)
  Else
    If(CURRENTROW >=0)
      YVALEURVAR =YVALEURARR(CURRENTROW)
    Endif
  #YVALEURVAR =YVALEURARR(CURRENTROW)
  Endif
End

Subprog YSETSTRVALEUR(YVALEURARR,YVALEURVAR,CURRENTROW)

  Variable Char YVALEURARR()()
  Variable Char YVALEURVAR
  Value Integer CURRENTROW

  If(!GWEBSERV)
    YVALEURARR(0)=YVALEURVAR
  Else
    YVALEURARR(CURRENTROW)=YVALEURVAR
  Endif
End

##############################################################################################################
Subprog YINTVALEUR(YVALEURARR,YVALEURVAR,CURRENTROW)

  Variable Integer YVALEURARR()
  Variable Integer YVALEURVAR
  Value Integer CURRENTROW

  If(!GWEBSERV)
    YVALEURVAR =YVALEURARR(0)
  Else
    If(CURRENTROW >=0)
      YVALEURVAR =YVALEURARR(CURRENTROW)
    Endif
    #YVALEURVAR =YVALEURARR(CURRENTROW)
  Endif
End

#############################################################################################################
Subprog YDECVALEUR(YVALEURARR,YVALEURVAR,CURRENTROW)

  Variable Decimal YVALEURARR()
  Variable Decimal YVALEURVAR
  Value Integer CURRENTROW

  If(!GWEBSERV)
    YVALEURVAR =YVALEURARR(0)
  Else
    If(CURRENTROW >=0)
      YVALEURVAR =YVALEURARR(CURRENTROW)
    Endif
    #YVALEURVAR =YVALEURARR(CURRENTROW)
  Endif
End
##################################################################################################################
Subprog YSETDECVALEUR(YVALEURARR,YVALEURVAR,CURRENTROW)

  Variable Decimal YVALEURARR()
  Variable Decimal YVALEURVAR
  Value Integer CURRENTROW

  If(!GWEBSERV)
    YVALEURARR(0)=YVALEURVAR
  Else
    If(CURRENTROW >=0)
      YVALEURARR(CURRENTROW)=YVALEURVAR
    Endif
  Endif
End

################################################################

Subprog YDATEVALEUR(YVALEURARR,YVALEURVAR,CURRENTROW)

  Variable Date YVALEURARR()
  Variable Date YVALEURVAR
  Value Integer CURRENTROW

  If(!GWEBSERV)
    YVALEURVAR =YVALEURARR(0)
  Else
    If(CURRENTROW >=0)
      YVALEURVAR =YVALEURARR(CURRENTROW)
    Endif
    #YVALEURVAR =YVALEURARR(CURRENTROW)
  Endif
End

##########################################################################################################
#                                   DEBUG
##########################################################################################################
#**
#* Metodo per stampa su .txt su cartella "tmp" della matrice YFIELDS
#*
#* @param YWHEN Settore
#* @param YFIELDS matrice YFIELDS
#* @param YACTION Azione X3 in esame
#*!

Subprog YAX3MOB_PRINT_YFIELDS(YWHEN, YFIELDS, YACTION)
  Value Char YWHEN
  Value Char YFIELDS()(,)
  Value Char YACTION

  Local Integer XDIM : XDIM = func YUTILS.COUNT_MULTI(YFIELDS) - 1
  Local Integer YDIM : YDIM = dim(YFIELDS,2)-1
  Local Integer I, J

  Gosub YSET_COLKEYS From YJSONDESERIALIZE

  Local Char YFIL(250)
  Local Char YNOW(50) : YNOW = ctrans(func YUTILS.YFORMATDATE(num$(datetime$),"DT"),":", "")
  YFIL = filpath("tmp", "print_yfields_"+YACTION+"_"+ YWHEN+ "_" + YNOW, "txt")
  Openo YFIL Using [YF]
  Iomode adxium GUTF8 Using [YF]
  Iomode adxirs chr$(13)+chr$(10) Using [YF]
  Wrseq "xdim = " - num$(XDIM)- "ydim = "-num$(dim(YFIELDS,2)) Using [YF]

  For I = 0 To XDIM
    Wrseq "New item:"  Using [YF]
    For J = 0 To YDIM
      Wrseq num$(I) + "," + num$(J) - "-" - YCOL_KEYS(J) + ":" - YFIELDS(I,J) Using [YF]
    Next J
  Next
  Openo Using [YF]

End

########################################################################################
#**
#*  Metodo per stampa su .txt su cartella LogDir della matrice YFIELDS
#*
#* @param YDIR Nome directory
#* @param YWHEN  Momento: "init", "end"
#* @param YFIELDS Matrice YFIELDS
#* @param YACTION Azione lanciata
#* @param YCURRENTUSER  Utente loggato
#*!

Subprog YAX3MOB_PRINT_DIR_YFIELDS(YDIR, YWHEN, YFIELDS, YACTION,YCURRENTUSER)

  Value Char YDIR
  Value Char YWHEN
  Value Char YFIELDS()(,)
  Value Char YACTION
  Value Char YCURRENTUSER

  Local Integer XDIM : XDIM = func YUTILS.COUNT_MULTI(YFIELDS) - 1
  Local Integer YDIM : YDIM = dim(YFIELDS,2)-1
  Local Integer I, J

  Gosub YSET_COLKEYS From YJSONDESERIALIZE

  Local Char YFIL(250)
  Local Char YNOW(50) : YNOW = ctrans(func YUTILS.YFORMATDATE(num$(datetime$),"DT"),":", "")
  YFIL = filpath(YDIR, "print_yfields_"+YACTION+"_("+YCURRENTUSER+")"+"_"+ YWHEN+ "_" + YNOW, "txt")
  Openo YFIL Using [YF]
  Iomode adxium GUTF8 Using [YF]
  Iomode adxirs chr$(13)+chr$(10) Using [YF]
  Wrseq "xdim = " - num$(XDIM)- "ydim = "-num$(dim(YFIELDS,2)) Using [YF]

  For I = 0 To XDIM
    Wrseq "New item:"  Using [YF]
    For J = 0 To YDIM
      Wrseq num$(I) + "," + num$(J) - "-" - YCOL_KEYS(J) + ":" - YFIELDS(I,J) Using [YF]
    Next J
  Next
  Openo Using [YF]

End

##################################################################################################
#                             Funzioni Utilità Gestione MULTIMEDIA
##################################################################################################
#**
#* Funzione che ritorna il json con tutte le azioni multimediali abilitate(es: email, phone, position, link)
#*
#* @param YMMEDIAENABLED Matrice con tutte le azioni-media abilitate
#*!

Funprog YGETMULTIMEDIA(YMMEDIAENABLED)

  Value Char YMMEDIAENABLED()(,)

  Local Char YRESULT(250)
  Local Integer YI,YMMEDIANUM: YMMEDIANUM = dim(YMMEDIAENABLED,1)  #N° delle azioni (media) previsti

  Local Char YACTIONS(250)(YMMEDIANUM)
  Local Char YMMEDIA_ITEM(250)(2)

  #Append YJSONRESULT, func YJSONSERIALIZE.GET_OPENCURLYBRACKET()     #{

  #ottengo oggetti per : email, phone, position, link...
  For YI=0 To YMMEDIANUM-1
    YMMEDIA_ITEM(0) = func YJSONSERIALIZE.GET_STR("type",func YGETMEDIATYPE(YMMEDIAENABLED(YI,0)), 1)
    YMMEDIA_ITEM(1) = func YJSONSERIALIZE.GET_STR("value",YMMEDIAENABLED(YI,1), 1)
    YACTIONS(YI) = func YJSONSERIALIZE.GET_STROBJ(AVOID.ACHAR, YMMEDIA_ITEM, 1, 1)
  Next

  YRESULT = func YJSONSERIALIZE.GET_STRARRAY_FROM_STRARRAY("actions", YACTIONS, 1) #actions : [{},..,{}]
  #Append YJSONRESULT, func YJSONSERIALIZE.GET_CLOSECURLYBRACKET()    #}

End YRESULT

###################################################################################################################
#**
#* Funzione che ritorna il valore dell'"Enum" associato al tipo di media
#*
#* @param YMEDIATYPE
#*!

Funprog YGETMEDIATYPE(YMEDIATYPE)

  Value Char YMEDIATYPE
  Local Char YMEDIA (10)

  Case YMEDIATYPE
    When "0"
      YMEDIA = "email"
    When "1"
      YMEDIA = "phone"
    When "2"
      YMEDIA = "position"
    When "3"
      YMEDIA = "link"
    When Default
  Endcase
End YMEDIA

#########################################################################################

$YMEDIACONST

  Const Integer CONST_EMAIL: CONST_EMAIL = 0
  Const Integer CONST_PHONE: CONST_PHONE = 1
  Const Integer CONST_POSITION: CONST_POSITION = 2
  Const Integer CONST_LINK: CONST_LINK = 3
Return

##################################################################################################################
#                                                    UTILITà PER ANAGRAFICA X3
##################################################################################################################

#**
#* Metodo per estrarre codice Sottoprogramma (X3) dato codice Azione in anagrafica
#*
#* @param YACTION Codice azione
#*!

Funprog YGET_SUBPRGNAME(YACTION)

  Value Char YACTION
  Local Char YSUBPRGNAME(30)
  Local File ACTION [F:YACT]

  Columns [F:YACT](SUBPRG)
  Read [F:YACT]ACTION = YACTION
  If(!fstat)
    YSUBPRGNAME = [F:YACT]SUBPRG
  Endif

End YSUBPRGNAME

######################################################################################
#**
#* Metodo per determinare la dimensione di un Parametro di un Sottoprogramma di X3
#*
#* @param YSUBPRGNAME Codice del Sottoprogramma di X3
#* @param YFIELDCODE  Codice del parametro del Sottoprogramma
#*!
Funprog YGET_DIMEPARAM(YSUBPRGNAME, YFIELDCODE)

  Value Char YSUBPRGNAME
  Value Char YFIELDCODE
  Local Integer YDIME
  Local File ASUBPROGD [F:YASP]

  Filter [F:YASP] Where ([F:YASP]SUBPRG = YSUBPRGNAME & [F:YASP]PARAM = YFIELDCODE)
  Columns [F:YASP](DIME)
  Read [F:YASP] First
  YDIME = [F:YASP]DIME
  Filter [F:YASP]

End YDIME
**********
7,"TRT","YAX3MUTILS",""
2,"TRT","YJSONDESERIALIZE",""
#<AdxTL>@(#)0.0.0.0 $Revision$
#################################################################################################################################
#                                             LIBRERIA PER DESERIALIZZAZIONE
#################################################################################################################################

Subprog JSONPARSE(YBODY, YRESPONSE)
  Variable Clbfile YBODY
  Variable Char YRESPONSE()(,)

  Local Integer PPROGRESS:PPROGRESS=1
  Local Char WERRMSG(100)
  Local Char YELEMENTTREE(250)(0..func F_DEEPLEVEL() )
  Local Char YELECOUNTER(250)(func F_MAXELEMENT(), func F_DEEPLEVEL() + 1)

  Call JSONPARSE_CLB(YBODY,PPROGRESS,YELEMENTTREE,YELECOUNTER,WERRMSG,YRESPONSE)
End

############################################################################################################
Subprog JSONPARSE_CLB(YDOC, PPROGRESS, YELEMENTTREE, YELECOUNTER, WERRMSG, YRESPONSE)
  Variable Clbfile YDOC
  Value Integer PPROGRESS
  Variable Char YELEMENTTREE
  Variable Char YELECOUNTER
  Variable Char WERRMSG
  Variable Char YRESPONSE()(,)

  Local Integer I
  Local Char YCH(1)
  Local Integer YCOUNT, YSTOP

  Local Char YA_STATUS(20)
  Local Char YCURR_ELEMENT_NAME(50)
  Local Char YCURR_ELEMENT_VALUE(250)
  Local Integer INTERRUPT

  Local Integer IN_STRING
  Local Char YPREV_CH(1)

  If PPROGRESS = [V]CST_AYES Then
    Call OUVRE_BOITE("JSON Parsing ", len(YDOC)) From GESECRAN : # Set Progress Bar
    Call SET_BOITE("JSON Parsing", len(YDOC)) From GESECRAN
  Endif

  IN_STRING = 0
  Raz YPREV_CH

  For I = 1 To len(YDOC)
    YCH = mid$(YDOC,I,1)

    # Gestione delle stringhe e degli escape
    If YCH = '"' and YPREV_CH <> '\' Then
      IN_STRING = not IN_STRING
      If IN_STRING Then
        If YA_STATUS = "" Then
          YA_STATUS = "ELEMENT_NAME"
        Endif
      Elsif YA_STATUS = "ELEMENT_NAME" Then
        Call APPEND_T0_TREEELEMENT(YELEMENTTREE, YELECOUNTER, YCURR_ELEMENT_NAME, YCOUNT)
        YA_STATUS = ""
      Endif
    Endif

    If not IN_STRING Then
      If YCH = "{" Then
        Raz [L]YCURR_ELEMENT_VALUE
        Raz YCURR_ELEMENT_NAME
        YA_STATUS = ""
      Elsif YCH = ":" Then
        YA_STATUS = "ELEMENT_VALUE"
      Elsif YCH = "," Then
        If YCURR_ELEMENT_NAME <> "" Then
          Raz YCOUNT
          YCOUNT = func COUNT_ELEMENT(YELEMENTTREE, YELECOUNTER)
          Call RAISE_END_ELEMENT(YELEMENTTREE, YCURR_ELEMENT_NAME, YCURR_ELEMENT_VALUE, YCOUNT, YSTOP, YRESPONSE )
          If YSTOP = 1 Then
              Break
          Endif
          Call REMOVE_FROM_TREEELEMENT(YELEMENTTREE, YCURR_ELEMENT_NAME, [V]CST_ANO, WERRMSG)
          If WERRMSG <> "" Then Call ERREUR(WERRMSG) From GESECRAN : Endif
          YA_STATUS = ""
          Raz YCURR_ELEMENT_VALUE
          Raz YCURR_ELEMENT_NAME
        Endif
      Elsif YCH = "}" and YA_STATUS = "ELEMENT_VALUE" Then
        If YCURR_ELEMENT_NAME <> "" Then
          Raz YCOUNT
          YCOUNT = func COUNT_ELEMENT(YELEMENTTREE, YELECOUNTER)
          Call RAISE_END_ELEMENT(YELEMENTTREE, YCURR_ELEMENT_NAME, YCURR_ELEMENT_VALUE, YCOUNT, YSTOP, YRESPONSE )
          If YSTOP = 1 Then
              Break
          Endif
          Call REMOVE_FROM_TREEELEMENT(YELEMENTTREE, YCURR_ELEMENT_NAME, [V]CST_AYES, WERRMSG)
          If [L]WERRMSG <> "" Then Call ERREUR([L]WERRMSG) From GESECRAN : Endif
        Else
          Call REMOVE_LAST_TREEELEMENT(YELEMENTTREE, WERRMSG)
          If [L]WERRMSG <> "" Then Call ERREUR([L]WERRMSG) From GESECRAN : Endif
        Endif

        YA_STATUS = ""
        Raz [L]YCURR_ELEMENT_VALUE
        Raz YCURR_ELEMENT_NAME
      Elsif YCH = "}" Then
        Call REMOVE_LAST_TREEELEMENT(YELEMENTTREE, WERRMSG)
        If [L]WERRMSG <> "" Then Call ERREUR([L]WERRMSG) From GESECRAN : Endif
      Elsif YCH = "[" Then
      Elsif YCH = "]" and YA_STATUS = "" Then
        Call REMOVE_LAST_TREEELEMENT(YELEMENTTREE, WERRMSG)
        If [L]WERRMSG <> "" Then Call ERREUR([L]WERRMSG) From GESECRAN : Endif
      Else
        If YA_STATUS = "ELEMENT_NAME" Then
          YCURR_ELEMENT_NAME += YCH
        Elsif YA_STATUS = "ELEMENT_VALUE" Then
          YCURR_ELEMENT_VALUE += YCH
        Endif
      Endif
    Else
      If YA_STATUS = "ELEMENT_NAME" Then
        YCURR_ELEMENT_NAME += YCH
      Elsif YA_STATUS = "ELEMENT_VALUE" Then
        YCURR_ELEMENT_VALUE += YCH
      Endif
    Endif

    YPREV_CH = YCH

    If PPROGRESS = [V]CST_AYES Then
      Call AFF_BOITE("Element: "-num$(YCURR_ELEMENT_NAME),I,INTERRUPT) From GESECRAN
    Endif
    If [L]INTERRUPT = 1 Then Break : Endif
  Next

  If IN_STRING Then
    WERRMSG = "JSON malformato: stringa non chiusa correttamente"
    Call ERREUR(WERRMSG) From GESECRAN
  Endif

  If PPROGRESS = [V]CST_AYES Then
    Call FERME_BOITE From GESECRAN
  Endif

End

##################################################################################

Subprog RAISE_END_ELEMENT(PURI, PELEMENT, PVALUE_CLB, PCOUNT, PSTOP, YRESPONSE)
  Value Char PURI()
  Value Char PELEMENT
  Variable Clbfile PVALUE_CLB
  Value Integer PCOUNT
  Variable Integer PSTOP
  Variable Char YRESPONSE()(,)

  Local Char YEVENT(20) : YEVENT = "END_ELEMENT"
  Local Char PVALUE(254) : PVALUE = PVALUE_CLB

  # Non rimuovere le virgolette se sono presenti originariamente
  If left$(PVALUE_CLB, 1) = '"' and right$(PVALUE_CLB, 1) = '"' Then
    PVALUE = PVALUE_CLB
  Else
    PVALUE = ctrans(PVALUE_CLB, chr$(34), "")
  Endif

  Case YEVENT
    When "END_ELEMENT" : Gosub END_ELEMENT
  Endcase
End

################################################################################

$END_ELEMENT

  Local Char YURITXT(250) : YURITXT = ""
  Local Char YFULLPATH(250) : YFULLPATH = ""
  Local Integer I : I = 0

  While PURI(I) <> ""
    If YFULLPATH <> "" Then YFULLPATH += "." : Endif
    YFULLPATH += PURI(I)
    I += 1
  Wend
  If YFULLPATH <> "" Then YFULLPATH += "." : Endif
  YFULLPATH += PELEMENT

  # Rimuovi le virgolette dalla chiave finale
  YFULLPATH = ctrans(YFULLPATH, chr$(34), "")

  # Trova il prossimo indice disponibile in YRESPONSE
  I = 0
  While YRESPONSE(I, 0) <> ""
    I += 1
  Wend

  # Memorizza il percorso e il valore
  YRESPONSE(I, 0) = vireblc(YFULLPATH, 2)
  YRESPONSE(I, 1) = vireblc(unescJson(PVALUE), 2)
  #YRESPONSE(I, 1) = vireblc(PVALUE, 2)

Return

#######################################################################################################################

Subprog APPEND_T0_TREEELEMENT(WELEMENTTREE, WELECOUNTER, YCURRELEMENT, WCOUNT)

    Variable Char WELEMENTTREE
    Variable Char WELECOUNTER
    Value Char YCURRELEMENT
    Variable Integer WCOUNT

    Local Integer I: I = -1
    Repeat
        I+=1
    Until vireblc(WELEMENTTREE(I),4) = ""
    WELEMENTTREE(I) = YCURRELEMENT
    Call UPDATECOUNTER(WELEMENTTREE, WELECOUNTER, WCOUNT)
End

######################################################################################################

Subprog REMOVE_FROM_TREEELEMENT(WELEMENTTREE, YCURRELEMENT, YANDPARENT, WERRMSG)

    Variable Char WELEMENTTREE
    Value Char YCURRELEMENT
    Value Integer YANDPARENT
    Variable Char WERRMSG

    Local Integer I: I = 0
    I = func LASTINDEX(WELEMENTTREE)

    If WELEMENTTREE(I) = YCURRELEMENT Then
      Raz WELEMENTTREE(I)
      If YANDPARENT = [V]CST_AYES and I > 0 Then
        Raz WELEMENTTREE(I-1)
      Endif
    Else
      WERRMSG = "Element '" + YCURRELEMENT + "' not closed correctly"
    Endif
End

#############################################################################################################

Subprog REMOVE_LAST_TREEELEMENT(WELEMENTTREE, WERRMSG)

  Variable Char WELEMENTTREE
  Variable Char WERRMSG

  Local Integer I: I = 0
  I = func LASTINDEX(WELEMENTTREE)
  Raz WELEMENTTREE(I)
End

########################################################################################################

Subprog UPDATECOUNTER(WELEMENTTREE, WELECOUNTER, WCOUNT)

    Variable Char WELEMENTTREE
    Variable Char WELECOUNTER
    Variable Integer WCOUNT

    Local Integer I: I = 0
    Local Integer J
    Local Char CURRELEMENT(250)
    Local Shortint TROVATO : Raz TROVATO
    While WELECOUNTER(I,0)<>""

        TROVATO =1
        J = 0
        While WELEMENTTREE(J) <> ""
            If WELEMENTTREE(J) <> WELECOUNTER(I, J) Then
                Raz TROVATO
                Break
            Endif
            J+=1
            If J >= dim(WELEMENTTREE)  Then
                Break
            Endif

        Wend
        If TROVATO = 1 Then
            If WELECOUNTER(I, J) = "" Then
                WCOUNT = val(WELECOUNTER(I, func F_DEEPLEVEL())) + 1
                WELECOUNTER(I, func F_DEEPLEVEL()) = num$(WCOUNT)
                End
            Else

            Endif
        Endif
        I+=1
    Wend

    If TROVATO <> 1 Then
        J=0
        While WELEMENTTREE(J) <> ""
            WELECOUNTER(I, J) = WELEMENTTREE(J) #CURRELEMENT
            J+=1
        Wend
        WCOUNT = 1
        WELECOUNTER(I,15) = num$(WCOUNT)
    Endif
End

#########################################################################################################

Funprog COUNT_ELEMENT(WELEMENTTREE, WELECOUNTER)

    Variable Char WELEMENTTREE
    Variable Char WELECOUNTER
    Local Integer I: I = 0
    Local Integer J
    Local Integer RESULT : RESULT = 0
    Local Char CURRELEMENT(250)
    Local Shortint TROVATO : Raz TROVATO
    Repeat
        TROVATO =1
        J = 0
        While WELEMENTTREE(J) <> ""
            If WELEMENTTREE(J) <> WELECOUNTER(I, J) Then
                Raz TROVATO
                Break
            Endif
            J+=1
            If J >= dim(WELEMENTTREE)  Then
                Break
            Endif

        Wend
        If TROVATO = 1 Then
            If WELECOUNTER(I, J) = "" Then
                RESULT = val(WELECOUNTER(I,15))

            Endif
        Endif
        I+=1
    Until WELECOUNTER(I,0) = "" | RESULT > 0

End RESULT

#############################################################################################

Funprog LASTINDEX(WELEMENTTREE)
  Value Char WELEMENTTREE
  Local Integer I: I = 0
  While WELEMENTTREE(I) <> ""
    I+=1
  Wend
  If I >= 1 Then
    I -= 1
  Endif
End I

#############################################################################################

#**
#* max sublevels of elemets managed
#*!
Funprog F_DEEPLEVEL()
End 15

#############################################################################################

#**
#* max numbers of different elements managed
#*!
Funprog F_MAXELEMENT()
End 1500

######################################################################################################################################

$YPARSING
    Case YEVENT
        When "END_ELEMENT"      : Gosub END_ELEMENT
    Endcase
Return

#**
#* YPATH è il path complessivo di una chiave json se abbiamo un elemento code in root e
#* uno in un oggetto child con la stessa chiave nel primo caso dobbiamo utilizzare "code.code"
#* nel secondo "address.code" <br /><br />
#* Call JSONPARSE_CLB(YBODY, AVOID.ACHAR, PPROGRESS, YELEMENTTREE, YELECOUNTER, WERRMSG, YJSON_ARR) From YJSONDESERIALIZE
#* Local Char YAPIKEY(36) : YAPIKEY = func YJSONDESERIALIZE.GET_JSON_VALUE(YJSON_ARR, "code.code")
#* Local Char YCTY(10) : YCTY = func YJSONDESERIALIZE.GET_JSON_VALUE(YJSON_ARR, "address.code.code")
#* {
#*  "code": "Pippo",
#*  "address":{
#*    "code":"RO",
#*    "name":"Via Rossi, 89",
#*    "city":"Ravenna"
#*  }
#* }
#* Stampando YRESPONSE sopra si può vedere l'intero path di ogni chiave del json
#*!
Funprog GET_JSON_VALUE(YKEY_VALUE, YPATH)
  Variable Char YKEY_VALUE()(,)
  Value Char YPATH

  Local Integer I : I = 0
  While vireblc(YKEY_VALUE(I, 0), 2) <> ""
    If YKEY_VALUE(I, 0) = YPATH Then
      End YKEY_VALUE(I, 1)
    Endif
    I += 1
  Wend
End ""  # Ritorna stringa vuota se non trovato

#########################################################################################################

#**
#* Metodo per estrarre chiave da un Percorso (ottenuto da parsing di un json e suddiviso dal Separatore adottato)
#* (da un percorso con formato : "A.B.C.D" estraggo "D")
#*
#* @param YPATH Percorso
#* @param YPATH_SEP  Separatore adottatto nel Percorso
#*!

Funprog GET_JSON_KEY(YPATH)

 Value Char YPATH
 Local Integer YINDEX, YI  #YINDEX = posizione ultimo separatore di YPATH trovato
 Local Char YLEAF(15)

 For YI =0 To len(YPATH) - 1
  If(xgetchar(YPATH,YI) = ".") #il separatore utilizzato dalla libreia è il punto
     YINDEX=YI
  Endif
 Next
 YLEAF = vireblc(right$(YPATH,YINDEX+1),2) #estraggo la sottostringa da ultimo separatore in poi

End YLEAF

#########################################################################################################
#**
#* Parametrizzazione Costanti legate a proprietà campi
#*!

$YSET_COLKEYS

  Const Integer YCOL_NAME : YCOL_NAME = 0
  Const Integer YCOL_TYPE : YCOL_TYPE = 1
  Const Integer YCOL_VALUE : YCOL_VALUE = 2
  Const Integer YCOL_VALID : YCOL_VALID = 3
  Const Integer YCOL_MESSAGE : YCOL_MESSAGE = 4
  Const Integer YCOL_FOCUS : YCOL_FOCUS = 5
  Const Integer YCOL_VIS : YCOL_VIS = 6
  Const Integer YCOL_ENA : YCOL_ENA = 7
  Const Integer YCOL_DETT : YCOL_DETT = 8   #colonna che accoglie "" o "1" (se campo di dett)
  Const Integer YCOL_ROW : YCOL_ROW = 9     #colonna che accoglie "0" o "1" (se riga corrente)

  Local Char YCOL_KEYS(20)(10)                                      #array per chiavi colonne

  YCOL_KEYS(YCOL_NAME)= "fieldName"
  YCOL_KEYS(YCOL_TYPE)= "fieldType"
  YCOL_KEYS(YCOL_VALUE)= "fieldValue"
  YCOL_KEYS(YCOL_VALID)= "fieldValid"
  YCOL_KEYS(YCOL_MESSAGE)= "fieldMessage"
  YCOL_KEYS(YCOL_FOCUS)= "fieldFocus"
  YCOL_KEYS(YCOL_VIS)= "fieldVisible"
  YCOL_KEYS(YCOL_ENA)= "fieldEnter"
  YCOL_KEYS(YCOL_DETT)= "fieldRiquadro"
  YCOL_KEYS(YCOL_ROW)= "currentRow"

Return

########################################################################################################
#**
#* Metodo per estrarre da JSON i campi e loro proprietà mettendoli in una matrice, considerando la chiave "currentRow" per campi di dettaglio
#*
#* @param YBODY Json del body come Clob
#* @param YCURRENTUSER Utente loggato
#* @param YFIELDS Matrice dei campi
#*!

Subprog YJSON2ARRAY_OLD(YBODY, YCURRENTUSER, YFIELDS)

  Value Clbfile YBODY
  Variable Char YCURRENTUSER
  Variable Char YFIELDS()(,)

  Local Clbfile YDOC(2):YDOC = YBODY
  Local Integer PPROGRESS:PPROGRESS=1
  Local Char WERRMSG(100)
  Local Char YELEMENTTREE(250)(0..func F_DEEPLEVEL() )
  Local Char YELECOUNTER(250)(func F_MAXELEMENT(), func F_DEEPLEVEL() + 1)
  Local Char YRESPONSE(250)(15000, 2) #2600

  Local Integer YI,YJ: YJ=-1
  Local Char YPATH(250),YVALUE(250),YJSON_KEY(20),YTURN_LEAF(20)

  Local Char YTFIELD(11): YTFIELD = AVOID.ACHAR                     #nome 1° campo di dett
  Local Integer YRI : YRI = -1
  Local Integer YCURROW : YCURROW = -1

  Call JSONPARSE_CLB(YDOC,PPROGRESS,YELEMENTTREE,YELECOUNTER,WERRMSG,YRESPONSE)
  Gosub YSET_COLKEYS

  Local Char YFIRSTKEY(100)

  For YI = 0 To func YUTILS.COUNT_MULTI(YRESPONSE) - 1    #ciclo su tutti i path estratti
    YPATH = YRESPONSE(YI,0)
    YVALUE = YRESPONSE(YI,1)
    YJSON_KEY = func GET_JSON_KEY(YPATH)

    If(YJSON_KEY = "currentUser")
      YCURRENTUSER = YVALUE
    Elsif(find(YJSON_KEY, YCOL_KEYS) > 0)

      # ricavo valore currentRow
      If(YJSON_KEY = YCOL_KEYS(YCOL_ROW))
        YCURROW = val(YVALUE)   # QUI : yvalue : intero
      Endif

      # ricavo la prima chiave che ci manda ax3m in yax3mresp
      If (YJ < 0 & (YJSON_KEY <> "currentRow"))
        YFIRSTKEY = YJSON_KEY
      Endif

      If(YJSON_KEY = YFIRSTKEY) #nuovo campo
        YJ+=1
      Endif

      #Salvo Nome 1° campo di Dett(YCURROW: già stata valorizzata)
      If(YTFIELD = AVOID.ACHAR & YCURROW > -1 & YJSON_KEY = YCOL_KEYS(YCOL_NAME))
        YTFIELD = YVALUE
      Endif

      #riempio le colonne con idx = 0..9
      If YJ >= 0
        Case YJSON_KEY
          When YCOL_KEYS(YCOL_NAME) #0
            YFIELDS(YJ,YCOL_NAME) = YVALUE
            If(YVALUE = YTFIELD)
              YRI += 1
            Endif
            YFIELDS(YJ,YCOL_ROW)= func YUTILS.STR_IIF((YRI = YCURROW & YCURROW >= 0), "1", "0")   #9 (qui valorizzata col idx=9)#contatore= currow, "1"

          When YCOL_KEYS(YCOL_TYPE) #1
            YFIELDS(YJ,YCOL_TYPE) = YVALUE

          When YCOL_KEYS(YCOL_VALUE) #2
            YFIELDS(YJ,YCOL_VALUE) = YVALUE

          When YCOL_KEYS(YCOL_VALID) #3
            #YFIELDS(YJ,YCOL_VALID) = func YUTILS.STR_IIF(YVALUE = "true", "1", "0")
            YFIELDS(YJ,YCOL_VALID) = func YUTILS.STR_IIF(YVALUE = "true", "0", "1") #qui YVALUE (da json) = "true"/"false"

          When YCOL_KEYS(YCOL_MESSAGE) #4
            YFIELDS(YJ,YCOL_MESSAGE) = YVALUE

          When YCOL_KEYS(YCOL_FOCUS) #5
            YFIELDS(YJ,YCOL_FOCUS) = func YUTILS.STR_IIF(YVALUE ="true","1","0") #qui YVALUE (da json) = "true"/"false"

          When YCOL_KEYS(YCOL_VIS) #6
            YFIELDS(YJ,YCOL_VIS) = func YUTILS.STR_IIF(YVALUE ="true","1","0") #qui YVALUE (da json) = "true"/"false"

          When YCOL_KEYS(YCOL_ENA) #7
            YFIELDS(YJ,YCOL_ENA) = func YUTILS.STR_IIF(YVALUE ="true","1","0") #qui YVALUE (da json) = "true"/"false"

          When YCOL_KEYS(YCOL_DETT) #8
            YFIELDS(YJ,YCOL_DETT) = YVALUE

          When Default
        Endcase
      Else
        #Call ECR_TRACE("Errore:" - YJSON_KEY - ";" - YPATH - ";" - YVALUE, 0) From GESECRAN
      Endif
    Endif
  Next

End

########################################################################################################
#**
#* Metodo per estrarre da JSON i campi e loro proprietà mettendoli in una matrice, considerando la chiave "currentRow" per campi di dettaglio.
#* NOTA: utilizzato New4GL, Prestare attenzione alla Versione di X3 in uso, se non supportata utilizzare YJSONTOARRAY_OLD
#*
#* @param YBODY Json del body come Clob
#* @param YCURRENTUSER Utente loggato
#* @param YFIELDS Matrice dei campi
#*!

Subprog YJSON2ARRAY(YBODY, YCURRENTUSER, YFIELDS)
  Value Clbfile YBODY
  Variable Char YCURRENTUSER
  Variable Char YFIELDS()(,)

  Local Integer I, J, K, ROW, RIQUADROROW, CURRENTROW
  Local Char BASEPATH(250), BASEROW(250),
&            FN(64), FV(250), FM(250), S_TMP(32),
&            ACTION_BASE_SLASH(60), ACTION_BASE_JSON(60),
&            ROWS_PATH(120), ROW_J_PATH_SLASH(120), ROW_J_PATH_JSON(120), CURRENTROW_PATH(120)

  # inizializzazioni
  I = 0 : J = 0 : K = 0
  ROW = 0
  RIQUADROROW = 0
  CURRENTROW = -1

  # Create the object
  Local Instance OBJ Using OBJECT
  PARSEINSTANCE OBJ With YBODY

  # Leggo l'utente corrente
  YCURRENTUSER = OBJ.SELECT$("$.currentUser")

  # Definisci i path base
  ACTION_BASE_SLASH = "/actions/0/details/"
  ACTION_BASE_JSON  = "$.actions[0].details["

  While OBJ.CONTAINS$(ACTION_BASE_SLASH + num$(I)) = 1
    BASEPATH = ACTION_BASE_JSON + num$(I) + "]"
    SLASHBASE = ACTION_BASE_SLASH + num$(I)
    CURRENTROW = -1

    # Path per currentRow (uso SLASH per CONTAINS$, JSON per SELECT$)
    CURRENTROW_PATH = SLASHBASE + "/currentRow"
    If OBJ.CONTAINS$(CURRENTROW_PATH) = 1
      S_TMP = OBJ.SELECT$(BASEPATH + ".currentRow")
      If S_TMP <> ""
        CURRENTROW = val(S_TMP)
      Endif
    Endif

    # Path per rows
    ROWS_PATH = SLASHBASE + "/rows"
    If OBJ.CONTAINS$(ROWS_PATH) = 1    # DETTAGLIO (ci sono righe)
        J = 0
        While OBJ.CONTAINS$(ROWS_PATH + "/" + num$(J)) = 1
          ROW_J_PATH_SLASH = ROWS_PATH + "/" + num$(J)
          ROW_J_PATH_JSON  = BASEPATH + ".rows[" + num$(J) + "]"

          K = 0
          While OBJ.CONTAINS$(ROW_J_PATH_SLASH + "/" + num$(K)) = 1
            BASEROW = ROW_J_PATH_JSON + "[" + num$(K) + "]"

            # Estrai i campi
            FN = OBJ.SELECT$(BASEROW + ".fieldName")
            FV = OBJ.SELECT$(BASEROW + ".fieldValue")
            FM = OBJ.SELECT$(BASEROW + ".fieldMessage")

            # Leggi i booleani come stringhe e convertili esplicitamente
            S_TMP = OBJ.SELECT$(BASEROW + ".fieldValid")
            If tolower(S_TMP) = "true"
              YFIELDS(ROW,3) = "1"
            Else
              YFIELDS(ROW,3) = "0"
            Endif

            S_TMP = OBJ.SELECT$(BASEROW + ".fieldFocus")
            If tolower(S_TMP) = "true"
              YFIELDS(ROW,5) = "1"
            Else
              YFIELDS(ROW,5) = "0"
            Endif

            S_TMP = OBJ.SELECT$(BASEROW + ".fieldVisible")
            If tolower(S_TMP) = "true"
              YFIELDS(ROW,6) = "1"
            Else
              YFIELDS(ROW,6) = "0"
            Endif

            S_TMP = OBJ.SELECT$(BASEROW + ".fieldEnter")
            If tolower(S_TMP) = "true"
              YFIELDS(ROW,7) = "1"
            Else
              YFIELDS(ROW,7) = "0"
            Endif

            # Popola la matrice
            YFIELDS(ROW,0) = FN
            YFIELDS(ROW,1) = AVOID.ACHAR
            YFIELDS(ROW,2) = FV
            YFIELDS(ROW,4) = FM
            YFIELDS(ROW,8) = "1"
            YFIELDS(ROW,9) = func YUTILS.STR_IIF(RIQUADROROW = CURRENTROW, "1", "0")

            ROW += 1
            K += 1
          Wend

          # Incrementa RIQUADROROW UNA SOLA VOLTA per ogni riga J
          RIQUADROROW += 1
          J += 1
        Wend

    Else   # TESTATA (detail singolo)
      FN = OBJ.SELECT$(BASEPATH + ".fieldName")
      FV = OBJ.SELECT$(BASEPATH + ".fieldValue")
      FM = OBJ.SELECT$(BASEPATH + ".fieldMessage")

      # Qui usare BASEPATH (non BASEROW) e convertire booleani correttamente
      S_TMP = OBJ.SELECT$(BASEPATH + ".fieldValid")
      If tolower(S_TMP) = "true"
        YFIELDS(ROW,3) = "1"
      Else
        YFIELDS(ROW,3) = "0"
      Endif

      S_TMP = OBJ.SELECT$(BASEPATH + ".fieldFocus")
      If tolower(S_TMP) = "true"
        YFIELDS(ROW,5) = "1"
      Else
        YFIELDS(ROW,5) = "0"
      Endif

      S_TMP = OBJ.SELECT$(BASEPATH + ".fieldVisible")
      If tolower(S_TMP) = "true"
        YFIELDS(ROW,6) = "1"
      Else
        YFIELDS(ROW,6) = "0"
      Endif

      S_TMP = OBJ.SELECT$(BASEPATH + ".fieldEnter")
      If tolower(S_TMP) = "true"
        YFIELDS(ROW,7) = "1"
      Else
        YFIELDS(ROW,7) = "0"
      Endif

      YFIELDS(ROW,0) = FN
      YFIELDS(ROW,1) = AVOID.ACHAR
      YFIELDS(ROW,2) = FV
      YFIELDS(ROW,4) = FM
      YFIELDS(ROW,8) = "0"
      YFIELDS(ROW,9) = "0"

      ROW += 1
    Endif

    I += 1
  Wend

  FreeGroup OBJ
End

#######################################################################################################################################
############################ debug ####################################################################################################

$YAX3MOB_PRINT_YRESPONSE

  Local Integer XDIM : XDIM = func YUTILS.COUNT_MULTI(YRESPONSE) - 1
  Local Integer YDIM : YDIM = dim(YRESPONSE,2)-1
  Local Integer I, J

  Local Char YFIL(250)
  YFIL = filpath("tmp", "print_yRESPONSE_des_"+"_"+num$(int(rnd(10000)))+"_"+date$, "json")
  Openo YFIL Using [YF]
  Iomode adxium GUTF8 Using [YF]
  Iomode adxirs chr$(13)+chr$(10) Using [YF]
  Wrseq "xdim = " - num$(XDIM)- "ydim = "-num$(dim(YRESPONSE,2)) Using [YF]

  For I = 0 To XDIM
    Wrseq "New item:"  Using [YF]
    For J = 0 To YDIM
      Wrseq num$(I) - ":"- "value"-":" - YRESPONSE(I,J) Using [YF]
    Next J
  Next
  Openo Using [YF]

Return
**********
7,"TRT","YJSONDESERIALIZE",""
2,"TRT","YJSONSERIALIZE",""
#<AdxTL>@(#)0.0.0.0 $Revision$
#######################################################################################################################
#                                                   LIBRERIA PER SERIALIZZAZIONE
#######################################################################################################################

##Caratteri json
Funprog GET_OPENCURLYBRACKET()
End chr$(123) #{

Funprog GET_CLOSECURLYBRACKET()
End chr$(125) #}

Funprog GET_OPENSQUAREBRACKET()
End chr$(91) #[

Funprog GET_CLOSESQUAREBRACKET()
End chr$(93) #]

Funprog GET_SEPARATOR() #,
End chr$(44)

Funprog GET_COLON() #:
End chr$(58)
##fine caratteri json

###########################################################################################################
##Funzioni di utilità
###########################################################################################################

Funprog GET_OPENCURLYBRACKET_ARRAY() #: [
End + chr$(58) + chr$(32) + chr$(91)

Funprog GET_OPENSQUAREBRACKET_KEY(YKEY)
  Value Char YKEY
End func GET_STRVALUE(YKEY) + func GET_OPENCURLYBRACKET_ARRAY()

Funprog GET_KEY(YKEY)
  Value Char YKEY
End chr$(34) + YKEY + chr$(34) + chr$(58) + chr$(32) # "YKEY":

Funprog GET_STRVALUE(YVALUE)
  Value Char YVALUE
End chr$(34) + escJson(YVALUE) + chr$(34) #"YVALUE"

#Fine funzioni utilita

#################################################################################################################
#chiave valore
#################################################################################################################

#**
#* Return YKEY: YVALUE (intero)
#*
#* @param YKEY Chiave
#* @param YVALUE Valore (tipo intero)
#* @param WITHSEP booleano per inserimento separatore (= 0 : inserimento separatore, =1 : no inserimento)
#*!
Funprog GET_INT(YKEY, YVALUE, WITHSEP)
  Value Char YKEY
  Value Integer YVALUE
  Value Integer WITHSEP
  Local Char YRESULT(250)

  YRESULT = func GET_KEY(YKEY) +  num$(YVALUE)
  If WITHSEP = 0
    YRESULT+= func GET_SEPARATOR()
  Endif

End YRESULT

#############################################################################################################
#chiave valore
#**
#* Return YKEY: YVALUE (decimale)
#*
#* @param YKEY Chiave
#* @param YVALUE Valore (tipo decimale)
#* @param WITHSEP booleano per inserimento separatore (= 0 : inserimento separatore, =1 : no inserimento)
#*!
Funprog GET_DECIMAL(YKEY, YVALUE, WITHSEP)
  Value Char YKEY
  Value Decimal YVALUE
  Value Integer WITHSEP
  Local Char YRESULT(250)

  YRESULT = func GET_KEY(YKEY) +  num$(YVALUE)
  If WITHSEP = 0
    YRESULT+= func GET_SEPARATOR()
  Endif

End YRESULT

###########################################################################################################
#**
#* Return YKEY: YVALUE (booleano)
#*
#* @param YKEY Chiave
#* @param YVALUE Valore (tipo intero visto come booleano) (1--> true, 0 --> false)
#* @param WITHSEP booleano per inserimento separatore (= 0 : inserimento separatore, =1 : no inserimento)
#*!
Funprog GET_BOOL(YKEY, YVALUE, WITHSEP)
  Value Char YKEY
  Value Integer YVALUE
  Value Integer WITHSEP
  Local Char YRESULT(250)

  YRESULT = func GET_KEY(YKEY) + func YUTILS.IIF(YVALUE = 1, "true", "false")
  If WITHSEP = 0
    YRESULT+= func GET_SEPARATOR()
  Endif

End YRESULT

###########################################################################################################
#**
#* Return YKEY: YVALUE (stringa)
#*
#* @param YKEY Chiave
#* @param YVALUE Valore (tipo stringa)
#* @param WITHSEP booleano per inserimento separatore (= 0 : inserimento separatore, =1 : no inserimento)
#*!
Funprog GET_STR(YKEY, YVALUE, WITHSEP)
  Value Char YKEY
  Value Char YVALUE
  Value Integer WITHSEP
  Local Char YRESULT(250)

  YRESULT = func GET_KEY(YKEY) + func GET_STRVALUE(YVALUE)
  If WITHSEP = 0
    YRESULT+= func GET_SEPARATOR()
  Endif

End YRESULT

##########################################################################################################
#Uguale a GET_STR ma restituisce una stringa con len > 250
#**
#* Return YKEY: YVALUE (stringa len >250)
#*
#* @param YKEY Chiave
#* @param YVALUE Valore (tipo stringa len >250)
#* @param WITHSEP booleano per inserimento separatore (= 0 : inserimento separatore, =1 : no inserimento)
#*!
Funprog GET_CLB(YKEY, YVALUE, WITHSEP)
  Value Char YKEY
  Value Char YVALUE
  Value Integer WITHSEP
  Local Clbfile YRESULT(250)
#TODO: sistema clbfile YRESULT(250)
  YRESULT = func GET_KEY(YKEY) + func GET_STRVALUE(YVALUE)
  If WITHSEP = 0
    YRESULT+= func GET_SEPARATOR()
  Endif

End YRESULT

#######################################################################################################
#**
#* Return YKEY: null
#*
#* @param YKEY Chiave
#* @param WITHSEP booleano per inserimento separatore (= 0 : inserimento separatore, =1 : no inserimento)
#*!
Funprog GET_NULL(YKEY, WITHSEP)
  Value Char YKEY
  Value Integer WITHSEP
  Local Char YRESULT(250)

  YRESULT = func GET_KEY(YKEY) + "null"
  If WITHSEP = 0
    YRESULT+= func GET_SEPARATOR()
  Endif

End YRESULT
#fine chiave valore

########################################################################################################
##liste
########################################################################################################

Funprog GET_STRLST(YKEY, YARRAY, WITHSEP)
  Value Char YKEY
  Value Char YARRAY()()
  Value Integer WITHSEP
  Local Clbfile YRESULT(250)

  YRESULT = func GET_KEY(YKEY) + func GET_OPENSQUAREBRACKET() #[
  Local Integer I, ARRAY_SIZE : ARRAY_SIZE = func YUTILS.COUNT(YARRAY) - 1
  For I=0 To ARRAY_SIZE
    YRESULT += func GET_STRVALUE(YARRAY(I))
    If I < ARRAY_SIZE
      YRESULT += func GET_SEPARATOR() #,
    Endif
  Next
  YRESULT += func GET_CLOSESQUAREBRACKET() #]
  If WITHSEP = 0
    YRESULT+= func GET_SEPARATOR()
  Endif

End YRESULT

#######################################################################################################
Funprog GET_INTLST(YKEY, YARRAY, WITHSEP)
  Value Char YKEY
  Value Integer YARRAY()
  Value Integer WITHSEP
  Local Clbfile YRESULT(250)

  YRESULT = func GET_KEY(YKEY) + func GET_OPENSQUAREBRACKET() #[
  Local Integer I
  For I=0 To dim(YARRAY) - 1
    YRESULT += YARRAY(I)
    If I < dim(YARRAY) - 1
      YRESULT += func GET_SEPARATOR() #,
    Endif
  Next
  YRESULT += func GET_CLOSESQUAREBRACKET() #]
  If WITHSEP = 0
    YRESULT+= func GET_SEPARATOR() #,
  Endif

End YRESULT
##fine liste

########################################################################################################
##oggetto
########################################################################################################

Funprog GET_INTOBJ(YKEY, YARRAY, WITHKEY, WITHSEP)
  Value Char YKEY
  Value Integer YARRAY()
  Value Integer WITHKEY
  Value Integer WITHSEP
  Local Integer I, LAST_NON_EMPTY
  Local Char YRESULT(250)

  #se si crea un oggetto senza chiave, lo si utilizza solo come item di un array
  YRESULT = func YUTILS.IIF(WITHKEY = 0, func GET_KEY(YKEY) + func GET_OPENCURLYBRACKET(), func GET_OPENCURLYBRACKET())
  For I = 0 To dim(YARRAY) - 1
    Append YRESULT, num$(YARRAY(I))
    If I < dim(YARRAY) - 1
      Append YRESULT, func GET_SEPARATOR() #,
    Endif
  Next I

  Append YRESULT, func GET_CLOSECURLYBRACKET

  If WITHSEP = 0
    Append YRESULT, func GET_SEPARATOR()
  Endif

End YRESULT

########################################################################################################################
##oggetto
Funprog GET_STROBJ(YKEY, YARRAY, WITHKEY, WITHSEP)
  Value Char YKEY
  Value Char YARRAY()()
  Value Integer WITHKEY
  Value Integer WITHSEP
  Local Integer I, LAST_NON_EMPTY
  Local Char YRESULT(250)

  Local Integer ARRAY_SIZE : ARRAY_SIZE = func YUTILS.COUNT(YARRAY) - 1
  #se si crea un oggetto senza chiave, lo si utilizza solo come item di un array
  YRESULT = func YUTILS.IIF(WITHKEY = 0, func GET_KEY(YKEY) + func GET_OPENCURLYBRACKET(), func GET_OPENCURLYBRACKET())
  For I = 0 To ARRAY_SIZE
    Append YRESULT, YARRAY(I)
    If I < ARRAY_SIZE
      Append YRESULT, func GET_SEPARATOR() #,
    Endif
  Next I

  Append YRESULT, func GET_CLOSECURLYBRACKET

  If WITHSEP = 0
    Append YRESULT, func GET_SEPARATOR()
  Endif

End YRESULT

######################################################################################################################
##oggetto
Funprog GET_CLBOBJ(YKEY, YARRAY, WITHKEY, WITHSEP)
  Value Char YKEY
  Value Clbfile YARRAY()()
  Value Integer WITHKEY
  Value Integer WITHSEP
  Local Integer I
  Local Clbfile YRESULT

  #se si crea un oggetto senza chiave, lo si utilizza solo come item di un array
  Gosub CREATE_CLBOBJ
End YRESULT

###########################################################################################################################

Funprog GET_CLBOBJ_FROM_STRARRAY(YKEY, YARRAY, WITHKEY, WITHSEP)
  Value Char YKEY
  Value Char YARRAY()
  Value Integer WITHKEY
  Value Integer WITHSEP
  Local Integer I
  Local Clbfile YRESULT

  #se si crea un oggetto senza chiave, lo si utilizza solo come item di un array
  Gosub CREATE_CLBOBJ
End YRESULT

##########################################################################################################################
$CREATE_CLBOBJ

  YRESULT = func YUTILS.IIF(WITHKEY = 0, func GET_KEY(YKEY) + func GET_OPENCURLYBRACKET(), func GET_OPENCURLYBRACKET())
  Local Integer ARRAY_SIZE : ARRAY_SIZE = func YUTILS.COUNT(YARRAY) - 1
  For I = 0 To ARRAY_SIZE
    Append YRESULT, YARRAY(I)
    If I < ARRAY_SIZE
      Append YRESULT, func GET_SEPARATOR() #,
    Endif
  Next I
  Append YRESULT, func GET_CLOSECURLYBRACKET
  If WITHSEP = 0
    Append YRESULT, func GET_SEPARATOR()
  Endif

Return

##########################################################################################################################
##array
##########################################################################################################################

Funprog GET_EMPTYARRAY(YKEY, WITHKEY)
  Value Char YKEY
  Value Integer WITHKEY

  Local Char EMPTY_ARR(2) : EMPTY_ARR = func GET_OPENSQUAREBRACKET + func GET_CLOSESQUAREBRACKET

End func YUTILS.IIF(WITHKEY = 0, func GET_KEY(YKEY) + EMPTY_ARR, EMPTY_ARR )

##########################################################################################################################

Funprog GET_STRARRAY(YKEY, YARRAY, WITHSEP)
  Value Char YKEY
  Value Char YARRAY()(,)
  Value Integer WITHSEP

  Local Integer I, J
  Local Integer ROWS, NCOLS
  Local Char ROWSTR(250)
  Local Char YRESULT(250)

  ROWS = func YUTILS.COUNT_MULTI(YARRAY)
  NCOLS = dim(YARRAY, 2)

  YRESULT = func GET_STRVALUE(YKEY) + func GET_OPENCURLYBRACKET_ARRAY()  #key:[

  For I = 0 To ROWS - 1
    ROWSTR = func GET_OPENCURLYBRACKET()  # apre l’oggetto

    For J = 0 To NCOLS - 1
      If vireblc(YARRAY(I,J), 2) <> AVOID.ACHAR
        ROWSTR += YARRAY(I,J)
      Endif
    Next J

    ROWSTR += func GET_CLOSECURLYBRACKET()  # chiude l’oggetto

    #AGGIUNGE LA RIGA COMPLETA AL RISULTATO
    YRESULT += ROWSTR

    If I < ROWS - 1
      YRESULT += func GET_SEPARATOR()  # virgola tra oggetti
    Endif
  Next I

  YRESULT += func GET_CLOSESQUAREBRACKET()  # chiude array

  If WITHSEP = 0
    YRESULT += func GET_SEPARATOR()
  Endif

End YRESULT

########################################################################################################################

Funprog GET_CLBARRAY(YKEY, YARRAY, WITHSEP)
  Value Char YKEY
  Value Char YARRAY()(,)
  Value Integer WITHSEP

  Local Integer I, J
  Local Integer ROWS, NCOLS
  Local Clbfile ROWSTR(1)
  Local Clbfile YRESULT

  ROWS = func YUTILS.COUNT_MULTI(YARRAY)
  NCOLS = dim(YARRAY, 2)

  YRESULT = func GET_STRVALUE(YKEY) + func GET_OPENCURLYBRACKET_ARRAY()  #key:[

  For I = 0 To ROWS - 1
    ROWSTR = func GET_OPENCURLYBRACKET()  # apre l’oggetto

    For J = 0 To NCOLS - 1
      If vireblc(YARRAY(I,J), 2) <> AVOID.ACHAR
        ROWSTR += YARRAY(I,J)
      Endif
    Next J

    ROWSTR += func GET_CLOSECURLYBRACKET()  # chiude l’oggetto

    #AGGIUNGE LA RIGA COMPLETA AL RISULTATO
    YRESULT += ROWSTR

    If I < ROWS - 1
      YRESULT += func GET_SEPARATOR()  # virgola tra oggetti
    Endif
  Next I

  YRESULT += func GET_CLOSESQUAREBRACKET()  # chiude array

  If WITHSEP = 0
    YRESULT += func GET_SEPARATOR()
  Endif

End YRESULT

#########################################################################################################################

Funprog GET_CLBARRAY_FROM_STRARRAY(YKEY, YARRAY, WITHSEP)
  Value Char YKEY
  Value Char YARRAY()()
  Value Integer WITHSEP

  Local Clbfile YRESULT(2)

  If YKEY <> AVOID.ACHAR
    Append YRESULT, func GET_STRVALUE(YKEY) + func GET_OPENCURLYBRACKET_ARRAY()
  Else
    Append YRESULT, func GET_OPENSQUAREBRACKET()
  Endif

  Local Integer I
  Local Integer ARRAY_SIZE : ARRAY_SIZE = func YUTILS.COUNT(YARRAY) - 1

  For I = 0 To ARRAY_SIZE
    Append YRESULT, YARRAY(I)
    If I < ARRAY_SIZE
      If vireblc(YARRAY(I), 2) <> AVOID.ACHAR
        Append YRESULT, func GET_SEPARATOR() #,
      Endif
    Endif
  Next I

  YRESULT += func GET_CLOSESQUAREBRACKET() #]

  If WITHSEP = 0
    Append YRESULT, func GET_SEPARATOR()
  Endif

End YRESULT

#################################################################################################################

Funprog GET_CLBARRAY_FROM_CLBARRAY(YKEY, YARRAY, WITHSEP)
  Value Char YKEY
  Value Clbfile YARRAY()()
  Value Integer WITHSEP

  Local Clbfile YRESULT(2)

  If YKEY <> AVOID.ACHAR
    YRESULT = func GET_STRVALUE(YKEY) + func GET_OPENCURLYBRACKET_ARRAY()
  Else
    YRESULT = func GET_OPENSQUAREBRACKET()
  Endif

  Local Integer I
  Local Integer ARRAY_SIZE : ARRAY_SIZE = func YUTILS.COUNT(YARRAY) - 1

  For I = 0 To ARRAY_SIZE
    Append YRESULT, YARRAY(I)
    If I < ARRAY_SIZE
      If vireblc(YARRAY(I), 2) <> AVOID.ACHAR
        Append YRESULT, func GET_SEPARATOR() #,
      Endif
    Endif
  Next I

  YRESULT += func GET_CLOSESQUAREBRACKET() #]

  If WITHSEP = 0
    YRESULT += func GET_SEPARATOR()
  Endif

End YRESULT

########################################################################################################################

Funprog GET_STRARRAY_FROM_STRARRAY(YKEY, YARRAY, WITHSEP)
  Value Char YKEY
  Value Char YARRAY()()
  Value Integer WITHSEP

  #Local Clbfile YRESULT(2)
  Local Char YRESULT(250)

  If YKEY <> AVOID.ACHAR
    YRESULT = func GET_STRVALUE(YKEY) + func GET_OPENCURLYBRACKET_ARRAY()
  Else
    YRESULT = func GET_OPENSQUAREBRACKET()
  Endif

  Local Integer I
  Local Integer ARRAY_SIZE : ARRAY_SIZE = func YUTILS.COUNT(YARRAY) - 1

  For I = 0 To ARRAY_SIZE
    YRESULT += YARRAY(I)
    If I < ARRAY_SIZE
      If vireblc(YARRAY(I), 2) <> AVOID.ACHAR
        YRESULT += func GET_SEPARATOR() #,
      Endif
    Endif
  Next I

  YRESULT += func GET_CLOSESQUAREBRACKET() #]

  If WITHSEP = 0
    YRESULT += func GET_SEPARATOR()
  Endif

End YRESULT

##############################################################

# apre un array: con chiave ->  "YKEY": [   ; senza chiave -> [
Funprog OPEN_ARRAY(YKEY, WITHKEY)
  Value Char YKEY
  Value Integer WITHKEY
  Local Char YRESULT(250)

  # se WITHKEY = 0 includo "YKEY": [ altrimenti solo [
  YRESULT = func YUTILS.IIF(WITHKEY = 0, func GET_STRVALUE(YKEY) + func GET_OPENCURLYBRACKET_ARRAY(), func GET_OPENSQUAREBRACKET())

End YRESULT

Funprog CLOSE_ARRAY()
End chr$(93) #]

##############################################################

# apre un object: con chiave ->  "YKEY": {   ; senza chiave -> {
Funprog OPEN_OBJECT(YKEY, WITHKEY)
  Value Char YKEY
  Value Integer WITHKEY
  Local Char YRESULT(250)

  # se WITHKEY = 0 includo "YKEY": { altrimenti solo {
  YRESULT = func YUTILS.IIF(WITHKEY = 0, func GET_STRVALUE(YKEY) + func GET_COLON() + func GET_OPENCURLYBRACKET(), func GET_OPENCURLYBRACKET())

End YRESULT

##############################################################

Funprog CLOSE_OBJECT()
End chr$(125) #}

############################################################################################################################

##print
Funprog GET_JSON(YJSON)
  Value Clbfile YJSON
  Local Clbfile YRESULT

  YRESULT = func GET_OPENCURLYBRACKET()
  YRESULT += YJSON
  YRESULT += func GET_CLOSECURLYBRACKET()

End YRESULT

############################################################################################################################
############################################################################################################################
#**
#* Funzione per generare Json di Risposta (clob) con varie azioni: Alert, Apertura Modale, Modifica campi videata, Selezione, Selezione multi campo
#*
#* @param SUCCESS_VALUE  Intero(Booleano)
#* @param ALERT_TYPE Tipo di Alert(toast,info,error, warning)
#* @param ALERT_MESSAGE Messaggio da visualizzare nell'Alert
#* @param ALERT_WS  Lista degli Eventuale/i Web service lanciato all'alert
#* @param OPENFUNCTION Lista delle Funzioni lanciabili in maniera modale
#* @param FIELDS Matrice dei campi di videata e loro proprietà
#* @param HEADER Chiavi(campi)da visualizzare in selezione
#* @param DATA Dati(campi)da visualizzare in selezione
#* @param SELECTEDFIELDS Lista dei campi da valorizzare in Selezione(Selezione con valorizzazione multi-campo)
#*!

Funprog GENERATE_JSON(SUCCESS_VALUE, ALERT_TYPE, ALERT_MESSAGE, ALERT_WS, OPENFUNCTION, FIELDS, HEADER, DATA, SELECTEDFIELDS)

  Value Integer SUCCESS_VALUE
  Value Char ALERT_TYPE
  Value Char ALERT_MESSAGE
  Value Char ALERT_WS()(,)
  Value Char OPENFUNCTION()
  Value Char FIELDS()(,)
  Value Char HEADER()(,)
  Value Char DATA()(,)
  Value Char SELECTEDFIELDS()()

  Local Clbfile JSON_RESULT(14)

  Append JSON_RESULT, func GET_OPENCURLYBRACKET()
  #IL MKSTAT è GESTITO DIVERSAMENTE, SIAMO COSTRETTI a gestirlo con un ternario
  Append JSON_RESULT, func GET_BOOL("success", func YUTILS.IIF(SUCCESS_VALUE = 0, 1, 0)  , 0)

  Local Char ALERT_TOAST_TEXT(250)
  Local Char ALERT_TOAST_ITEM(250)(2)
  # qui ci sono tutte le azioni da mandare ad ax3m
  Local Clbfile ACTION_ITEMS(1)(0..)
  # si gestiscono più azioni per cui questo è l'indice corrente dell'array di clob contenente le azioni
  Local Shortint ACTION_INDEX : ACTION_INDEX = -1

  #ALERT E TOAST
  If(find(ALERT_TYPE, "info", "warning", "confirm", "error") > 0)
    ACTION_INDEX+=1
    Local Char ALERT_DETAILS(250)(2)
    ALERT_DETAILS(0) = func GET_STR("alertType", ALERT_TYPE, 1)
    ALERT_DETAILS(1) = func GET_STR("message", ALERT_MESSAGE, 1)
    Local Char ALERT_DETAILS_TEXT(250)
    ALERT_DETAILS_TEXT = func GET_STROBJ("details", ALERT_DETAILS, 0, 1)
    ALERT_TOAST_ITEM(0) = func GET_STR("type","alert", 1)
    ALERT_TOAST_ITEM(1) = ALERT_DETAILS_TEXT
    ALERT_TOAST_TEXT = func GET_STROBJ(AVOID.ACHAR, ALERT_TOAST_ITEM, 1, 1)
    ACTION_ITEMS(ACTION_INDEX) = ALERT_TOAST_TEXT

  Elsif ALERT_TYPE = "toast"
    ACTION_INDEX+=1
    Local Char ALERT_DETAILS(250)(1)
    ALERT_DETAILS(0) = func GET_STR("message", ALERT_MESSAGE,1)
    Local Char ALERT_DETAILS_TEXT(250)
    ALERT_DETAILS_TEXT = func GET_STROBJ("details", ALERT_DETAILS, 0, 1)
    ALERT_TOAST_ITEM(0) = func GET_STR("type", ALERT_TYPE, 1)
    ALERT_TOAST_ITEM(1) = ALERT_DETAILS_TEXT
    ALERT_TOAST_TEXT = func GET_STROBJ(AVOID.ACHAR, ALERT_TOAST_ITEM, 1, 1)
    ACTION_ITEMS(ACTION_INDEX) = ALERT_TOAST_TEXT

  Endif

  #FIELDS
  If(len(FIELDS) > 0)
    Local Integer NB_DETAIL_FIELDS : NB_DETAIL_FIELDS = 0
    Local Integer NB_GRID_FIELDS : NB_GRID_FIELDS = 0
    Local Integer GRID_ROW_LENGTH : GRID_ROW_LENGTH = 0
    Local Integer GRID_FIELD_FOUND : GRID_FIELD_FOUND = 0
    Local Integer I
    Local Char FIRST_GRID_FIELD(13)
    Local Char TESTATA(1) : TESTATA = "0"
    Local Char RIQUADRO(1) : RIQUADRO = "1"
    # Process detail fields
    Local Integer COUNT_SCREEN_ITEMS : COUNT_SCREEN_ITEMS = func YUTILS.COUNT_MULTI(FIELDS) - 1

    ACTION_INDEX+=1
    # First pass: Count detail fields and identify the length of a grid row
    For I = 0 To COUNT_SCREEN_ITEMS
      If FIELDS(I, 8) <> RIQUADRO
        NB_DETAIL_FIELDS = NB_DETAIL_FIELDS + 1
      Else  # Grid field
        If GRID_FIELD_FOUND = 0  # First grid field detection
          FIRST_GRID_FIELD = FIELDS(I, 0)
          GRID_FIELD_FOUND = 1
        Endif
        If FIELDS(I, 0) = FIRST_GRID_FIELD
          GRID_ROW_LENGTH = GRID_ROW_LENGTH + 1
        Endif
        NB_GRID_FIELDS = NB_GRID_FIELDS + 1
      Endif
    Next

    Local Char FIELD_ITEM(250)(7), FIELD_JSON(250)
    Local Clbfile DETAILS(1)
    Local Char FIELD_OBJECT(250)(dim(FIELDS, 2) - 1)
    Local Integer WITHSEP

    #qui registro il 1° indice trovato in YFIELDS di un campo di Testata
    Local Integer Y1TESTATA: Y1TESTATA = -1

    For I = 0 To COUNT_SCREEN_ITEMS
      If FIELDS(I, 8) = TESTATA # se è un campo appartenente alla testata

        #intercetto l'indice 1° Campo di Testata in YFIELDS
        If(Y1TESTATA<0)
          Y1TESTATA = I
        Endif

        Raz FIELD_OBJECT
        Call FILL_FIELD_OBJECT(I, FIELDS, FIELD_OBJECT)
        FIELD_JSON = func GET_STROBJ(AVOID.ACHAR, FIELD_OBJECT, 1, func YUTILS.IIF(type(FIELDS(I + 1, 0)) > 0 & (vireblc(FIELDS(I + 1, 0), 2) <> AVOID.ACHAR | Y1TESTATA>0), 0, 1) )
        #FIELD_JSON = func GET_STROBJ(AVOID.ACHAR, FIELD_OBJECT, 1, func YUTILS.IIF(type(FIELDS(I + 1, 0)) > 0 & vireblc(FIELDS(I + 1, 0), 2) <> AVOID.ACHAR, 0, 1) )
        Append DETAILS, FIELD_JSON
      Endif
    Next

    # Process grid fields if any rows are detected
    If GRID_ROW_LENGTH > 0
      Local Clbfile GRID_ARRAY(1), CURRENT_ROW(1)
      Local Integer CURRENT_FIELD : CURRENT_FIELD = 0
      Local Integer CURRENT_ROW_INDEX : CURRENT_ROW_INDEX = 1

      # To track the "currentRow" when FIELDS(I, 9) = "1"
      Local Integer FOUND_CURRENT_ROW : FOUND_CURRENT_ROW = 0
      Local Integer WITHSEP, ROW_INDEX : ROW_INDEX = 0
      Local Integer IS_LAST_ARRAY_ITEM : IS_LAST_ARRAY_ITEM = 0
      Local Char FIELD_OBJECT(250)(dim(FIELDS, 2) - 1)

      # Process each grid field
      For I = 0 To COUNT_SCREEN_ITEMS
        If FIELDS(I, 8) = RIQUADRO
          Raz FIELD_OBJECT
          Call FILL_FIELD_OBJECT(I, FIELDS, FIELD_OBJECT)
          #1- se campo successivo : di Testata; 2- se campo successivo: ha fieldName vuoto; 3- "" o  campo successivo è il 1° campo di dettaglio(cominciata una nuova riga)
          If (FIELDS(I + 1, 8) = TESTATA & vireblc(FIELDS(I + 1, 0), 2) <> '') | (vireblc(FIELDS(I + 1, 0), 2) = AVOID.ACHAR | FIELDS(I + 1, 0) = FIRST_GRID_FIELD)
            WITHSEP = 1 # NON METTO LA VIRGOLA
          Else
            WITHSEP = 0 # METTO LA VIRGOLA
          Endif

          FIELD_JSON = func GET_STROBJ(AVOID.ACHAR, FIELD_OBJECT, 1, WITHSEP)

          # If the first riquadro field is detected again, start a new row
          If FIELDS(I, 0) = FIRST_GRID_FIELD & CURRENT_FIELD > 0
            # Append the current row to GRID_ARRAY
            Append GRID_ARRAY, func GET_CLBARRAY_FROM_CLBARRAY(AVOID.ACHAR, CURRENT_ROW, 0)
            Raz CURRENT_ROW
            CURRENT_ROW_INDEX = CURRENT_ROW_INDEX + 1
          Endif

          # Check if this row is the "currentRow"
          If FIELDS(I, 9) = "1"
            FOUND_CURRENT_ROW = CURRENT_ROW_INDEX
          Endif

          Append CURRENT_ROW, FIELD_JSON
          CURRENT_FIELD = CURRENT_FIELD + 1
        Endif
      Next

      # Add last row if any fields remain
      If dim(CURRENT_ROW, 1) > 0
        Append GRID_ARRAY, func GET_CLBARRAY_FROM_CLBARRAY(AVOID.ACHAR, CURRENT_ROW, 1)
      Endif

      # Add the grid structure with currentRow and rows
      Local Clbfile FINAL_GRID_STRUCTURE(1)(2)
      FINAL_GRID_STRUCTURE(0) = func GET_INT("currentRow", FOUND_CURRENT_ROW - 1, 1)
      FINAL_GRID_STRUCTURE(1) = func GET_CLBARRAY_FROM_CLBARRAY("rows", GRID_ARRAY, 1)

      Local Clbfile FINAL_GRID
      FINAL_GRID = func GET_CLBOBJ(AVOID.ACHAR, FINAL_GRID_STRUCTURE, 1, 1)

      Append DETAILS, FINAL_GRID
    Endif

    # Final JSON structure
    #Local Clbfile ACTIONS(1)
    Local Clbfile FIELDS_OBJ(1)(func YUTILS.IIF(func YUTILS.COUNT(OPENFUNCTION) = 0, 2, 6))
    If func YUTILS.COUNT(OPENFUNCTION) = 0
      #payload fields
      FIELDS_OBJ(0) = func GET_STR("type", "fields", 1)
      FIELDS_OBJ(1) = func GET_CLBARRAY_FROM_CLBARRAY("details", DETAILS, 1)
    Else
      #payload open new function
      FIELDS_OBJ(0) = func GET_STR("type", "function", 1)
      FIELDS_OBJ(1) = func GET_STR("open", OPENFUNCTION(0), 1)
      FIELDS_OBJ(2) = func GET_STR("title", OPENFUNCTION(1), 1)
      FIELDS_OBJ(3) = func GET_STR("controller", OPENFUNCTION(2), 1)
      FIELDS_OBJ(4) = func GET_INT("navigation", val(OPENFUNCTION(3)), 1)
      FIELDS_OBJ(5) = func GET_CLBARRAY_FROM_CLBARRAY("details", DETAILS, 1)
    Endif
    Append ACTION_ITEMS(ACTION_INDEX), func GET_CLBOBJ(AVOID.ACHAR, FIELDS_OBJ, 1, 1)

  Endif

  #GRID
  If(len(HEADER) > 0)

    ACTION_INDEX+=1

    Local Integer HEADER_SIZE : HEADER_SIZE = func YUTILS.COUNT_MULTI(HEADER)
    Local Char HEADER_KEY_VALUE(250)(dim(HEADER, 1))

    Call FILL_GRID_HEADER(HEADER, HEADER_KEY_VALUE)

    Local Integer DATA_SIZE : DATA_SIZE = func YUTILS.COUNT_MULTI(DATA)
    Local Char DATA_KEY_VALUE(250)(DATA_SIZE, dim(DATA, 2))

    Call FILL_GRID_DATA(DATA, DATA_KEY_VALUE)
    Local Clbfile GRID_ITEMS(1)(2)
    GRID_ITEMS(0)= func GET_CLBOBJ("header", HEADER_KEY_VALUE, 0, 1)
    GRID_ITEMS(1)= func GET_CLBARRAY("data", DATA_KEY_VALUE, 1) #SISTEMARE
    Local Clbfile GRID_DETAILS_TEXT(1)
    GRID_DETAILS_TEXT = func GET_CLBOBJ("details", GRID_ITEMS, 0, 1)

    Local Clbfile GRID_OBJ(1)(3)
    GRID_OBJ(0) = func GET_STR("type", "grid", 1)
    GRID_OBJ(1) = func GET_STRLST("selectionFields", SELECTEDFIELDS, 1)  #chiave-valore per campi aggiuntivi (Selezione multi campo)
    GRID_OBJ(2) = GRID_DETAILS_TEXT

    ACTION_ITEMS(ACTION_INDEX)= func GET_CLBOBJ(AVOID.ACHAR, GRID_OBJ, 1, 1)

  Endif

  Append JSON_RESULT, func GET_CLBARRAY_FROM_CLBARRAY("actions", ACTION_ITEMS, 1)
  Append JSON_RESULT, func GET_CLOSECURLYBRACKET()

End JSON_RESULT

########################################################################################

Subprog FILL_FIELD_ARRAY(FIELDS, FIELD_KEY_VALUE)
  Value Char FIELDS()(,)
  Variable Char FIELD_KEY_VALUE()(,)

  Local Integer I

  Local Integer COUNT_SCREEN_ITEMS : COUNT_SCREEN_ITEMS = func YUTILS.COUNT_MULTI(FIELDS) - 1
  For I = 0 To COUNT_SCREEN_ITEMS
    FIELD_KEY_VALUE(I,0) = func GET_STR("fieldName", FIELDS(I,0), 0)
    Case tolower(FIELDS(I,1))
      When "bool":
        FIELD_KEY_VALUE(I,1) = func GET_BOOL("fieldValue", val(FIELDS(I,2)), 0)
      When "decimal" :
        FIELD_KEY_VALUE(I,1) = func GET_DECIMAL("fieldValue", val(FIELDS(I,2)), 0)
      When "integer" :
        FIELD_KEY_VALUE(I,1) = func GET_INT("fieldValue", val(FIELDS(I,2)), 0)
      When "char" :
        FIELD_KEY_VALUE(I,1) = func GET_STR("fieldValue", FIELDS(I,2), 0)
      When "date" :
        FIELD_KEY_VALUE(I,1) = func GET_STR("fieldValue", FIELDS(I,2), 0)
      When Default:
    Endcase
    FIELD_KEY_VALUE(I,2) = func GET_BOOL("fieldValid", val(FIELDS(I,3)), 0)
    FIELD_KEY_VALUE(I,3) = func GET_STR("fieldMessage", FIELDS(I,4), 0)
    FIELD_KEY_VALUE(I,4) = func GET_BOOL("fieldFocus", val(FIELDS(I,5)), 0)
    FIELD_KEY_VALUE(I,5) = func GET_BOOL("fieldVisible", val(FIELDS(I,6)), 0)
    FIELD_KEY_VALUE(I,6) = func GET_BOOL("fieldEnter", val(FIELDS(I,7)), 1)
  Next
End

########################################################################################

Subprog FILL_FIELD_OBJECT(INDEX, FIELDS, FIELD_ARRAY)
  Value Integer INDEX
  Value Char FIELDS()(,)
  Variable Char FIELD_ARRAY()()

  FIELD_ARRAY(0) = func GET_STR("fieldName", FIELDS(INDEX,0), 1)
  FIELD_ARRAY(1) = func GET_STR("fieldType", FIELDS(INDEX,1), 1)
  Case tolower(FIELDS(INDEX,1))
    When "bool":
      FIELD_ARRAY(2) = func GET_BOOL("fieldValue", val(FIELDS(INDEX,2)), 1)
    When "decimal" :
      FIELD_ARRAY(2) = func GET_DECIMAL("fieldValue", val(FIELDS(INDEX,2)), 1)
    When "integer" :
      FIELD_ARRAY(2) = func GET_INT("fieldValue", val(FIELDS(INDEX,2)), 1)
    When "char" :
      FIELD_ARRAY(2) = func GET_STR("fieldValue", FIELDS(INDEX,2), 1)
    When "date" :
      FIELD_ARRAY(2) = func GET_STR("fieldValue", FIELDS(INDEX,2), 1)
    When Default:
  Endcase
  FIELD_ARRAY(3) = func GET_BOOL("fieldValid", val(FIELDS(INDEX,3)), 1)
  FIELD_ARRAY(4) = func GET_STR("fieldMessage", FIELDS(INDEX,4), 1)
  FIELD_ARRAY(5) = func GET_BOOL("fieldFocus", val(FIELDS(INDEX,5)), 1)
  FIELD_ARRAY(6) = func GET_BOOL("fieldVisible", val(FIELDS(INDEX,6)), 1)
  FIELD_ARRAY(7) = func GET_BOOL("fieldEnter", val(FIELDS(INDEX,7)), 1)
End

###################################################################################

Subprog FILL_GRID_HEADER(FIELDS, FIELD_KEY_VALUE)

  Value Char FIELDS()(,)
  Variable Char FIELD_KEY_VALUE()()

  Local Integer I
  Local Integer COUNT_SCREEN_ITEMS : COUNT_SCREEN_ITEMS = func YUTILS.COUNT_MULTI(FIELDS) - 1
  For I = 0 To COUNT_SCREEN_ITEMS
    FIELD_KEY_VALUE(I) = func GET_STR(FIELDS(I,0), FIELDS(I,1), 1)
  Next I

End

###################################################################################

Subprog FILL_GRID_DATA(FIELDS, FIELD_KEY_VALUE)

  Value Char FIELDS()(,)
  Variable Char FIELD_KEY_VALUE()(,)

  Local Integer I, J
  Local Integer COUNT_SCREEN_ITEMS : COUNT_SCREEN_ITEMS = func YUTILS.COUNT_MULTI(FIELDS) - 1
  For I = 0 To COUNT_SCREEN_ITEMS
    For J = 0 To dim(FIELDS, 2) - 1
      FIELD_KEY_VALUE(I,J) = FIELDS(I,J)
      If(J < dim(FIELDS, 2) - 1)
        FIELD_KEY_VALUE(I,J) += chr$(44)
      Endif
    Next J
  Next I

End
**********
7,"TRT","YJSONSERIALIZE",""
2,"TRT","YRESTWS",""
#<AdxTL>@(#)0.0.0.0 $Revision$
#<AdxTL>@(#)0.0.0.0 $Revision$
#**
#* Funzionalità per esecuzione servizio REST
#*
#* @param HTTP_METHOD Verbo richiesta (GET, POST, PUT, PATCH, DELETE)
#* @param NAME Nome Servizio REST X3
#* @param CONTROLLER Nome Controller
#* @param ACTION Nome Azione
#* @param CDATA Body richiesta REST
#* @param YRESPONSE Output response (status, message)
#*!
Subprog EXEC(NAME, HTTP_METHOD, CONTROLLER, ACTION, PCOD, PVAL, CDATA, RESBODY)

  Value Char NAME
  Value Char HTTP_METHOD
  Value Char CONTROLLER
  Value Char ACTION
  Value Char PCOD()()
  Value Char PVAL()()
  Value Clbfile CDATA
  Variable Clbfile RESBODY

  Gosub EXEC_REST

  #Inizio traccia
  Call OUVRE_TRACE("Esecuzione endpoint: " + CONTROLLER + ACTION ) From LECFIC

  TYPE_TRACE = func YUTILS.IIF(RETVAL = SUCCESS, -1, 1)

  #lo disabilito perchè ci son dati sensibili
  Call ECR_TRACE ("Body request:", TYPE_TRACE) From GESECRAN
  For I = 0 To dim(REQBODY_ARR) - 1
    Call ECR_TRACE (REQBODY_ARR(I), TYPE_TRACE) From GESECRAN
  Next

  Call ECR_TRACE ("Response status code:" - num$(RETVAL), TYPE_TRACE) From GESECRAN

  Local Char RESHEAD_ARR(250)(int(len(RESHEAD) / 250) + 1)
  Call ECR_TRACE ("Header response:", TYPE_TRACE) From GESECRAN
  Call YCLB2STRARR(RESHEAD, RESHEAD_ARR) From YUTILS
  For I = 0 To dim(RESHEAD_ARR) - 1
    Call ECR_TRACE (RESHEAD_ARR(I), TYPE_TRACE) From GESECRAN
  Next

  Local Char RESBODY_ARR(250)(int(len(RESBODY) / 250) + 1)
  #LO DISABILITO PERCHÈ CI SON DATI SENSIBILI
  Call ECR_TRACE ("Body response:", TYPE_TRACE)  From GESECRAN
  Call YCLB2STRARR(RESBODY, RESBODY_ARR) From YUTILS
  For I = 0 To dim(RESBODY_ARR) - 1
    Call ECR_TRACE (RESBODY_ARR(I), TYPE_TRACE) From GESECRAN
  Next

  Call FERME_TRACE From LECFIC

End

#########################################################################################################

#**
#* Funzionalità per esecuzione servizio REST
#*
#* @param HTTP_METHOD Verbo richiesta (GET, POST, PUT, PATCH, DELETE)
#* @param NAME Nome Servizio REST X3
#* @param CONTROLLER Nome Controller
#* @param ACTION Nome Azione
#* @param CDATA Body richiesta REST
#* @param YRESPONSE Output response (status, message)
#*!
Subprog EXEC_NOTRACE(NAME, HTTP_METHOD, CONTROLLER, ACTION, PCOD, PVAL, CDATA, RESBODY)

  Value Char NAME
  Value Char HTTP_METHOD
  Value Char CONTROLLER
  Value Char ACTION
  Value Char PCOD()()
  Value Char PVAL()()
  Value Clbfile CDATA
  Variable Clbfile RESBODY

  Gosub EXEC_REST

End

$EXEC_REST

  Gosub GET_WS_CONSTANTS From YUTILS

  Local Char HCOD(100)(1..10),HVAL(100)(1..10)
  Local Char SUBURL(len(CONTROLLER) + len(ACTION) + 5)
  If CONTROLLER <> AVOID.ACHAR
    SUBURL += CONTROLLER
  Endif
  If ACTION <> AVOID.ACHAR
    SUBURL += ACTION
  Endif

  Local Clbfile RESHEAD(0)
  Local Integer RETVAL, I

  #inizializzo header request
  HCOD(1)="Accept-Language"
  HVAL(1)='"it,it-IT;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6"'
  HCOD(2)="Content-Type"
  HVAL(2)='"application/json"'

  Local Char REQBODY_ARR(250)(int(len(CDATA) / 250) + 1)
  Call YCLB2STRARR(CDATA, REQBODY_ARR) From YUTILS

  RETVAL=func ASYRRESTCLI.EXEC_REST_WS(NAME, HTTP_METHOD, SUBURL, PCOD, PVAL, HCOD, HVAL, CDATA, 0, "", RESHEAD, RESBODY)

Return
**********
7,"TRT","YRESTWS",""
2,"TRT","YUTILS",""
#<AdxTL>@(#)0.0.0.0 $Revision$
#####################################################################################################################################
#                                               Libreria con funzioni di utilità
#####################################################################################################################################

$GET_CONSTANTS

  Const Integer TRUE : TRUE = 2
  Const Integer FALSE : FALSE = 1

Return

##########################################################################################################

$GET_WS_CONSTANTS

  Const Integer SUCCESS : SUCCESS = 200
  Const Integer CREATED : CREATED = 201
  Const Integer NO_CONTENT : NO_CONTENT = 204
  Const Integer MOVED_PERMANENTLY : MOVED_PERMANENTLY = 301
  Const Integer FOUND : FOUND = 302
  Const Integer NOT_MODIFIED : NOT_MODIFIED = 304
  Const Integer BAD_REQUEST : BAD_REQUEST = 400
  Const Integer UNAUTHORIZED : UNAUTHORIZED = 401
  Const Integer FORBIDDEN : FORBIDDEN = 403
  Const Integer NOT_FOUND : NOT_FOUND = 404
  Const Integer METHOD_NOT_ALLOWED : METHOD_NOT_ALLOWED = 405
  Const Integer CONFLICT : CONFLICT = 409 #'Tentativo di creare un valore chiave duplicato.'
  Const Integer LOCKED : LOCKED = 423 #'Tabella bloccata.'
  Const Integer INTERNAL_SERVER_ERROR : INTERNAL_SERVER_ERROR = 500
  Const Integer NOT_IMPLEMENTED : NOT_IMPLEMENTED = 501
  Const Integer BAD_GATEWAY : BAD_GATEWAY = 502
  Const Integer SERVICE_UNAVAILABLE : SERVICE_UNAVAILABLE = 503
  Const Integer INSUFFICIENT_STORAGE : INSUFFICIENT_STORAGE = 507 #'Spazio insufficiente per creare nuove righe.'

Return

########################################################

Funprog FIXURL(MALFORMEDURL)
  Value Char MALFORMEDURL
  Local Char URL(250)
  Local Char PROTOCOL(10), TEMPURL(250), DOMAIN(250), REMAINDER(250)
  Local Integer HASPROTOCOL, HASWWW, HASTLD, I, PROTOCOLPOS, SLASHPOS

  # Rimuovi spazi iniziali e finali
  URL = vireblc(MALFORMEDURL, 2)
  HASPROTOCOL = 0
  HASWWW = 0
  HASTLD = 0

  # Verifica se ha già un protocollo
  If mid$(URL, 1, 7) = "http://" | mid$(URL, 1, 8) = "https://"
    HASPROTOCOL = 1
  Endif

  # Aggiungi protocollo se mancante
  If !HASPROTOCOL
    URL = "https://" + URL
  Endif

  # Trova posizione dopo il protocollo
  If mid$(URL, 1, 7) = "http://"
    PROTOCOLPOS = 8
    PROTOCOL = "http://"
  Else
    PROTOCOLPOS = 9  # https:// ha 8 caratteri
    PROTOCOL = "https://"
  Endif

  # Verifica se ha www
  If mid$(URL, PROTOCOLPOS, 4) = "www."
    HASWWW = 1
  Endif

  # Verifica se ha un TLD comune (.com, .net, ecc.)
  If instr(0, URL, ".com") > 0 | instr(0, URL, ".net") > 0 | instr(0, URL, ".org") > 0 | instr(0, URL, ".gov") > 0 | instr(0, URL, ".edu") > 0 | instr(0, URL, ".io") > 0 | instr(0, URL, ".dev") > 0 |
& instr(0, URL, ".it") > 0 | instr(0, URL, ".fr") > 0 | instr(0, URL, ".de") > 0 | instr(0, URL, ".es") > 0 | instr(0, URL, ".uk") > 0
    HASTLD = 1
  Endif

  # Aggiungi www se mancante e potrebbe essere necessario (euristica semplificata)
  If !HASWWW & HASTLD
    # Dobbiamo ricostruire l'URL con www.
    DOMAIN = mid$(URL, PROTOCOLPOS, len(URL) - PROTOCOLPOS + 1)
    URL = PROTOCOL + "www." + DOMAIN
  Endif

  # Aggiungi .com se non ha un TLD
  If !HASTLD
    # Trova la posizione del primo slash dopo il protocollo
    SLASHPOS = instr(PROTOCOLPOS, URL, "/")

    # Se non c'è slash dopo il dominio, aggiungi .com alla fine
    If SLASHPOS = 0
    URL = URL + ".com"
    Else
    # Altrimenti, inserisci .com prima del primo slash
    DOMAIN = mid$(URL, 1, SLASHPOS - 1)
    REMAINDER = mid$(URL, SLASHPOS, len(URL) - SLASHPOS + 1)
    URL = DOMAIN + ".com" + REMAINDER
    Endif
  Endif

  # Correggi doppi slash dopo il dominio
  # Poiché non abbiamo la funzione replace, dobbiamo gestirlo manualmente
  I = instr(PROTOCOLPOS, URL, "//")
  While I > 0
    TEMPURL = mid$(URL, 1, I) + mid$(URL, I + 2, len(URL) - (I + 2) + 1)
    URL = TEMPURL
    I = instr(PROTOCOLPOS, URL, "//")
  Wend

End URL

########################################################
              #Manipolazione stringhe#
########################################################

Subprog YSPLIT(STR,SEP,RESULT,NUMRES)
  Value Char STR,SEP
  Variable Char RESULT()()
  Variable Integer NUMRES

  Local Integer IND,IND2 : IND=1

  Raz RESULT,NUMRES
  If SEP="" End Endif

  While 1
    IND2=instr(IND,STR,SEP)
    If !IND2
      RESULT(NUMRES)=right$(STR,IND)
      If RESULT(NUMRES)<>"" : NUMRES+=1 : Endif
      Break
    Elsif IND2>IND
      RESULT(NUMRES)=seg$(STR,IND,IND2-1)
      NUMRES+=1
      If NUMRES>=dim(RESULT) : Break : Endif
    Endif
    IND=IND2+len(SEP)
  Wend
End

########################################################

Subprog YSPLITCLB(STR,SEP,RESULT,NUMRES)
  Value Clbfile STR
  Value Char SEP
  Variable Clbfile RESULT()()
  Variable Integer NUMRES

  Local Integer IND,IND2 : IND=1

  Raz RESULT,NUMRES
  If SEP="" End Endif

  While 1
    IND2=instr(IND,STR,SEP)
    If !IND2
      RESULT(NUMRES)=right$(STR,IND)
      If RESULT(NUMRES)<>"" : NUMRES+=1 : Endif
      Break
    Elsif IND2>IND
      RESULT(NUMRES)=seg$(STR,IND,IND2-1)
      NUMRES+=1
      If NUMRES>=dim(RESULT) : Break : Endif
    Endif
    IND=IND2+len(SEP)
  Wend
End

########################################################

Subprog YCLB2STRARR(YCLOB, YRESULT)
  Value Clbfile YCLOB
  Variable Char YRESULT ()()
  Local Integer STRNUM, I, START
  Local Integer TOTAL_LEN : TOTAL_LEN = len(YCLOB)

  If len(YCLOB) = 0
    End
  Endif

  STRNUM = int((TOTAL_LEN - 1) / 250) + 1
  For I = 0 To STRNUM - 2
    START = I * 250 + 1
    YRESULT(I) = mid$(YCLOB, START, 250)
  Next

  # Gestione dell'ultimo segmento
  START = (STRNUM - 1) * 250 + 1
  YRESULT(STRNUM - 1) = mid$(YCLOB, START, TOTAL_LEN - START + 1)
End

########################################################

Funprog YJOIN(ARRAY,SEP)
  Value Char ARRAY
  Value Char SEP
  Local Char RESULT(250)

  For I=0 To dim(ARRAY)-1
    If vireblc(num$(ARRAY(I)),2)<>""
      If RESULT<>"" : RESULT+=SEP : Endif
      RESULT+=num$(ARRAY(I))
    Endif
  Next
End RESULT

#######################################################
#**
#* Ritorna la prima posizione nella dell'elemento YKEY nell'array multidim. PARAMS_ARR, se non trovato ritorna -1
#*
#* @param PARAMS_ARR Matrice dove cercare elemento YKEY
#* @param YKEY Elemento da cercare
#*!

Funprog FIND_ITEM(PARAMS_ARR, YKEY)

  Value Char PARAMS_ARR()(,)
  Value Char YKEY
  Local Integer I
  Local Integer J

  YKEY = vireblc(YKEY, 2)
  For I = 0 To func YUTILS.COUNT_MULTI(PARAMS_ARR) - 1 #dim(PARAMS_ARR, 1)
    For J = 0 To dim(PARAMS_ARR, 2) - 1
      If(vireblc(PARAMS_ARR(I, J), 2) = YKEY)
        End I
      Endif
    Next J
  Next I

End -1

################################################################
#**
#* Ritorna la YPOS posizione dell'elemento YKEY nell'array multidim. PARAMS_ARR, se non trovato ritorna -1
#*
#* @param PARAMS_ARR Matrice dove cercare elemento YKEY
#* @param YKEY Elemento da cercare
#* @param YPOS Pos dell'elemento da cercare
#*!

Funprog FIND_MULTITEM(PARAMS_ARR, YKEY, YPOS)

  Value Char PARAMS_ARR()(,)
  Value Char YKEY
  Value Integer YPOS

  Local Integer YMAX: YMAX =dim(PARAMS_ARR,1)*dim(PARAMS_ARR,2)
  Local Integer YFOUND(YMAX)  #array con le posizioni (righe) della YKEY cercata
  Local Integer I,J
  Local Integer INDEX: INDEX =-1
  Local Integer YFOUND_IDX: YFOUND_IDX = -1

  Call YINIT_INTARR(YFOUND,-1)

  YKEY = vireblc(YKEY, 2)
  For I = 0 To dim(PARAMS_ARR, 1) - 1
    For J = 0 To dim(PARAMS_ARR, 2) - 1
      If( vireblc(PARAMS_ARR(I, J),2) = YKEY)
        INDEX +=1
        YFOUND(INDEX)=I
      Endif
    Next J
  Next I

  YFOUND_IDX = func IIF(INDEX >= 0, YFOUND(YPOS), -1)

#Call ECR_TRACE("FIND_MULTITEM -YFOUND_IDX = "- num$(YFOUND_IDX) - "-"-"INDEX = " -num$(INDEX) ,0)From GESECRAN

End YFOUND_IDX

#######################################################
#**
#* Subprog che ritorna l'array con tutti gli indici delle occorennze di YKEY in PARAMS_ARR
#*
#* @param PARAMS_ARR Array dove cercare le occorrenze di un certo item
#* @param YKEY Item di cui cercare le occorrenze
#* @param YFOUND Array con indici delle occorrenze di YKEY nell'array PARAMS_ARR
#*!

Subprog YFIND_OCCS(PARAMS_ARR, YKEY, YFOUND)

  Value Char PARAMS_ARR()(,)
  Value Char YKEY
  Variable Integer YFOUND()

  Local Integer I,J,INDEX: INDEX =-1

  YKEY = vireblc(YKEY, 2)
  For I = 0 To func YUTILS.COUNT_MULTI(PARAMS_ARR) - 1
    For J = 0 To dim(PARAMS_ARR, 2) - 1
      If( vireblc(PARAMS_ARR(I, J),2) = YKEY)
        INDEX +=1
        YFOUND(INDEX)=I
      Endif
    Next J
  Next I
End

#######################################################
#**
#* Subprog che inizializza un intero array 1D di interi con un determinato valore intero
#*
#* @param PARAMS_ARR Array 1D di Interi da inizializzare con un valore di Default
#* @param YDEFINT Valore Intero di default con cui inizializzare l'array
#*!

Subprog YINIT_INTARR(PARAMS_ARR, YDEFINT)

  Variable Integer PARAMS_ARR()
  Value Integer YDEFINT
  Local Integer YI

  For YI = 0 To dim(PARAMS_ARR) - 1
    PARAMS_ARR(YI) = YDEFINT
  Next
End

#######################################################
#**
#* Ritorna la posizione dell'elemento che contiene la sottostringa YKEY nell'array PARAMS_ARR, se non trovato ritorna -1
#*
#* @param PARAMS_ARR Matrice dove cercare elemento YKEY
#* @param YKEY Elemento da cercare
#*!

Funprog CONTAINS_ITEM(PARAMS_ARR, YKEY, FIRST_DIM, SECOND_DIM)

  Value Char PARAMS_ARR()(,)
  Value Char YKEY
  Variable Integer FIRST_DIM
  Variable Integer SECOND_DIM

  Local Integer I
  Local Integer J

  YKEY = vireblc(YKEY, 2)
  FIRST_DIM = func IIF(FIRST_DIM > 0, FIRST_DIM, dim(PARAMS_ARR, 1) - 1)
  SECOND_DIM = func IIF(SECOND_DIM > 0, SECOND_DIM, dim(PARAMS_ARR, 2) - 1)

  For I = 0 To FIRST_DIM
    For J = 0 To SECOND_DIM
      If(instr(1, YKEY, vireblc(PARAMS_ARR(I, J),2)) > 0)
        End I
      Endif
    Next J
  Next I

End -1

########################################################

Funprog FIND1D_ITEM(PARAMS_ARR, YKEY)

  Value Char PARAMS_ARR()()
  Value Char YKEY
  Local Integer I

  YKEY = vireblc(YKEY, 2)
  For I = 0 To dim(PARAMS_ARR, 1) - 1
    If(PARAMS_ARR(I) = YKEY)
      End I
    Endif
  Next I
End -1

#################################################################################
#**
#* Funzione che ritorna l'indice del 1° item deiverso da YKEY (Altrimenti: -1)
#*
#* @param PARAMS_ARR Array dove cercare
#* @param YKEY Elemento con cui confrontare
#*!
Funprog YFIND1D_NOT_EQITEM(PARAMS_ARR, YKEY)

  Value Char PARAMS_ARR()()
  Value Char YKEY
  Local Integer I

  YKEY = vireblc(YKEY, 2)
  For I = 0 To dim(PARAMS_ARR, 1) - 1
    If(vireblc(PARAMS_ARR(I),2)<> AVOID.ACHAR & PARAMS_ARR(I) <> YKEY)
      End I
    Endif
  Next I
End -1

########################################################
#**
#* Metodo che controlla se l'array ha almeno degli elementi distinti
#* (Ritorna: 1 se elementi tutti uguali, 0: se esistono elementi distinti)
#*
#* @param PARAMS_ARR
#*!
Funprog YEXISTDISTINCTS_IN1D(PARAMS_ARR)

  Value Char PARAMS_ARR()()
  Local Integer I,J,YDIM,YDISTINCTS: YDISTINCTS = 1 # =0 esitono DISTINTI , =1 (tutti uguali)
  Local Char YTEMP(250)
  YDIM = dim(PARAMS_ARR, 1)

  For I = 0 To YDIM - 1
    For J = I +1 To YDIM -1

      #elementi non vuoti & distinti
      If(vireblc(PARAMS_ARR(I),2) <> AVOID.ACHAR & vireblc(PARAMS_ARR(J),2) <> AVOID.ACHAR & PARAMS_ARR(I) <> PARAMS_ARR(J))
       YDISTINCTS = 0
       Break 2
      Endif
    Next J
  Next I

End YDISTINCTS

########################################################
#**
#* Metodo che ritorna il 1° indice nell'array in cuisi trova YKEY, escludendo l'indice YEXCL_INDEX.
#* Se non trovato ritorna -1.
#*
#* @param PARAMS_ARR Array dove ricercare
#* @param YKEY  Elemento da ricercare nell'array
#* @param YEXCL_INDEX Indice da escludere
#*!

Funprog YFIND1D_WITHEXCL(PARAMS_ARR, YKEY, YEXCL_INDEX)
  Value Char PARAMS_ARR()()
  Value Char YKEY
  Value Integer YEXCL_INDEX
  Local Integer I

  YKEY = vireblc(YKEY, 2)
  For I = 0 To dim(PARAMS_ARR, 1) - 1
    If(vireblc(PARAMS_ARR(I), 2) <> AVOID.ACHAR & PARAMS_ARR(I) = YKEY & I <> YEXCL_INDEX)
      End I
    Endif
  Next I
End -1

########################################################
Funprog YFINDCOUPLE1D_WITHEXCL(PARAMS1_ARR,PARAMS2_ARR, YKEY1, YKEY2, YEXCL_INDEX)

  Value Char PARAMS1_ARR()()
  Value Char PARAMS2_ARR()()
  Value Char YKEY1
  Value Char YKEY2
  Value Integer YEXCL_INDEX
  Local Integer I

  YKEY1 = vireblc(YKEY1, 2)
  YKEY2 = vireblc(YKEY2, 2)

  For I = 0 To dim(PARAMS1_ARR, 1) - 1
    If(vireblc(PARAMS1_ARR(I), 2) <> AVOID.ACHAR & vireblc(PARAMS2_ARR(I), 2) <> AVOID.ACHAR &
&              PARAMS1_ARR(I) = YKEY1 & PARAMS2_ARR(I) = YKEY2 & I <> YEXCL_INDEX)
      End I
    Endif
  Next I
End -1

##########################################################################
#**
#* Ritorna numero occorrenze dell'elemento YKEY  nella matrice (array 2D) PARAMS_ARR
#*
#* @param PARAMS_ARR Matrice dove cercare numero volte elemento YKEY
#* @param YKEY Elemento di cui cercare il numero delle occorrenze
#*!

Funprog COUNT_ITEM(PARAMS_ARR, YKEY)

  Value Char PARAMS_ARR()(,)
  Value Char YKEY
  Local Integer COUNT : COUNT = 0
  Local Integer I
  Local Integer J

  YKEY = vireblc(YKEY, 2)
  For I = 0 To dim(PARAMS_ARR, 1) - 1
    For J = 0 To dim(PARAMS_ARR, 2) - 1
      If(PARAMS_ARR(I, J) = YKEY)
        COUNT+=1
      Endif
    Next J
  Next I

End COUNT

#####################################################################################
#**
#* Ritorna numero occorrenze dell'elemento YKEY  nell'array 1D PARAMS_ARR
#*
#* @param PARAMS_ARR Array dove cercare numero volte elemento YKEY
#* @param YKEY Elemento di cui cercare il numero delle occorrenze
#*!
Funprog COUNT_1DITEM(PARAMS_ARR, YKEY)

  Value Char PARAMS_ARR()()
  Value Char YKEY
  Local Integer COUNT : COUNT = 0
  Local Integer I

  YKEY = vireblc(YKEY, 2)
  For I = 0 To dim(PARAMS_ARR, 1) - 1
    If(PARAMS_ARR(I) = YKEY)
      COUNT+=1
    Endif
  Next I

End COUNT

########################################################
#**
#* Metodo per conteggio elementi non voti di un array 1D
#*
#* @param ARRAY
#*!

Funprog COUNT(ARRAY)
  Value Char ARRAY()()
  Local Integer COUNT : COUNT = 0

  For I=0 To dim(ARRAY) - 1
    If vireblc(num$(ARRAY(I)), 2) <> AVOID.ACHAR
      COUNT+=1
    Else
      End COUNT
    Endif
  Next
End COUNT

########################################################

Funprog INT_COUNT(INT_ARRAY)

  Value Integer INT_ARRAY()
  Local Integer COUNT : COUNT = 0

  For I=0 To dim(INT_ARRAY) - 1
    If vireblc(num$(INT_ARRAY(I)), 2) <> AVOID.ACHAR
      COUNT+=1
    Else
      End COUNT
    Endif
  Next
End COUNT

########################################################

Funprog COUNT_MULTI(ARRAY)
  Value Char ARRAY()(,)
  Local Integer I, COUNT : COUNT = 0

  For I=0 To dim(ARRAY, 1) - 1
    If vireblc(num$(ARRAY(I, 0)), 2) <> AVOID.ACHAR
      COUNT+=1
    Else
      End COUNT
    Endif
  Next
End COUNT

##########################################################################
#**
#* Funzione per riconfiguare matrice associando in un unico blocco tutte le righe non vuote
#*
#* @param YFIELDS Matrice da riconfigurare
#* @param YTMPFIELDS Matrice d'appoggio delle stesse dimensioni di quella da riconfigurare
#*!

Subprog YHANDLEMAT(YFIELDS,YTMPFIELDS)

   Variable Char YFIELDS()(,)
   Variable Char YTMPFIELDS()(,)
   Local Integer YI,YK,YF: YF = -1

  For YI = 0 To func YUTILS.COUNT_MULTI(YFIELDS) - 1
    #se incontro riga vuota
    If(func YISEMPTYROW(YI, YFIELDS)= 0)
      YF+=1
      For YK = 0 To dim(YFIELDS,2) -1
        YTMPFIELDS(YF,YK)= YFIELDS(YI,YK) #copia delle righe non vuote
      Next
    Endif
  Next

  #raz di yfields
  For YI = 0 To func YUTILS.COUNT_MULTI(YFIELDS) - 1
    For YK = 0 To dim (YFIELDS,2)-1
      Raz YFIELDS(YI,YK)
    Next
  Next

  #copia
  For YI = 0 To func YUTILS.COUNT_MULTI(YTMPFIELDS) - 1
    For YK = 0 To dim (YTMPFIELDS,2)-1
      YFIELDS(YI,YK) = YTMPFIELDS(YI,YK)
    Next
  Next
End

######################################################
#**
#* Funzione che controlla se dato l'indice di una riga (YROW) di una matrice alfanumerica(YFIELDS) è vuota
#*
#* @param YROW Indice della riga da controllare
#* @param YFIELDS Matrice con entries alfanumerici
#*!

Funprog YISEMPTYROW(YROW, YFIELDS)

  Value Integer YROW
  Value Char YFIELDS()(,)
  Local Integer YI, YISEMPTY:YISEMPTY =1

  For YI = 0 To dim(YFIELDS,2) -1
    If(vireblc(YFIELDS(YROW,YI),2) <> AVOID.ACHAR)
      YISEMPTY = 0 #non vuota
      Break
    Endif
  Next
End YISEMPTY

########################################################
# v12 adxuid(1)
Funprog GET_BDDID()
  Local File ALOGIN [F:ALO]
  Read [F:ALO]ALO2 =  num$(adxuid(1))
  End num$([F:ALO]BDDID)
End

########################################################

Funprog GET_ALOSEQ()
  WBDDID=func GET_BDDID()
  Local File ALOGIN[ALO]
  Filter [F:ALO] Where [F:ALO]BDDID=WBDDID and [F:ALO]FLG=2
  Read [F:ALO] First
End [F:ALO]SEQ


########################################################

Funprog IIF(TEST,TRUE,FALSE)
  Value Integer TEST

  If TEST
    End TRUE
  Endif
End FALSE

########################################################

Funprog STR_IIF(TEST, TRUE_STRING, FALSE_STRING)
  Value Integer TEST
  Value Char TRUE_STRING
  Value Char FALSE_STRING

  If TEST
    End TRUE_STRING
  Endif
End FALSE_STRING


#######################################################

Subprog COPYARR(DST,SRC)
  Variable Char DST()()
  Const Char SRC()()
  Local Integer I,N
  N=max(dim(DST),dim(SRC))
  Raz DST
  For I=0 To N-1
    DST(I)=SRC(I)
  Next
End

##################################################

Subprog ARR2MSK(ARRAYVAL,MSKFLD)
  Value Char MSKFLD
  Local Integer I
  For I=0 To dim(ARRAYVAL)-1
    If evalue("dim("+MSKFLD+num$(I+1)+")")>=0
      Assign MSKFLD+num$(I+1) With ARRAYVAL(I)
    Else
      Break
    Endif
  Next
End

##################################################

Funprog COALESCE(V1,V2)
  Local Integer ISNULL,V1T : V1T=type(V1)
  If find(V1T,1,2,4,5,6,7)
    ISNULL=(V1=0)
  Elsif V1T=3
    ISNULL=(V1=[0/0/0])
  Elsif (V1T>10 and V1T<500) or V1T=523
    ISNULL=(V1="")
  Endif
  If ISNULL
    End V2
  Endif
End V1


##################################################
# Sostituzione di una stringa con un'altra
##################################################

Subprog REPLACE(TEXTE,AVANT,APRES)
  Variable Char   TEXTE ()
  Value    Char AVANT ()
  Value    Char APRES ()
  Local    Integer IYA,START
  IYA=1 : START=1
  While IYA
    IYA = instr(START,TEXTE,AVANT)
    If IYA
      TEXTE=left$(TEXTE,IYA-1)+APRES+right$(TEXTE,IYA+len(AVANT))
      START = IYA+len(APRES)
    Endif
  Wend
End


Subprog REPLACE_CLB(TEXTE,AVANT,APRES)
  Variable Clbfile TEXTE ()
  Value    Char AVANT ()
  Value    Char APRES ()
  Local    Integer IYA,START
  IYA=1 : START=1
  While IYA
    IYA = instr(START,TEXTE,AVANT)
    If IYA
      TEXTE=left$(TEXTE,IYA-1)+APRES+right$(TEXTE,IYA+len(AVANT))
      START = IYA+len(APRES)
    Endif
  Wend
End

##################################################
# Trimming di caratteri personalizzati dalle stringhe
##################################################

Funprog TRIM(STR,CAR)
  Value Char STR,CAR

  Local Integer I1,I2
  For I1=1 To len(STR)
    If instr(1,CAR,mid$(STR,I1,1))=0
      Break
    Endif
  Next
  If I1>len(STR) : End "" : Endif
  For I2=len(STR) To 1 Step -1
    If instr(1,CAR,mid$(STR,I2,1))=0
      Break
    Endif
  Next
End mid$(STR,I1,I2-I1+1)

##################################################
# Sostituzione di una parte di testo dichiarata come commento, con un unico carattere
# Esempio: Prova~1=1~Ok~123~~~456, Car ~ dichiarato come tag commento -> Esito: Prova ok 456
##################################################

Subprog REPLACE_COMM(STR,CAR,SOST)
  Variable Char STR,SOST
  Value Char CAR

  Local Integer I1,S1,S2,YOK
  Local Char YRPL(250)
  YOK = 1

  While YOK
    Raz I1,S1,S2,YRPL
    For I1=1 To len(STR)
      If instr(1,mid$(STR,I1,1),CAR)
        If S1=0
          S1=I1
        Else
          S2=I1
          Break
        Endif
      Endif
    Next

    If S1<>0 and S2<>0  # Se ho un replace di commento lo effettuo, altrimenti esco
      YRPL = mid$(STR,S1,S2-S1+1)
      Call REPLACE(STR,YRPL,SOST)
    Else
      YOK=0
    Endif
  Wend

End

##################################################
# Cast per portare da stringa GMA a formato data
# Esempio: "3/9/21" -> Esito: [03/09/2021]
##################################################

Subprog STR_TO_DATE(YSTR,YDAT)
  Value Char YSTR
  Variable Date YDAT

  Local Char RESULT(5)(5)
  Local Integer NUMRES

  Call YSPLIT(YSTR,"/",RESULT,NUMRES)
  If NUMRES < 3 : Raz YDAT : End : Endif

  YDAT = gdat$(val(RESULT(0)),val(RESULT(1)),val(RESULT(2)))

End

#####################################################

Funprog GET_MESS(JVALUE, CODFIC, CODZON)

  Value Char JVALUE
  Value Char CODFIC
  Value Char CODZON

  Local File ATABZON    [ATZ]
  Read [ATZ]CODTYP = 'M';CODFIC;CODZON
  If fstat = 0
    End mess(val(JVALUE), [ATZ]NOLIB, 1)
  Else
    End AVOID.ACHAR
  Endif

End AVOID.ACHAR

######################################################
#**
#* Stampa di un Clob in un file sulla Crt "tmp",dato il Nome e l'estensione
#*
#* @param YCLBFILE Clob da scrivere in un file
#* @param YFILENAME Nome del file su cui scrivere il clob
#* @param YEXTENSION Estensione del file su cui scrivere il clob
#*!

Subprog YPRINT_CLB(YCLBFILE, YFILENAME, YEXTENSION)

  Value Clbfile YCLBFILE
  Value Char YFILENAME
  Value Char YEXTENSION

  Local Char YNOW(50) : YNOW = func YFORMATDATE(num$(datetime$),"DT")
  Local Char YFILA(250) : YFILA=filpath("tmp", YFILENAME + "_" + YNOW, YEXTENSION)
  Openo YFILA Using [YF1]
  Iomode adxifs ";" Using [YF1]
  Iomode adxium GUTF8 Using [YF1]
  Iomode adxirs chr$(13)+chr$(10) Using [YF1]
  Wrseq YCLBFILE Using [YF1]
  Openo Using [YF1]

End

#########################################################################################
Subprog YPRINT_TEXT(YTEXT, YFILENAME, YEXTENSION)

  Value Char YTEXT
  Value Char YFILENAME
  Value Char YEXTENSION

  Local Char YNOW(50) : YNOW = func YFORMATDATE(num$(datetime$),"DT")
  Local Char YFILA(250) : YFILA=filpath("tmp", YFILENAME + "_" + YNOW, YEXTENSION)
  Openo YFILA Using [YF1]
  Iomode adxifs ";" Using [YF1]
  Iomode adxium GUTF8 Using [YF1]
  Iomode adxirs chr$(13)+chr$(10) Using [YF1]
  Wrseq YTEXT Using [YF1]
  Openo Using [YF1]

End

######################################################
#**
#* Stampa di un Clob in un file data la Crt ambiente, il Nome e l'estensione
#*
#* @param YDIR Nome Cartella ambiente in cui creare il file
#* @param YCLBFILE Clob da scrivere in un file
#* @param YFILENAME Nome del file su cui scrivere il clob
#* @param YEXTENSION Estensione del file su cui scrivere il clob
#*!

Subprog YPRINT_DIR_CLB(YDIR, YCLBFILE, YFILENAME, YEXTENSION)

  Value Char YDIR
  Value Clbfile YCLBFILE
  Value Char YFILENAME
  Value Char YEXTENSION

  Local Char YNOW(50) : YNOW = func YFORMATDATE(num$(datetime$),"DT")
  Local Char YFILA(250) : YFILA=filpath(YDIR, YFILENAME + "_" + YNOW, YEXTENSION)
  Openo YFILA Using [YF1]
  Iomode adxifs ";" Using [YF1]
  Iomode adxium GUTF8 Using [YF1]
  Iomode adxirs chr$(13)+chr$(10) Using [YF1]
  Wrseq YCLBFILE Using [YF1]
  Openo Using [YF1]

End

######################################################
#**
#* Metodo per ottenere il format desiderato di una struttura stringa datetime.
#* "D" --> date : AAAA-MM-DD , "T" --> time : hh:mm:ss , "DT" --> AAAA-MM-DD hh:mm:ss
#*
#* @param YDATETIME Stringa con struttura DateTime
#* @param YFORMAT_TYPE Formato che si vuole in output (D: data, T: time, DT: datetime)
#*!
Funprog YFORMATDATE(YDATETIME, YFORMAT_TYPE)

  Value Char YDATETIME
  Value Char YFORMAT_TYPE
  Local Char YRESULT(50)

  # RIMUOVO EVENTUALI DOPPI APICI E NORMALIZZO IL FORMATO DEL Datetime
  # (SOSTITUISCO "/" CON "-" E "." CON ":" E RIMUOVO DOPPI APICI)
  YDATETIME = ctrans(ctrans(ctrans(YDATETIME, "/", "-"), ".", ":"), chr$(22), "")

  Case YFORMAT_TYPE
    When "D"
      # PRENDO SOLO LA PARTE DELLA DATA (PRIMI 10 CARATTERI) E RIMUOVO I SEPARATORI
      YRESULT = ctrans(mid$(YDATETIME, 1, 10), "-", "")

    When "T"
      # PRENDO SOLO LA PORZIONE DEL "time" (12° AL 19° CARATTERE) E RIMUOVO I SEPARATORI
      YRESULT = ctrans(mid$(mid$(YDATETIME, 1, 19), 12, 8), ":", "")

    When "DT"
      # TRONCO DOPO I MILLISECONDI (FINO A 17 CARATTERI), RIMUOVO LA "T" E I SEPARATORI
#      YRESULT = ctrans(ctrans(mid$(YDATETIME, 1, 17), "T", ""), "-", "")
#      YRESULT = ctrans(YRESULT, ":", "")
      YRESULT = ctrans(ctrans(ctrans(mid$(YDATETIME, 1, 17), "T", ""), "-", ""), ":", "")

    When Default
      # RESTITUISCO STRINGA DI ERRORE SE IL TIPO NON È VALIDO
      YRESULT = "Formato non valido"
  Endcase

End YRESULT

######################################################################################################################
# Ritorna il datetime corrente localizzato (datetime$ torna il datetime corrente sul meridiano di greenwich)

Funprog YDATETIME_NOW
  Case(GACTX.LAN)
    When "ITA", "SWE", "DEU", "FRA", "ESP" :
      End func TIMEZONE_CSTD.TO_LOCAL('W. Europe Standard Time', datetime$)
    When "GBR", "IRL" :
      End func TIMEZONE_CSTD.TO_LOCAL('GMT Standard Time', datetime$)
    When "USA", "CAN" :
      End func TIMEZONE_CSTD.TO_LOCAL('Eastern Standard Time', datetime$)
    When "AUS" :
      End func TIMEZONE_CSTD.TO_LOCAL('AUS Eastern Standard Time', datetime$)
    When "JPN" :
      End func TIMEZONE_CSTD.TO_LOCAL('Tokyo Standard Time', datetime$)
    When "CHN" :
      End func TIMEZONE_CSTD.TO_LOCAL('China Standard Time', datetime$)
    When "IND" :
      End func TIMEZONE_CSTD.TO_LOCAL('India Standard Time', datetime$)
    When "BRA" :
      End func TIMEZONE_CSTD.TO_LOCAL('E. South America Standard Time', datetime$)
    When "RUS" :
      End func TIMEZONE_CSTD.TO_LOCAL('Russian Standard Time', datetime$)
    When "ZAF" :
      End func TIMEZONE_CSTD.TO_LOCAL('South Africa Standard Time', datetime$)
    When "ARE" :
      End func TIMEZONE_CSTD.TO_LOCAL('Arabian Standard Time', datetime$)
    When "SGP" :
      End func TIMEZONE_CSTD.TO_LOCAL('Singapore Standard Time', datetime$)
    When "NZL" :
      End func TIMEZONE_CSTD.TO_LOCAL('New Zealand Standard Time', datetime$)
    When "MEX" :
      End func TIMEZONE_CSTD.TO_LOCAL('Central Standard Time', datetime$)
    When "ARG" :
      End func TIMEZONE_CSTD.TO_LOCAL('Argentina Standard Time', datetime$)
    When "KOR" :
      End func TIMEZONE_CSTD.TO_LOCAL('Korea Standard Time', datetime$)
    When "SAU" :
      End func TIMEZONE_CSTD.TO_LOCAL('Arabian Standard Time', datetime$)
    When "TUR" :
      End func TIMEZONE_CSTD.TO_LOCAL('Turkey Standard Time', datetime$)
    When "ISR" :
      End func TIMEZONE_CSTD.TO_LOCAL('Israel Standard Time', datetime$)
    When "EGY" :
      End func TIMEZONE_CSTD.TO_LOCAL('Egypt Standard Time', datetime$)
    When "THA" :
      End func TIMEZONE_CSTD.TO_LOCAL('SE Asia Standard Time', datetime$)
    When "NLD" :
      End func TIMEZONE_CSTD.TO_LOCAL('W. Europe Standard Time', datetime$)
    When "BEL" :
      End func TIMEZONE_CSTD.TO_LOCAL('W. Europe Standard Time', datetime$)
    When "PRT" :
      End func TIMEZONE_CSTD.TO_LOCAL('GMT Standard Time', datetime$)
    When "CHE" :
      End func TIMEZONE_CSTD.TO_LOCAL('W. Europe Standard Time', datetime$)
    When "AUT" :
      End func TIMEZONE_CSTD.TO_LOCAL('W. Europe Standard Time', datetime$)
    When Default:
      End datetime$ #GMT - Meridiano di greenwich
  Endcase
End datetime$

###########################################################################################################
#**
#* Funzione che ritorna il TimeStamp (Data-Ora-millesimi)
#*!

Funprog YGET_TIMESTAMP()
  Local Char YTIME_STAMP(30): YTIME_STAMP = format$("D:YY[.]MM[.]DD[_]hh[.]mm[.]ss", date$) +  "." + format$("N0:3#", mod(val(timestamp$), 1000))
End YTIME_STAMP

############################################################################################################
# ==============================================
# Funzione di utilità per calcolare il timelapse
# fra due timestamp in millisecondi
# ==============================================

Funprog YTIMELAPSE(START_TIMESTAMP, END_TIMESTAMP)
    Value Char START_TIMESTAMP
    Value Char END_TIMESTAMP

    Local Decimal START_TIME, END_TIME, ELAPSED_MS

    # Conversione dei timestamp stringa in numerici
    START_TIME = val(START_TIMESTAMP)
    END_TIME   = val(END_TIMESTAMP)

    # Calcolo differenza in millisecondi
    ELAPSED_MS = END_TIME - START_TIME

    # Ritorno del valore (millisecondi)
End ELAPSED_MS

###########################################################################################################

$JSON_RESPONSE_BUILDER

  Local Clbfile RESPONSE(0)
  Gosub GET_WS_CONSTANTS From YUTILS

  Case fstat
    When 0,2
      RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", SUCCESS, 1)
    When 1
      RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", LOCKED, 0)
      RESPONSE += func YJSONSERIALIZE.GET_STR("message", "La tabella è bloccata.", 1)
    When 3
      RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", CONFLICT, 0)
      RESPONSE += func YJSONSERIALIZE.GET_STR("message", "Tentativo di creare un valore chiave duplicato.", 1)
    When 4
      RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", INTERNAL_SERVER_ERROR, 0)
      RESPONSE += func YJSONSERIALIZE.GET_STR("message", "Raggiunto inizio o fine della tabella.", 1)
    When 7
      RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", NOT_FOUND, 0)
      RESPONSE += func YJSONSERIALIZE.GET_STR("message", "La classe non esiste (nessuna tabella aperta con l'abbreviazione corrispondente).", 1)
    When 27
      RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", BAD_REQUEST, 0)
      RESPONSE += func YJSONSERIALIZE.GET_STR("message", "Tentativo di scrittura su un'abbreviazione Link.", 1)
    When 44, 65
      RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", INSUFFICIENT_STORAGE, 0)
      RESPONSE += func YJSONSERIALIZE.GET_STR("message", "Spazio insufficiente per creare nuove righe.", 1)
    When 75
      RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", INTERNAL_SERVER_ERROR, 0)
      RESPONSE += func YJSONSERIALIZE.GET_STR("message", "Errore del database.", 1)
    When Default
      RESPONSE = func YJSONSERIALIZE.GET_INT("statusCode", INTERNAL_SERVER_ERROR, 0)
      RESPONSE += func YJSONSERIALIZE.GET_STR("message", "Errore sconosciuto durante la scrittura.", 1)
  Endcase

  YRESPONSE = func YJSONSERIALIZE.GET_JSON(RESPONSE)

Return

###########################################################################################################

Funprog YGET_PASSWORD()

    Local Char YLOWERCASE_CHARS(50) : YLOWERCASE_CHARS = "abcdefghijklmnopqrstuvwxyz"
    Local Char YUPPERCASE_CHARS(50): YUPPERCASE_CHARS = toupper(YLOWERCASE_CHARS)
    Local Char YNUMBERS(10) : YNUMBERS = "0123456789"
    Local Char YSPECIALCHRS(25): YSPECIALCHRS = "\|!£$%&/()=?@-<>#_*+]["
    Local Char YALL_CHARS(150): YALL_CHARS = YLOWERCASE_CHARS + YUPPERCASE_CHARS + YNUMBERS + YSPECIALCHRS
    Local Char YPASSWORD(1)(10)
    Local Integer YNUM, YI, YJ, YSEED
    Local Char YTEMP(1), YPASSWORD_STR(10)

    # Genera i primi 4 caratteri rispettando i criteri
    YPASSWORD(0) = xgetchar(YLOWERCASE_CHARS, fix(rnd(len(YLOWERCASE_CHARS)) + 1))
    YPASSWORD(1) = xgetchar(YUPPERCASE_CHARS, fix(rnd(len(YUPPERCASE_CHARS)) + 1))
    YPASSWORD(2) = xgetchar(YNUMBERS, fix(rnd(len(YNUMBERS)) + 1))
    YPASSWORD(3) = xgetchar(YSPECIALCHRS, fix(rnd(len(YSPECIALCHRS)) + 1))

    # Riempie i rimanenti caratteri con valori casuali
    For YI=4 To dim(YPASSWORD,1)-1
      YPASSWORD(YI) = xgetchar(YALL_CHARS, fix(rnd(len(YALL_CHARS)) + 1))
    Next

    # Mescolamento della password per maggiore casualità
    For YI=0 To dim(YPASSWORD,1)-1
      YJ = fix(rnd(dim(YPASSWORD,1))) # Numero casuale tra 0 e dim-1
      YTEMP = YPASSWORD(YJ)
      YPASSWORD(YJ) = YPASSWORD(YI)
      YPASSWORD(YI) = YTEMP
    Next

    # Creazione della stringa finale della password
    For YI=0 To dim(YPASSWORD,1)-1
      YPASSWORD_STR += YPASSWORD(YI)
    Next

End YPASSWORD_STR

###########################################################################################################################################

Funprog YCHECK_PASSWORD(YPASSWORD)
  Value Char YPASSWORD

  Local Char YLOWERCASE_CHARS(50) : YLOWERCASE_CHARS = "abcdefghijklmnopqrstuvwxyz"
  Local Char YUPPERCASE_CHARS(50): YUPPERCASE_CHARS = toupper(YLOWERCASE_CHARS)
  Local Char YNUMBERS(10) : YNUMBERS = "0123456789"
  Local Char YSPECIALCHRS(25): YSPECIALCHRS = "\|!£$%&/()=?@-<>.#,;_*+]["
  Local Integer YHAS_LOWER, YHAS_UPPER, YHAS_NUMBER, YHAS_SPECIAL, YI

  # Inizializza flag per i criteri
  YHAS_LOWER = 0
  YHAS_UPPER = 0
  YHAS_NUMBER = 0
  YHAS_SPECIAL = 0
  YHAS_VALID_LENGHT = func YUTILS.IIF(len(YPASSWORD) >= 8, 1, 0)   #LUNGHEZZA ALMENO 8 CARATTERI

  # Check for lowercase letter
  For YI = 1 To len(YLOWERCASE_CHARS)
    If instr(1, YPASSWORD, mid$(YLOWERCASE_CHARS,YI,1)) <> 0
      YHAS_LOWER = 1
      Break
    Endif
  Next

  # Check for uppercase letter
  For YI = 1 To len(YUPPERCASE_CHARS)
    If instr(1, YPASSWORD, mid$(YUPPERCASE_CHARS,YI,1)) <> 0
      YHAS_UPPER = 1
      Break
    Endif
  Next

  # Check for number
  For YI = 1 To len(YNUMBERS)
    If instr(1, YPASSWORD, mid$(YNUMBERS,YI,1)) <> 0
      YHAS_NUMBER = 1
      Break
    Endif
  Next

  # Check for special character
  For YI = 1 To len(YSPECIALCHRS)
    If instr(1, YPASSWORD, mid$(YSPECIALCHRS,YI,1)) <> 0
      YHAS_SPECIAL = 1
      Break
    Endif
  Next

  # Verifica se tutti i criteri sono rispettati
#Infbox "YHAS_LOWER" - num$(YHAS_LOWER) - "- YHAS_UPPER:" - num$(YHAS_UPPER) - "- YHAS_NUMBER" - num$(YHAS_NUMBER) - "- YHAS_SPECIAL" - num$(YHAS_SPECIAL)
  If YHAS_LOWER = 1 and YHAS_UPPER = 1 and YHAS_NUMBER = 1 and YHAS_SPECIAL = 1 & YHAS_VALID_LENGHT = 1
    End 1
  Else
    End 0
  Endif

End

##################################################################################################################
Funprog ENCODE_URL(_URL)
  Variable Char _URL
  Local Char CHR(1)
  Local Char URL(250)

  For I=1 To len(_URL)
    CHR = mid$(_URL,I,1)
    If find(CHR,",","/","?",":","@","&","=","+","#"," ",'"',"'","%")
      URL += "%40"
    Else
      URL+= CHR
    Endif
  Next
End URL


###################################################################################################################
#                                            GESTIONE FILE SYSTEM
###################################################################################################################
#**
#* Creazione Cartella dato il Percorso ed il Nome
#*
#* @param YDIRPATH Percorso della crt da creare
#* @param YDIRNAME Nome della crt da creare
#*!
Subprog YCREATE_DIRECTORY(YDIRPATH,YDIRNAME)

  Value Char YDIRPATH
  Value Char YDIRNAME

  Local Char YDIR(250):YDIR = YDIRPATH+"\"+YDIRNAME
  Local Integer YSTAT
  Call SYSTEME (adxmac(0),"ae_mkdir"-'"'+YDIR+'"',"",YSTAT) From ORDSYS
End
**********
7,"TRT","YUTILS",""
8,"Patch per Trattamenti CORE - v1.2"
